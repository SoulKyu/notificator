// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func NotificationService() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\t// Browser Notification Service\n\t\twindow.NotificationService = {\n\t\t\t// State\n\t\t\tpermissionGranted: false,\n\t\t\tpreferences: {\n\t\t\t\tbrowserNotificationsEnabled: false,\n\t\t\t\tenabledSeverities: ['critical', 'warning'],\n\t\t\t\tsoundNotificationsEnabled: true\n\t\t\t},\n\t\t\tseenAlerts: new Set(),\n\n\t\t\t// Initialize the notification service\n\t\t\tasync init(userID) {\n\t\t\t\tconsole.log('Initializing NotificationService...');\n\n\t\t\t\t// Load preferences from backend\n\t\t\t\tawait this.loadPreferences();\n\n\t\t\t\t// Check current browser permission status\n\t\t\t\tif ('Notification' in window) {\n\t\t\t\t\tthis.permissionGranted = Notification.permission === 'granted';\n\t\t\t\t\tconsole.log('Notification permission status:', Notification.permission);\n\n\t\t\t\t\t// Auto-enable if browser permission granted but preference not saved\n\t\t\t\t\tif (this.permissionGranted && !this.preferences.browserNotificationsEnabled) {\n\t\t\t\t\t\tthis.preferences.browserNotificationsEnabled = true;\n\t\t\t\t\t\tawait this.savePreferences(this.preferences);\n\t\t\t\t\t\tconsole.log('Auto-enabled browser notifications (permission already granted)');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('Browser does not support notifications');\n\t\t\t\t}\n\n\t\t\t\t// Initialize seen alerts from sessionStorage\n\t\t\t\tconst storageKey = 'notificator_seen_alerts_' + userID;\n\t\t\t\tconst stored = sessionStorage.getItem(storageKey);\n\t\t\t\tif (stored) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst fingerprints = JSON.parse(stored);\n\t\t\t\t\t\tthis.seenAlerts = new Set(fingerprints);\n\t\t\t\t\t\tconsole.log('Loaded', this.seenAlerts.size, 'seen alerts from storage');\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error('Failed to parse seen alerts:', e);\n\t\t\t\t\t\tthis.seenAlerts = new Set();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Load notification preferences from backend\n\t\t\tasync loadPreferences() {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch('/api/v1/notifications/preferences', {\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\n\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\tif (result.success && result.data) {\n\t\t\t\t\t\t\tthis.preferences = {\n\t\t\t\t\t\t\t\tbrowserNotificationsEnabled: result.data.browser_notifications_enabled || false,\n\t\t\t\t\t\t\t\tenabledSeverities: result.data.enabled_severities || ['critical', 'warning'],\n\t\t\t\t\t\t\t\tsoundNotificationsEnabled: result.data.sound_notifications_enabled !== undefined ? result.data.sound_notifications_enabled : true\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tconsole.log('Loaded notification preferences:', this.preferences);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Failed to load notification preferences:', error);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Save notification preferences to backend\n\t\t\tasync savePreferences(preferences) {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch('/api/v1/notifications/preferences', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\tbrowser_notifications_enabled: preferences.browserNotificationsEnabled,\n\t\t\t\t\t\t\tenabled_severities: preferences.enabledSeverities\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\n\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.preferences = preferences;\n\t\t\t\t\t\t\tconsole.log('Saved notification preferences');\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Failed to save notification preferences:', error);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Request browser notification permission\n\t\t\tasync requestPermission() {\n\t\t\t\tif (!('Notification' in window)) {\n\t\t\t\t\tconsole.warn('Browser does not support notifications');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst permission = await Notification.requestPermission();\n\t\t\t\t\tthis.permissionGranted = permission === 'granted';\n\t\t\t\t\tconsole.log('Notification permission:', permission);\n\t\t\t\t\treturn this.permissionGranted;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Failed to request notification permission:', error);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Initialize seen alerts (call on dashboard load)\n\t\t\tinitializeSeenAlerts(alerts, userID) {\n\t\t\t\tconst fingerprints = alerts.map(a => a.fingerprint);\n\t\t\t\tthis.seenAlerts = new Set(fingerprints);\n\n\t\t\t\t// Save to sessionStorage\n\t\t\t\tconst storageKey = 'notificator_seen_alerts_' + userID;\n\t\t\t\tsessionStorage.setItem(storageKey, JSON.stringify(fingerprints));\n\n\t\t\t\tconsole.log('Initialized', this.seenAlerts.size, 'seen alerts');\n\t\t\t},\n\n\t\t\t// Mark alerts as seen\n\t\t\tmarkAsSeen(fingerprints, userID) {\n\t\t\t\tfingerprints.forEach(fp => this.seenAlerts.add(fp));\n\n\t\t\t\t// Save to sessionStorage\n\t\t\t\tconst storageKey = 'notificator_seen_alerts_' + userID;\n\t\t\t\tsessionStorage.setItem(storageKey, JSON.stringify(Array.from(this.seenAlerts)));\n\t\t\t},\n\n\t\t\t// Detect new alerts (not in seen set)\n\t\t\tdetectNewAlerts(alerts) {\n\t\t\t\treturn alerts.filter(alert => !this.seenAlerts.has(alert.fingerprint));\n\t\t\t},\n\n\t\t\t// Check if we should notify for this alert\n\t\t\tshouldNotify(alert) {\n\t\t\t\t// Check if notifications are enabled\n\t\t\t\tif (!this.preferences.browserNotificationsEnabled) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Check if browser permission granted\n\t\t\t\tif (!this.permissionGranted) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Check if severity is enabled\n\t\t\t\tconst severity = alert.severity || alert.labels?.severity || 'info';\n\t\t\t\tconst normalizedSeverity = severity.toLowerCase();\n\n\t\t\t\t// Handle 'information' as 'info'\n\t\t\t\tconst severityToCheck = normalizedSeverity === 'information' ? 'info' : normalizedSeverity;\n\n\t\t\t\tif (!this.preferences.enabledSeverities.includes(severityToCheck)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t// Get notification icon based on severity\n\t\t\tgetNotificationIcon(severity) {\n\t\t\t\tconst severityLower = severity.toLowerCase();\n\t\t\t\tconst iconMap = {\n\t\t\t\t\t'critical': '/static/images/critical-icon.png',\n\t\t\t\t\t'critical-daytime': '/static/images/critical-icon.png',\n\t\t\t\t\t'warning': '/static/images/warning-icon.png',\n\t\t\t\t\t'info': '/static/images/info-icon.png',\n\t\t\t\t\t'information': '/static/images/info-icon.png',\n\t\t\t\t\t'success': '/static/images/success-icon.png'\n\t\t\t\t};\n\t\t\t\treturn iconMap[severityLower] || '/static/images/default-icon.png';\n\t\t\t},\n\n\t\t\t// Get notification sound based on severity\n\t\t\tgetNotificationSound(severity) {\n\t\t\t\tconst severityLower = severity.toLowerCase();\n\t\t\t\tconst soundMap = {\n\t\t\t\t\t'critical': '/static/sounds/critical.mp3',\n\t\t\t\t\t'critical-daytime': '/static/sounds/critical.mp3',\n\t\t\t\t\t'warning': '/static/sounds/warning.mp3',\n\t\t\t\t\t'info': '/static/sounds/info.mp3',\n\t\t\t\t\t'information': '/static/sounds/info.mp3'\n\t\t\t\t};\n\t\t\t\treturn soundMap[severityLower] || '/static/sounds/info.mp3';\n\t\t\t},\n\n\t\t\t// Play notification sound\n\t\t\tplayNotificationSound(severity) {\n\t\t\t\t// Check if sounds are enabled\n\t\t\t\tif (!this.preferences.soundNotificationsEnabled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst soundFile = this.getNotificationSound(severity);\n\t\t\t\t\tconst audio = new Audio(soundFile);\n\t\t\t\t\taudio.volume = 0.7; // Fixed volume at 70%\n\n\t\t\t\t\t// Play with error handling\n\t\t\t\t\taudio.play().catch(err => {\n\t\t\t\t\t\t// Browsers may block autoplay - this is expected\n\t\t\t\t\t\tconsole.warn('Could not play notification sound (may be blocked by browser):', err.message);\n\t\t\t\t\t});\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error creating audio for notification sound:', error);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Show browser notification\n\t\t\tshowNotification(alert) {\n\t\t\t\tif (!this.shouldNotify(alert)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst alertName = alert.alertName || alert.labels?.alertname || 'Alert';\n\t\t\t\tconst summary = alert.summary || alert.annotations?.summary || '';\n\t\t\t\tconst severity = alert.severity || alert.labels?.severity || 'info';\n\t\t\t\tconst source = alert.source || '';\n\t\t\t\t// Capture fingerprint to ensure it's available in the click handler closure\n\t\t\t\tconst fingerprint = alert.fingerprint;\n\n\t\t\t\t// Validate fingerprint exists\n\t\t\t\tif (!fingerprint) {\n\t\t\t\t\tconsole.error('Cannot show notification: alert fingerprint is missing', alert);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Play notification sound\n\t\t\t\tthis.playNotificationSound(severity);\n\n\t\t\t\tconst title = `Alert: ${alertName}`;\n\t\t\t\tconst body = summary || `${severity.toUpperCase()} alert from ${source}`;\n\n\t\t\t\tconst options = {\n\t\t\t\t\tbody: body,\n\t\t\t\t\ticon: this.getNotificationIcon(severity),\n\t\t\t\t\tbadge: '/static/images/default-icon.png',\n\t\t\t\t\ttag: fingerprint, // Prevents duplicates\n\t\t\t\t\trequireInteraction: severity.toLowerCase() === 'critical',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tfingerprint: fingerprint,\n\t\t\t\t\t\talertName: alertName\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\ttry {\n\t\t\t\t\tconst notification = new Notification(title, options);\n\n\t\t\t\t\t// Handle notification click - navigate to alert details\n\t\t\t\t\tnotification.onclick = () => {\n\t\t\t\t\t\t\twindow.focus();\n\n\t\t\t\t\t\t\t// Validate fingerprint before navigation\n\t\t\t\t\t\t\tif (!fingerprint) {\n\t\t\t\t\t\t\t\tconsole.error('Cannot navigate: fingerprint is missing');\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconsole.log('Notification clicked, navigating to alert:', fingerprint);\n\n\t\t\t\t\t\t\t// Check if we're already on the dashboard\n\t\t\t\t\t\t\tif (window.location.pathname.startsWith('/dashboard')) {\n\t\t\t\t\t\t\t\t// Already on dashboard - just open the modal directly\n\t\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showAlertDetails) {\n\t\t\t\t\t\t\t\t\twindow.dashboardInstance.showAlertDetails(fingerprint);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Fallback: navigate to the URL\n\t\t\t\t\t\t\t\t\twindow.location.href = `/dashboard/alert/${fingerprint}`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Navigate to dashboard with alert ID\n\t\t\t\t\t\t\t\twindow.location.href = `/dashboard/alert/${fingerprint}`;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnotification.close();\n\t\t\t\t\t\t};\n\n\t\t\t\t\tconsole.log('Showed notification for alert:', alertName, 'fingerprint:', fingerprint);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Failed to show notification:', error);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Process new alerts and show notifications\n\t\t\tprocessNewAlerts(allAlerts, currentFilters, userID) {\n\t\t\t\t// Detect which alerts are new\n\t\t\t\tconst newAlerts = this.detectNewAlerts(allAlerts);\n\n\t\t\t\tif (newAlerts.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconsole.log('Processing', newAlerts.length, 'new alerts for notifications');\n\n\t\t\t\t// Show notifications for new alerts with staggered delay to avoid browser spam\n\t\t\t\tnewAlerts.forEach((alert, index) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tthis.showNotification(alert);\n\t\t\t\t\t}, index * 500); // 500ms stagger between each notification\n\t\t\t\t});\n\n\t\t\t\t// Mark new alerts as seen\n\t\t\t\tconst newFingerprints = newAlerts.map(a => a.fingerprint);\n\t\t\t\tthis.markAsSeen(newFingerprints, userID);\n\t\t\t},\n\n\t\t\t// Get severity color for notification icons\n\t\t\tgetSeverityColor(severity) {\n\t\t\t\tconst colors = {\n\t\t\t\t\tcritical: '#dc2626',      // red-600\n\t\t\t\t\t'critical-daytime': '#be123c', // rose-700\n\t\t\t\t\twarning: '#d97706',       // amber-600\n\t\t\t\t\tinfo: '#2563eb',          // blue-600\n\t\t\t\t\tinformation: '#2563eb',   // blue-600\n\t\t\t\t\tdefault: '#6b7280'        // gray-500\n\t\t\t\t};\n\t\t\t\treturn colors[severity.toLowerCase()] || colors.default;\n\t\t\t}\n\t\t};\n\n\t\t// Make it globally available\n\t\twindow.notificationService = window.NotificationService;\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
