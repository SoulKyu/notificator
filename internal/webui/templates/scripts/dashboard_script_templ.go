// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func DashboardScript() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\tfunction newDashboard() {\n\t\t\treturn {\n\t\t\t\t// Core state\n\t\t\t\tloading: true,\n\t\t\t\talerts: [],\n\t\t\t\tgroups: [],\n\t\t\t\tmetadata: {\n\t\t\t\t\ttotalAlerts: 0,\n\t\t\t\t\tfilteredCount: 0,\n\t\t\t\t\tlastUpdate: null,\n\t\t\t\t\tcounters: {\n\t\t\t\t\t\tcritical: 0,\n\t\t\t\t\t\twarning: 0,\n\t\t\t\t\t\tinfo: 0,\n\t\t\t\t\t\tfiring: 0,\n\t\t\t\t\t\tresolved: 0,\n\t\t\t\t\t\tacknowledged: 0,\n\t\t\t\t\t\twithComments: 0\n\t\t\t\t\t},\n\t\t\t\t\tavailableFilters: {\n\t\t\t\t\t\talertmanagers: [],\n\t\t\t\t\t\tseverities: [],\n\t\t\t\t\t\tstatuses: [],\n\t\t\t\t\t\tteams: []\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsettings: {\n\t\t\t\t\ttheme: 'light',\n\t\t\t\t\tnotificationsEnabled: true,\n\t\t\t\t\tsoundEnabled: true,\n\t\t\t\t\tresolvedAlertsRetention: 1,\n\t\t\t\t\trefreshInterval: 5,\n\t\t\t\t\tnotificationDelay: 1500,\n\t\t\t\t\tmaxConcurrentNotifications: 3,\n\t\t\t\t\tnotificationBatching: true,\n\t\t\t\t\tprioritizedNotifications: true\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Remove resolved alerts state\n\t\t\t\tisRemovingResolvedAlerts: false,\n\t\t\t\t\n\t\t\t\t// UI state\n\t\t\t\tdisplayMode: 'classic',\n\t\t\t\tviewMode: 'list',\n\t\t\t\tsortField: 'duration',\n\t\t\t\tsortDirection: 'asc',\n\t\t\t\tshowSettings: false,\n\t\t\t\t\n\t\t\t\t// Acknowledgment modal state\n\t\t\t\tshowAckModal: false,\n\t\t\t\tackAction: 'single', // 'single', 'bulk', or 'group'\n\t\t\t\tackReason: '',\n\t\t\t\tackError: '',\n\t\t\t\tackSubmitting: false,\n\t\t\t\tcurrentAckAlert: null,\n\t\t\t\tcurrentGroupName: '',\n\t\t\t\t\n\t\t\t\t// Alert details modal state\n\t\t\t\tshowAlertModal: false,\n\t\t\t\talertDetails: null,\n\t\t\t\tcurrentAlertTab: 'overview',\n\t\t\t\talertDetailsLoading: false,\n\t\t\t\t\n\t\t\t\t// Comment management state\n\t\t\t\tnewCommentContent: '',\n\t\t\t\tcommentSubmitting: false,\n\t\t\t\tcommentDeleting: {},\n\t\t\t\tcurrentUser: null,\n\t\t\t\t\n\t\t\t\t// Filter state\n\t\t\t\tsearchQuery: '',\n\t\t\t\tfilters: {\n\t\t\t\t\talertmanagers: [],\n\t\t\t\t\tseverities: [],\n\t\t\t\t\tstatuses: [],\n\t\t\t\t\tteams: []\n\t\t\t\t},\n\t\t\t\tacknowledgmentFilter: null,\n\t\t\t\tcommentsFilter: null,\n\t\t\t\t\n\t\t\t\t// Selection state\n\t\t\t\tselectedAlerts: [],\n\t\t\t\tselectedGroups: [],\n\t\t\t\texpandedGroups: [],\n\t\t\t\t\n\t\t\t\t// Auto-refresh\n\t\t\t\trefreshInterval: null,\n\t\t\t\tlastUpdateTime: null,\n\t\t\t\t\n\t\t\t\t// Color preferences\n\t\t\t\talertColors: {}, // fingerprint -> ColorResult\n\t\t\t\talertColorsTimestamp: 0, // when colors were last loaded\n\t\t\t\t\n\t\t\t\t// Sound objects\n\t\t\t\tcriticalSound: null,\n\t\t\t\twarningSound: null,\n\t\t\t\t\n\t\t\t\t// Notification queue system\n\t\t\t\tnotificationQueue: [],\n\t\t\t\taudioQueue: [],\n\t\t\t\tisProcessingNotifications: false,\n\t\t\t\tisProcessingAudio: false,\n\t\t\t\tmaxConcurrentNotifications: 3,\n\t\t\t\tnotificationDelay: 1500, // milliseconds between notifications\n\t\t\t\tactiveNotifications: new Set(),\n\t\t\t\tnotificationProcessingTimer: null,\n\t\t\t\taudioProcessingTimer: null,\n\t\t\t\t\n\t\t\t\t// Resizable columns\n\t\t\t\tcolumnWidths: {\n\t\t\t\t\talertName: 300,\n\t\t\t\t\tacknowledge: 75,\n\t\t\t\t\tacknowledge: 125,\n\t\t\t\t\tinstance: 350,\n\t\t\t\t\tseverity: 150,\n\t\t\t\t\tstatus: 150,\n\t\t\t\t\tcomments: 130,\n\t\t\t\t\tteam: 200,\n\t\t\t\t\tsummary: 400,\n\t\t\t\t\tduration: 150,\n\t\t\t\t\tsource: 180\n\t\t\t\t},\n\t\t\t\tisResizing: false,\n\t\t\t\tstartX: 0,\n\t\t\t\tstartWidth: 0,\n\t\t\t\tcurrentColumn: null,\n\n\t\t\t\t// Utility function to map status for display\n\t\t\t\tgetDisplayStatus(status) {\n\t\t\t\t\tif (!status?.state) return 'unknown';\n\t\t\t\t\t// Map 'suppressed' to 'silenced' for UI display\n\t\t\t\t\treturn status.state === 'suppressed' ? 'silenced' : status.state;\n\t\t\t\t},\n\n\t\t\t\t// Utility function to check if status matches a value (handles suppressed->silenced mapping)\n\t\t\t\tstatusMatches(status, value) {\n\t\t\t\t\tconst displayStatus = this.getDisplayStatus(status);\n\t\t\t\t\treturn displayStatus === value;\n\t\t\t\t},\n\n\t\t\t\tinit() {\n\t\t\t\t\tthis.loadSettings();\n\t\t\t\t\tthis.loadFiltersFromURL();\n\t\t\t\t\tthis.initializeSounds();\n\t\t\t\t\tthis.loadColumnWidths();\n\t\t\t\t\tthis.loadCurrentUser();\n\t\t\t\t\tthis.startAutoRefresh();\n\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t\n\t\t\t\t\t// Check if URL contains alert ID and open modal\n\t\t\t\t\tthis.checkAlertFromURL();\n\t\t\t\t\t\n\t\t\t\t\t// Listen for visibility changes to pause/resume refresh\n\t\t\t\t\tdocument.addEventListener('visibilitychange', () => {\n\t\t\t\t\t\tif (document.hidden) {\n\t\t\t\t\t\t\tthis.stopAutoRefresh();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.startAutoRefresh();\n\t\t\t\t\t\t\t// Use incremental update when coming back from hidden\n\t\t\t\t\t\t\tthis.loadDashboardIncremental();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t// Add global mouse events for resizing\n\t\t\t\t\tdocument.addEventListener('mousemove', this.handleMouseMove.bind(this));\n\t\t\t\t\tdocument.addEventListener('mouseup', this.handleMouseUp.bind(this));\n\t\t\t\t},\n\n\t\t\t\t// Data loading - initial load with full data\n\t\t\t\tasync loadDashboardData() {\n\t\t\t\t\tthis.loading = true;\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst params = new URLSearchParams();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add current filters to request\n\t\t\t\t\t\tif (this.searchQuery) params.set('search', this.searchQuery);\n\t\t\t\t\t\tif (this.filters.alertmanagers.length > 0) params.set('alertmanagers', this.filters.alertmanagers.join(','));\n\t\t\t\t\t\tif (this.filters.severities.length > 0) params.set('severities', this.filters.severities.join(','));\n\t\t\t\t\t\tif (this.filters.statuses.length > 0) params.set('statuses', this.filters.statuses.join(','));\n\t\t\t\t\t\tif (this.filters.teams.length > 0) params.set('teams', this.filters.teams.join(','));\n\t\t\t\t\t\t\n\t\t\t\t\t\tparams.set('displayMode', this.displayMode);\n\t\t\t\t\t\tparams.set('viewMode', this.viewMode);\n\t\t\t\t\t\tparams.set('sortField', this.sortField);\n\t\t\t\t\t\tparams.set('sortDirection', this.sortDirection);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (this.acknowledgmentFilter) params.set('acknowledged', this.acknowledgmentFilter);\n\t\t\t\t\t\tif (this.commentsFilter) params.set('hasComments', this.commentsFilter);\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/data?${params.toString()}`, {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tconst oldAlerts = this.alerts;\n\t\t\t\t\t\t\tthis.alerts = result.data.alerts || [];\n\t\t\t\t\t\t\tthis.groups = result.data.groups || [];\n\t\t\t\t\t\t\tthis.metadata = result.data.metadata;\n\t\t\t\t\t\t\tthis.settings = { ...this.settings, ...result.data.settings };\n\t\t\t\t\t\t\tthis.lastUpdateTime = Date.now();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Check for new alerts for notifications\n\t\t\t\t\t\t\tthis.checkForNewAlerts(oldAlerts, this.alerts);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Load custom alert colors\n\t\t\t\t\t\t\tawait this.loadAlertColors();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.updateURL();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to load alerts: ' + result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading dashboard data:', error);\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to load dashboard data');\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.loading = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Incremental update - only fetch changes\n\t\t\t\tasync loadDashboardIncremental() {\n\t\t\t\t\t// Don't show loading spinner for incremental updates\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst params = new URLSearchParams();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add current filters to request\n\t\t\t\t\t\tif (this.searchQuery) params.set('search', this.searchQuery);\n\t\t\t\t\t\tif (this.filters.alertmanagers.length > 0) params.set('alertmanagers', this.filters.alertmanagers.join(','));\n\t\t\t\t\t\tif (this.filters.severities.length > 0) params.set('severities', this.filters.severities.join(','));\n\t\t\t\t\t\tif (this.filters.statuses.length > 0) params.set('statuses', this.filters.statuses.join(','));\n\t\t\t\t\t\tif (this.filters.teams.length > 0) params.set('teams', this.filters.teams.join(','));\n\t\t\t\t\t\t\n\t\t\t\t\t\tparams.set('displayMode', this.displayMode);\n\t\t\t\t\t\tparams.set('viewMode', this.viewMode);\n\t\t\t\t\t\tparams.set('sortField', this.sortField);\n\t\t\t\t\t\tparams.set('sortDirection', this.sortDirection);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (this.acknowledgmentFilter) params.set('acknowledged', this.acknowledgmentFilter);\n\t\t\t\t\t\tif (this.commentsFilter) params.set('hasComments', this.commentsFilter);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Include current alert fingerprints for comparison\n\t\t\t\t\t\tconst currentFingerprints = this.alerts.map(a => a.fingerprint).join(',');\n\t\t\t\t\t\tif (currentFingerprints) {\n\t\t\t\t\t\t\tparams.set('clientAlerts', currentFingerprints);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (this.lastUpdateTime) {\n\t\t\t\t\t\t\tparams.set('lastUpdate', Math.floor(this.lastUpdateTime / 1000).toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/incremental?${params.toString()}`, {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.applyIncrementalUpdate(result.data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Fallback to full refresh if incremental fails\n\t\t\t\t\t\t\tconsole.warn('Incremental update failed, falling back to full refresh');\n\t\t\t\t\t\t\tawait this.loadDashboardData();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading incremental data:', error);\n\t\t\t\t\t\t// Fallback to full refresh on error\n\t\t\t\t\t\tawait this.loadDashboardData();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Load alert colors from user preferences\n\t\t\t\tasync loadAlertColors(force = false) {\n\t\t\t\t\t// Skip loading if colors are already loaded and not forcing refresh\n\t\t\t\t\tif (!force && Object.keys(this.alertColors).length > 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconsole.log('Loading alert colors...');\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Build same URL parameters as dashboard data API\n\t\t\t\t\t\tconst params = new URLSearchParams();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add current filters to request\n\t\t\t\t\t\tif (this.searchQuery) params.set('search', this.searchQuery);\n\t\t\t\t\t\tif (this.filters.alertmanagers.length > 0) params.set('alertmanagers', this.filters.alertmanagers.join(','));\n\t\t\t\t\t\tif (this.filters.severities.length > 0) params.set('severities', this.filters.severities.join(','));\n\t\t\t\t\t\tif (this.filters.statuses.length > 0) params.set('statuses', this.filters.statuses.join(','));\n\t\t\t\t\t\tif (this.filters.teams.length > 0) params.set('teams', this.filters.teams.join(','));\n\t\t\t\t\t\t\n\t\t\t\t\t\tparams.set('displayMode', this.displayMode);\n\t\t\t\t\t\tparams.set('viewMode', this.viewMode);\n\t\t\t\t\t\tparams.set('sortField', this.sortField);\n\t\t\t\t\t\tparams.set('sortDirection', this.sortDirection);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (this.acknowledgmentFilter) params.set('acknowledged', this.acknowledgmentFilter);\n\t\t\t\t\t\tif (this.commentsFilter) params.set('hasComments', this.commentsFilter);\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert-colors?${params.toString()}`, {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.alertColors = result.data.colors || {};\n\t\t\t\t\t\t\tthis.alertColorsTimestamp = result.data.timestamp || Date.now();\n\t\t\t\t\t\t\tconsole.log(`Loaded colors for ${Object.keys(this.alertColors).length} alerts`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.warn('Failed to load alert colors:', result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading alert colors:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Invalidate and reload alert colors when preferences change\n\t\t\t\tasync refreshAlertColors() {\n\t\t\t\t\tconsole.log('Refreshing alert colors due to preference changes...');\n\t\t\t\t\tawait this.loadAlertColors(true);\n\t\t\t\t\t// Trigger UI update by reassigning the object to ensure reactivity\n\t\t\t\t\tthis.alertColors = { ...this.alertColors };\n\t\t\t\t},\n\n\t\t\t\t// Get color for an alert\n\t\t\t\tgetAlertColor(alert, colorType = 'backgroundColor') {\n\t\t\t\t\tconst fingerprint = alert.fingerprint;\n\t\t\t\t\tif (this.alertColors[fingerprint]) {\n\t\t\t\t\t\tconst colorResult = this.alertColors[fingerprint];\n\t\t\t\t\t\tswitch (colorType) {\n\t\t\t\t\t\t\tcase 'backgroundColor': return colorResult.backgroundColor;\n\t\t\t\t\t\t\tcase 'textColor': return colorResult.textColor;\n\t\t\t\t\t\t\tcase 'borderColor': return colorResult.borderColor;\n\t\t\t\t\t\t\tcase 'badgeColor': return colorResult.badgeColor;\n\t\t\t\t\t\t\tdefault: return colorResult.backgroundColor;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Fallback to default severity colors\n\t\t\t\t\treturn this.getDefaultSeverityColor(alert, colorType);\n\t\t\t\t},\n\n\t\t\t\t// Get default severity color (fallback)\n\t\t\t\tgetDefaultSeverityColor(alert, colorType = 'backgroundColor') {\n\t\t\t\t\tconst severity = alert.severity || 'default';\n\t\t\t\t\tconst colorMap = {\n\t\t\t\t\t\tcritical: {\n\t\t\t\t\t\t\tbackgroundColor: '#fee2e2', // red-100\n\t\t\t\t\t\t\ttextColor: '#991b1b',       // red-800\n\t\t\t\t\t\t\tborderColor: '#dc2626',     // red-600\n\t\t\t\t\t\t\tbadgeColor: '#dc2626'       // red-600\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'critical-daytime': {\n\t\t\t\t\t\t\tbackgroundColor: '#ffe4e6', // rose-100\n\t\t\t\t\t\t\ttextColor: '#9f1239',       // rose-800\n\t\t\t\t\t\t\tborderColor: '#be123c',     // rose-700\n\t\t\t\t\t\t\tbadgeColor: '#be123c'       // rose-700\n\t\t\t\t\t\t},\n\t\t\t\t\t\twarning: {\n\t\t\t\t\t\t\tbackgroundColor: '#fef3c7', // amber-100\n\t\t\t\t\t\t\ttextColor: '#92400e',       // amber-800\n\t\t\t\t\t\t\tborderColor: '#d97706',     // amber-600\n\t\t\t\t\t\t\tbadgeColor: '#d97706'       // amber-600\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinfo: {\n\t\t\t\t\t\t\tbackgroundColor: '#dbeafe', // blue-100\n\t\t\t\t\t\t\ttextColor: '#1e40af',       // blue-800\n\t\t\t\t\t\t\tborderColor: '#2563eb',     // blue-600\n\t\t\t\t\t\t\tbadgeColor: '#2563eb'       // blue-600\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tbackgroundColor: '#f3f4f6', // gray-100\n\t\t\t\t\t\t\ttextColor: '#374151',       // gray-700\n\t\t\t\t\t\t\tborderColor: '#6b7280',     // gray-500\n\t\t\t\t\t\t\tbadgeColor: '#6b7280'       // gray-500\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tconst colors = colorMap[severity] || colorMap.default;\n\t\t\t\t\treturn colors[colorType] || colors.backgroundColor;\n\t\t\t\t},\n\n\t\t\t\t// Apply incremental changes to the dashboard\n\t\t\t\tapplyIncrementalUpdate(update) {\n\t\t\t\t\t// Create fingerprint maps for efficient lookups\n\t\t\t\t\tconst alertMap = new Map();\n\t\t\t\t\tthis.alerts.forEach((alert, index) => {\n\t\t\t\t\t\talertMap.set(alert.fingerprint, { alert, index });\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t// Track if we need to notify about new alerts\n\t\t\t\t\tconst oldAlerts = [...this.alerts];\n\t\t\t\t\t\n\t\t\t\t\t// Remove alerts that are no longer present\n\t\t\t\t\tif (update.removedAlerts && update.removedAlerts.length > 0) {\n\t\t\t\t\t\tthis.alerts = this.alerts.filter(alert => \n\t\t\t\t\t\t\t!update.removedAlerts.includes(alert.fingerprint)\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Update selection to remove deleted alerts\n\t\t\t\t\t\tthis.selectedAlerts = this.selectedAlerts.filter(fingerprint => \n\t\t\t\t\t\t\t!update.removedAlerts.includes(fingerprint)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Update existing alerts\n\t\t\t\t\tif (update.updatedAlerts && update.updatedAlerts.length > 0) {\n\t\t\t\t\t\tconst newAlertMap = new Map();\n\t\t\t\t\t\tthis.alerts.forEach((alert, index) => {\n\t\t\t\t\t\t\tnewAlertMap.set(alert.fingerprint, { alert, index });\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tupdate.updatedAlerts.forEach(updatedAlert => {\n\t\t\t\t\t\t\tconst existing = newAlertMap.get(updatedAlert.fingerprint);\n\t\t\t\t\t\t\tif (existing) {\n\t\t\t\t\t\t\t\t// Update in place to maintain order\n\t\t\t\t\t\t\t\tthis.alerts[existing.index] = updatedAlert;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Add new alerts\n\t\t\t\t\tif (update.newAlerts && update.newAlerts.length > 0) {\n\t\t\t\t\t\tthis.alerts.push(...update.newAlerts);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Sort after adding new alerts to maintain correct order\n\t\t\t\t\t\tthis.alerts = this.sortAlerts(this.alerts);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Update metadata and settings\n\t\t\t\t\tif (update.metadata) {\n\t\t\t\t\t\tthis.metadata = update.metadata;\n\t\t\t\t\t}\n\t\t\t\t\tif (update.settings) {\n\t\t\t\t\t\tthis.settings = { ...this.settings, ...update.settings };\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Update colors for new and updated alerts\n\t\t\t\t\tif (update.colors && Object.keys(update.colors).length > 0) {\n\t\t\t\t\t\t// Merge new colors with existing ones\n\t\t\t\t\t\tthis.alertColors = { ...this.alertColors, ...update.colors };\n\t\t\t\t\t\tthis.alertColorsTimestamp = Date.now();\n\t\t\t\t\t\tconsole.log(`Updated colors for ${Object.keys(update.colors).length} alerts from incremental update`);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Update timestamp\n\t\t\t\t\tthis.lastUpdateTime = update.lastUpdateTime * 1000; // Convert to milliseconds\n\t\t\t\t\t\n\t\t\t\t\t// Check for new alerts for notifications\n\t\t\t\t\tif (update.newAlerts && update.newAlerts.length > 0) {\n\t\t\t\t\t\tthis.checkForNewAlerts(oldAlerts, this.alerts);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Sort alerts based on current sorting configuration\n\t\t\t\tsortAlerts(alerts) {\n\t\t\t\t\treturn [...alerts].sort((a, b) => {\n\t\t\t\t\t\tlet aVal, bVal;\n\t\t\t\t\t\t\n\t\t\t\t\t\tswitch (this.sortField) {\n\t\t\t\t\t\t\tcase 'alertName':\n\t\t\t\t\t\t\t\taVal = a.alertName.toLowerCase();\n\t\t\t\t\t\t\t\tbVal = b.alertName.toLowerCase();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'severity':\n\t\t\t\t\t\t\t\tconst severityOrder = { 'critical': 3, 'warning': 2, 'info': 1 };\n\t\t\t\t\t\t\t\taVal = severityOrder[a.severity] || 0;\n\t\t\t\t\t\t\t\tbVal = severityOrder[b.severity] || 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'status':\n\t\t\t\t\t\t\t\taVal = a.status.toLowerCase();\n\t\t\t\t\t\t\t\tbVal = b.status.toLowerCase();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'instance':\n\t\t\t\t\t\t\t\taVal = a.instance.toLowerCase();\n\t\t\t\t\t\t\t\tbVal = b.instance.toLowerCase();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'team':\n\t\t\t\t\t\t\t\taVal = (a.labels.team || '').toLowerCase();\n\t\t\t\t\t\t\t\tbVal = (b.labels.team || '').toLowerCase();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'duration':\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\taVal = a.duration;\n\t\t\t\t\t\t\t\tbVal = b.duration;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (this.sortDirection === 'asc') {\n\t\t\t\t\t\t\treturn aVal < bVal ? -1 : aVal > bVal ? 1 : 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn aVal > bVal ? -1 : aVal < bVal ? 1 : 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\t// Auto-refresh management\n\t\t\t\tstartAutoRefresh() {\n\t\t\t\t\tthis.stopAutoRefresh();\n\t\t\t\t\tthis.refreshInterval = setInterval(() => {\n\t\t\t\t\t\t// Use incremental updates for auto-refresh\n\t\t\t\t\t\tthis.loadDashboardIncremental();\n\t\t\t\t\t}, this.settings.refreshInterval * 1000);\n\t\t\t\t},\n\n\t\t\t\tstopAutoRefresh() {\n\t\t\t\t\tif (this.refreshInterval) {\n\t\t\t\t\t\tclearInterval(this.refreshInterval);\n\t\t\t\t\t\tthis.refreshInterval = null;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Display modes\n\t\t\t\tsetDisplayMode(mode) {\n\t\t\t\t\tif (this.displayMode !== mode) {\n\t\t\t\t\t\tthis.displayMode = mode;\n\t\t\t\t\t\tthis.clearSelection();\n\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tsetViewMode(mode) {\n\t\t\t\t\tif (this.viewMode !== mode) {\n\t\t\t\t\t\tthis.viewMode = mode;\n\t\t\t\t\t\tthis.clearSelection();\n\t\t\t\t\t\tif (mode === 'group') {\n\t\t\t\t\t\t\tthis.expandedGroups = this.groups.map(g => g.groupName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Sorting\n\t\t\t\tsortBy(field) {\n\t\t\t\t\tif (this.sortField === field) {\n\t\t\t\t\t\tthis.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.sortField = field;\n\t\t\t\t\t\tthis.sortDirection = 'asc';\n\t\t\t\t\t}\n\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t},\n\n\t\t\t\t// Filtering\n\t\t\t\tapplyFilters() {\n\t\t\t\t\t// Debounced filter application happens automatically via data loading\n\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t},\n\n\t\t\t\tclearAllFilters() {\n\t\t\t\t\tthis.searchQuery = '';\n\t\t\t\t\tthis.filters = {\n\t\t\t\t\t\talertmanagers: [],\n\t\t\t\t\t\tseverities: [],\n\t\t\t\t\t\tstatuses: [],\n\t\t\t\t\t\tteams: []\n\t\t\t\t\t};\n\t\t\t\t\tthis.acknowledgmentFilter = null;\n\t\t\t\t\tthis.commentsFilter = null;\n\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t},\n\n\t\t\t\tclearFilter(filterType) {\n\t\t\t\t\tthis.filters[filterType] = [];\n\t\t\t\t\tthis.applyFilters();\n\t\t\t\t},\n\n\t\t\t\tremoveFilter(filterType, value) {\n\t\t\t\t\tconst index = this.filters[filterType].indexOf(value);\n\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\tthis.filters[filterType].splice(index, 1);\n\t\t\t\t\t\tthis.applyFilters();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\thasActiveFilters() {\n\t\t\t\t\treturn this.searchQuery.length > 0 ||\n\t\t\t\t\t\t   this.filters.alertmanagers.length > 0 ||\n\t\t\t\t\t\t   this.filters.severities.length > 0 ||\n\t\t\t\t\t\t   this.filters.statuses.length > 0 ||\n\t\t\t\t\t\t   this.filters.teams.length > 0 ||\n\t\t\t\t\t\t   this.acknowledgmentFilter !== null ||\n\t\t\t\t\t\t   this.commentsFilter !== null;\n\t\t\t\t},\n\n\t\t\t\t// Selection management\n\t\t\t\ttoggleAlert(fingerprint) {\n\t\t\t\t\tconst index = this.selectedAlerts.indexOf(fingerprint);\n\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\tthis.selectedAlerts.splice(index, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.selectedAlerts.push(fingerprint);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\ttoggleGroup(groupName) {\n\t\t\t\t\tconst index = this.selectedGroups.indexOf(groupName);\n\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\tthis.selectedGroups.splice(index, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.selectedGroups.push(groupName);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tselectAll() {\n\t\t\t\t\tif (this.viewMode === 'list') {\n\t\t\t\t\t\tthis.selectedAlerts = this.alerts.map(a => a.fingerprint);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.selectedGroups = this.groups.map(g => g.groupName);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tclearSelection() {\n\t\t\t\t\tthis.selectedAlerts = [];\n\t\t\t\t\tthis.selectedGroups = [];\n\t\t\t\t},\n\n\t\t\t\ttoggleSelectAll(event) {\n\t\t\t\t\tif (event.target.checked) {\n\t\t\t\t\t\tthis.selectAll();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.clearSelection();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Group expansion\n\t\t\t\ttoggleGroupExpanded(groupName) {\n\t\t\t\t\tconst index = this.expandedGroups.indexOf(groupName);\n\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\tthis.expandedGroups.splice(index, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.expandedGroups.push(groupName);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Actions\n\t\t\t\tacknowledgeSelected() {\n\t\t\t\t\tif (this.selectedAlerts.length === 0 && this.selectedGroups.length === 0) {\n\t\t\t\t\t\tthis.showNotification('warning', 'Please select alerts or groups to acknowledge');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.ackAction = 'bulk';\n\t\t\t\t\tthis.ackReason = '';\n\t\t\t\t\tthis.ackError = '';\n\t\t\t\t\tthis.showAckModal = true;\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Acknowledgment modal functions\n\t\t\t\tcancelAcknowledgment() {\n\t\t\t\t\tthis.showAckModal = false;\n\t\t\t\t\tthis.ackReason = '';\n\t\t\t\t\tthis.ackError = '';\n\t\t\t\t\tthis.ackSubmitting = false;\n\t\t\t\t\tthis.currentAckAlert = null;\n\t\t\t\t\tthis.currentGroupName = '';\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tasync submitAcknowledgment() {\n\t\t\t\t\t// Validate reason\n\t\t\t\t\tif (!this.ackReason.trim()) {\n\t\t\t\t\t\tthis.ackError = 'Please provide a reason for the acknowledgment';\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.ackSubmitting = true;\n\t\t\t\t\tthis.ackError = '';\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet request;\n\t\t\t\t\t\tlet successMessage;\n\t\t\t\t\t\t\n\t\t\t\t\t\tswitch (this.ackAction) {\n\t\t\t\t\t\t\tcase 'single':\n\t\t\t\t\t\t\t\trequest = {\n\t\t\t\t\t\t\t\t\talertFingerprints: [this.currentAckAlert.fingerprint],\n\t\t\t\t\t\t\t\t\tgroupNames: [],\n\t\t\t\t\t\t\t\t\taction: 'acknowledge',\n\t\t\t\t\t\t\t\t\tcomment: this.ackReason\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tsuccessMessage = 'Alert acknowledged successfully';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcase 'group':\n\t\t\t\t\t\t\t\trequest = {\n\t\t\t\t\t\t\t\t\talertFingerprints: [],\n\t\t\t\t\t\t\t\t\tgroupNames: [this.currentGroupName],\n\t\t\t\t\t\t\t\t\taction: 'acknowledge',\n\t\t\t\t\t\t\t\t\tcomment: this.ackReason\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tsuccessMessage = `Group \"${this.currentGroupName}\" acknowledged successfully`;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcase 'bulk':\n\t\t\t\t\t\t\t\trequest = {\n\t\t\t\t\t\t\t\t\talertFingerprints: this.selectedAlerts,\n\t\t\t\t\t\t\t\t\tgroupNames: this.selectedGroups,\n\t\t\t\t\t\t\t\t\taction: 'acknowledge',\n\t\t\t\t\t\t\t\t\tcomment: this.ackReason\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tsuccessMessage = `${this.selectedAlerts.length + this.selectedGroups.length} items acknowledged successfully`;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthis.ackError = 'Invalid acknowledgment action';\n\t\t\t\t\t\t\t\tthis.ackSubmitting = false;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.showNotification('success', successMessage);\n\t\t\t\t\t\t\tthis.showAckModal = false;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Clear selection for bulk actions\n\t\t\t\t\t\t\tif (this.ackAction === 'bulk') {\n\t\t\t\t\t\t\t\tthis.clearSelection();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Refresh dashboard data\n\t\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.ackError = result.error || 'Failed to acknowledge';\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error submitting acknowledgment:', error);\n\t\t\t\t\t\tthis.ackError = 'Network error: Failed to submit acknowledgment';\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.ackSubmitting = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync hideSelected() {\n\t\t\t\t\tconst request = {\n\t\t\t\t\t\talertFingerprints: this.selectedAlerts,\n\t\t\t\t\t\tgroupNames: this.selectedGroups,\n\t\t\t\t\t\taction: 'hide'\n\t\t\t\t\t};\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.showNotification('success', `Hidden ${result.data.processedCount} alerts`);\n\t\t\t\t\t\t\tthis.clearSelection();\n\t\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to hide alerts: ' + result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error hiding alerts:', error);\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to hide alerts');\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tacknowledgeAlert(fingerprint) {\n\t\t\t\t\t// Find the alert details\n\t\t\t\t\tconst alert = this.alerts.find(a => a.fingerprint === fingerprint);\n\t\t\t\t\tthis.currentAckAlert = alert;\n\t\t\t\t\tthis.ackAction = 'single';\n\t\t\t\t\tthis.ackReason = '';\n\t\t\t\t\tthis.ackError = '';\n\t\t\t\t\tthis.showAckModal = true;\n\t\t\t\t},\n\n\t\t\t\tacknowledgeGroup(groupName) {\n\t\t\t\t\tthis.currentGroupName = groupName;\n\t\t\t\t\tthis.ackAction = 'group';\n\t\t\t\t\tthis.ackReason = '';\n\t\t\t\t\tthis.ackError = '';\n\t\t\t\t\tthis.showAckModal = true;\n\t\t\t\t},\n\n\t\t\t\tasync hideAlert(fingerprint) {\n\t\t\t\t\tconst request = {\n\t\t\t\t\t\talertFingerprints: [fingerprint],\n\t\t\t\t\t\taction: 'hide'\n\t\t\t\t\t};\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.showNotification('success', 'Alert hidden');\n\t\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to hide alert: ' + result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error hiding alert:', error);\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to hide alert');\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Unacknowledge actions\n\t\t\t\tasync unacknowledgeSelected() {\n\t\t\t\t\tconst request = {\n\t\t\t\t\t\talertFingerprints: this.selectedAlerts,\n\t\t\t\t\t\tgroupNames: this.selectedGroups,\n\t\t\t\t\t\taction: 'unacknowledge',\n\t\t\t\t\t\tcomment: 'Unacknowledged from dashboard'\n\t\t\t\t\t};\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.showNotification('success', `Unacknowledged ${result.data.processedCount} alerts`);\n\t\t\t\t\t\t\tthis.clearSelection();\n\t\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to unacknowledge alerts: ' + result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error unacknowledging alerts:', error);\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to unacknowledge alerts');\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync unacknowledgeAlert(fingerprint) {\n\t\t\t\t\tconst request = {\n\t\t\t\t\t\talertFingerprints: [fingerprint],\n\t\t\t\t\t\taction: 'unacknowledge',\n\t\t\t\t\t\tcomment: 'Unacknowledged from dashboard'\n\t\t\t\t\t};\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.showNotification('success', 'Alert unacknowledged');\n\t\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to unacknowledge alert: ' + result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error unacknowledging alert:', error);\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to unacknowledge alert');\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Resolve actions\n\t\t\t\tasync resolveSelected() {\n\t\t\t\t\tconst request = {\n\t\t\t\t\t\talertFingerprints: this.selectedAlerts,\n\t\t\t\t\t\tgroupNames: this.selectedGroups,\n\t\t\t\t\t\taction: 'resolve',\n\t\t\t\t\t\tcomment: 'Resolved from dashboard'\n\t\t\t\t\t};\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.showNotification('success', `Resolved ${result.data.processedCount} alerts`);\n\t\t\t\t\t\t\tthis.clearSelection();\n\t\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to resolve alerts: ' + result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error resolving alerts:', error);\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to resolve alerts');\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync resolveAlert(fingerprint) {\n\t\t\t\t\tconst request = {\n\t\t\t\t\t\talertFingerprints: [fingerprint],\n\t\t\t\t\t\taction: 'resolve',\n\t\t\t\t\t\tcomment: 'Resolved from dashboard'\n\t\t\t\t\t};\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.showNotification('success', 'Alert resolved');\n\t\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to resolve alert: ' + result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error resolving alert:', error);\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to resolve alert');\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Settings\n\t\t\t\tasync openSettings() {\n\t\t\t\t\tthis.showSettings = true;\n\t\t\t\t\t// Trigger color preferences reload in the settings modal\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tif (window.currentSettingsModal && window.currentSettingsModal.loadColorPreferences) {\n\t\t\t\t\t\t\twindow.currentSettingsModal.loadColorPreferences();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 100); // Small delay to ensure modal is initialized\n\t\t\t\t},\n\n\t\t\t\tasync saveSettings() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Save regular settings\n\t\t\t\t\t\tconst settingsResponse = await fetch('/api/v1/dashboard/settings', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify(this.settings)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst settingsResult = await settingsResponse.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!settingsResult.success) {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to save settings: ' + settingsResult.error);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Save color preferences from the settings modal\n\t\t\t\t\t\t// First try to use the modal's save method if available\n\t\t\t\t\t\tlet colorSaved = false;\n\t\t\t\t\t\tif (window.currentSettingsModal && window.currentSettingsModal.saveColorPreferences) {\n\t\t\t\t\t\t\tcolorSaved = await window.currentSettingsModal.saveColorPreferences();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// If modal method not available or failed, log a message\n\t\t\t\t\t\tif (!colorSaved && window.currentSettingsModal && window.currentSettingsModal.colorPreferences && window.currentSettingsModal.colorPreferences.length > 0) {\n\t\t\t\t\t\t\tconsole.log('Color preferences exist but could not be saved via modal method');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Always refresh alert colors to apply preference changes\n\t\t\t\t\t\tawait this.refreshAlertColors();\n\n\t\t\t\t\t\t// Apply notification queue settings\n\t\t\t\t\t\tthis.applyNotificationSettings();\n\n\t\t\t\t\t\tthis.showNotification('success', 'Settings saved');\n\t\t\t\t\t\tthis.showSettings = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Apply theme change\n\t\t\t\t\t\tif (this.settings.theme === 'dark') {\n\t\t\t\t\t\t\tdocument.documentElement.classList.add('dark');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdocument.documentElement.classList.remove('dark');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Update auto-refresh interval\n\t\t\t\t\t\tthis.startAutoRefresh();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving settings:', error);\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to save settings');\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Apply notification queue settings when settings are saved\n\t\t\t\tapplyNotificationSettings() {\n\t\t\t\t\t// Update notification delay from settings\n\t\t\t\t\tthis.notificationDelay = this.settings.notificationDelay || 1500;\n\t\t\t\t\t\n\t\t\t\t\t// Update max concurrent notifications from settings  \n\t\t\t\t\tthis.maxConcurrentNotifications = this.settings.maxConcurrentNotifications || 3;\n\t\t\t\t\t\n\t\t\t\t\t// Log the updated settings for debugging\n\t\t\t\t\tconsole.log('Notification settings applied:', {\n\t\t\t\t\t\tnotificationDelay: this.notificationDelay,\n\t\t\t\t\t\tmaxConcurrentNotifications: this.maxConcurrentNotifications,\n\t\t\t\t\t\tnotificationBatching: this.settings.notificationBatching,\n\t\t\t\t\t\tprioritizedNotifications: this.settings.prioritizedNotifications\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\tloadSettings() {\n\t\t\t\t\t// Load settings from localStorage as fallback\n\t\t\t\t\tconst saved = localStorage.getItem('dashboard-settings');\n\t\t\t\t\tif (saved) {\n\t\t\t\t\t\tthis.settings = { ...this.settings, ...JSON.parse(saved) };\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Apply notification settings after loading\n\t\t\t\t\tthis.applyNotificationSettings();\n\t\t\t\t},\n\n\t\t\t\t// Load current user information for comment ownership checks\n\t\t\t\tasync loadCurrentUser() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/auth/profile', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success && result.data) {\n\t\t\t\t\t\t\t\tthis.currentUser = {\n\t\t\t\t\t\t\t\t\tid: result.data.id,\n\t\t\t\t\t\t\t\t\tusername: result.data.username,\n\t\t\t\t\t\t\t\t\temail: result.data.email\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading current user:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Notifications and sounds\n\t\t\t\tinitializeSounds() {\n\t\t\t\t\tif (this.settings.soundEnabled) {\n\t\t\t\t\t\tthis.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tcreateBeep(frequency, duration, type = 'sine') {\n\t\t\t\t\tif (!this.audioContext) return Promise.resolve();\n\t\t\t\t\t\n\t\t\t\t\tconst oscillator = this.audioContext.createOscillator();\n\t\t\t\t\tconst gainNode = this.audioContext.createGain();\n\t\t\t\t\t\n\t\t\t\t\toscillator.connect(gainNode);\n\t\t\t\t\tgainNode.connect(this.audioContext.destination);\n\t\t\t\t\t\n\t\t\t\t\toscillator.frequency.value = frequency;\n\t\t\t\t\toscillator.type = type;\n\t\t\t\t\t\n\t\t\t\t\tgainNode.gain.setValueAtTime(0, this.audioContext.currentTime);\n\t\t\t\t\tgainNode.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.01);\n\t\t\t\t\tgainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);\n\t\t\t\t\t\n\t\t\t\t\toscillator.start(this.audioContext.currentTime);\n\t\t\t\t\toscillator.stop(this.audioContext.currentTime + duration);\n\t\t\t\t\t\n\t\t\t\t\treturn new Promise(resolve => {\n\t\t\t\t\t\toscillator.onended = resolve;\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\tcheckForNewAlerts(oldAlerts, newAlerts) {\n\t\t\t\t\tif (!this.settings.notificationsEnabled || oldAlerts.length === 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst oldFingerprints = new Set(oldAlerts.map(a => a.fingerprint));\n\t\t\t\t\tconst newFingerprints = newAlerts.filter(a => !oldFingerprints.has(a.fingerprint));\n\n\t\t\t\t\t// Use queue system instead of immediate notifications\n\t\t\t\t\tnewFingerprints.forEach(alert => {\n\t\t\t\t\t\t// Skip notifications for silenced/suppressed/resolved alerts\n\t\t\t\t\t\tconst alertStatus = this.getDisplayStatus(alert.status);\n\t\t\t\t\t\tif (alertStatus === 'silenced' || alertStatus === 'suppressed' || alertStatus === 'resolved') {\n\t\t\t\t\t\t\treturn; // Skip notification for silenced/suppressed/resolved alerts\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// For critical alerts, show immediately if prioritized notifications is enabled\n\t\t\t\t\t\tif (alert.severity === 'critical' && this.settings.prioritizedNotifications) {\n\t\t\t\t\t\t\tthis.showAlertNotification(alert);\n\t\t\t\t\t\t\tthis.addToAudioQueue(alert);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Add to queue for normal processing\n\t\t\t\t\t\t\tthis.addToNotificationQueue(alert);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\taddToNotificationQueue(alert, priority = null) {\n\t\t\t\t\t// Skip notifications for silenced/suppressed/resolved alerts (additional safety check)\n\t\t\t\t\tconst alertStatus = this.getDisplayStatus(alert.status);\n\t\t\t\t\tif (alertStatus === 'silenced' || alertStatus === 'suppressed' || alertStatus === 'resolved') {\n\t\t\t\t\t\treturn; // Skip notification for silenced/suppressed/resolved alerts\n\t\t\t\t\t}\n\n\t\t\t\t\t// Determine priority based on severity if not provided\n\t\t\t\t\tconst alertPriority = priority || this.getNotificationPriority(alert.severity);\n\t\t\t\t\t\n\t\t\t\t\tconst queueItem = {\n\t\t\t\t\t\talert: alert,\n\t\t\t\t\t\tpriority: alertPriority,\n\t\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\t\tid: alert.fingerprint + '_' + Date.now()\n\t\t\t\t\t};\n\n\t\t\t\t\t// Add to queue and sort by priority (higher number = higher priority)\n\t\t\t\t\tthis.notificationQueue.push(queueItem);\n\t\t\t\t\tthis.sortNotificationQueue();\n\n\t\t\t\t\t// Start processing if not already running\n\t\t\t\t\tif (!this.isProcessingNotifications) {\n\t\t\t\t\t\tthis.processNotificationQueue();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tgetNotificationPriority(severity) {\n\t\t\t\t\tswitch (severity) {\n\t\t\t\t\t\tcase 'critical': return 3;\n\t\t\t\t\t\tcase 'warning': return 2;\n\t\t\t\t\t\tcase 'info': return 1;\n\t\t\t\t\t\tdefault: return 0;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tsortNotificationQueue() {\n\t\t\t\t\tthis.notificationQueue.sort((a, b) => {\n\t\t\t\t\t\t// First sort by priority (higher first)\n\t\t\t\t\t\tif (a.priority !== b.priority) {\n\t\t\t\t\t\t\treturn b.priority - a.priority;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Then by timestamp (older first)\n\t\t\t\t\t\treturn a.timestamp - b.timestamp;\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\tasync processNotificationQueue() {\n\t\t\t\t\tif (this.isProcessingNotifications || this.notificationQueue.length === 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.isProcessingNotifications = true;\n\n\t\t\t\t\twhile (this.notificationQueue.length > 0) {\n\t\t\t\t\t\t// Check if we've reached the concurrent notification limit\n\t\t\t\t\t\tif (this.activeNotifications.size >= this.settings.maxConcurrentNotifications) {\n\t\t\t\t\t\t\t// Wait a bit and check again\n\t\t\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve, 500));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Get the highest priority notification\n\t\t\t\t\t\tconst queueItem = this.notificationQueue.shift();\n\t\t\t\t\t\tif (!queueItem) break;\n\n\t\t\t\t\t\t// Show the notification\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.showQueuedNotification(queueItem);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tconsole.error('Error showing queued notification:', error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add to audio queue\n\t\t\t\t\t\tthis.addToAudioQueue(queueItem.alert);\n\n\t\t\t\t\t\t// Wait for the configured delay before processing next notification\n\t\t\t\t\t\tif (this.notificationQueue.length > 0) {\n\t\t\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve, this.settings.notificationDelay));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.isProcessingNotifications = false;\n\t\t\t\t},\n\n\t\t\t\tasync showQueuedNotification(queueItem) {\n\t\t\t\t\tconst alert = queueItem.alert;\n\n\t\t\t\t\t// If batching is enabled and we have similar alerts, create a batched notification\n\t\t\t\t\tif (this.settings.notificationBatching) {\n\t\t\t\t\t\tconst similarAlerts = this.findSimilarAlertsInQueue(alert);\n\t\t\t\t\t\tif (similarAlerts.length > 0) {\n\t\t\t\t\t\t\treturn this.showBatchedNotification(alert, similarAlerts);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Show individual notification\n\t\t\t\t\tthis.showAlertNotification(alert);\n\t\t\t\t},\n\n\t\t\t\tfindSimilarAlertsInQueue(alert) {\n\t\t\t\t\tconst similar = [];\n\t\t\t\t\tconst alertTeam = alert.labels?.team || 'unknown';\n\t\t\t\t\tconst alertJob = alert.labels?.job || 'unknown';\n\n\t\t\t\t\t// Look for alerts with same team or job in the queue\n\t\t\t\t\tfor (let i = this.notificationQueue.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst queueItem = this.notificationQueue[i];\n\t\t\t\t\t\tconst queueAlert = queueItem.alert;\n\n\t\t\t\t\t\tconst isSimilar = (\n\t\t\t\t\t\t\tqueueAlert.severity === alert.severity &&\n\t\t\t\t\t\t\t(queueAlert.labels?.team === alertTeam || queueAlert.labels?.job === alertJob)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (isSimilar && similar.length < 5) { // Limit batch size\n\t\t\t\t\t\t\tsimilar.push(queueItem);\n\t\t\t\t\t\t\tthis.notificationQueue.splice(i, 1); // Remove from queue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn similar;\n\t\t\t\t},\n\n\t\t\t\tshowBatchedNotification(primaryAlert, similarAlerts) {\n\t\t\t\t\tif (!('Notification' in window) || Notification.permission !== 'granted') {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst totalCount = similarAlerts.length + 1;\n\t\t\t\t\tconst severity = primaryAlert.severity;\n\t\t\t\t\tconst team = primaryAlert.labels?.team || 'Unknown';\n\t\t\t\t\t\n\t\t\t\t\t// Create batched notification title and content\n\t\t\t\t\tlet title = '';\n\t\t\t\t\tlet icon = '';\n\t\t\t\t\t\n\t\t\t\t\tswitch (severity) {\n\t\t\t\t\t\tcase 'critical':\n\t\t\t\t\t\t\ttitle = `🚨 ${totalCount} CRITICAL ALERTS`;\n\t\t\t\t\t\t\ticon = 'data:image/svg+xml;base64,' + btoa('<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"#dc2626\" width=\"24\" height=\"24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z\" /></svg>');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'warning':\n\t\t\t\t\t\t\ttitle = `⚠️ ${totalCount} WARNING ALERTS`;\n\t\t\t\t\t\t\ticon = 'data:image/svg+xml;base64,' + btoa('<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"#d97706\" width=\"24\" height=\"24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z\" /></svg>');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttitle = `ℹ️ ${totalCount} ALERTS`;\n\t\t\t\t\t\t\ticon = 'data:image/svg+xml;base64,' + btoa('<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"#2563eb\" width=\"24\" height=\"24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z\" /></svg>');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet body = `📊 Team: ${team}\\n🎯 Primary Alert: ${primaryAlert.alertName}`;\n\t\t\t\t\tif (totalCount > 1) {\n\t\t\t\t\t\tbody += `\\n📝 +${totalCount - 1} similar alerts`;\n\t\t\t\t\t}\n\t\t\t\t\tbody += `\\n\\n🖱️ Click to view all alerts in dashboard`;\n\n\t\t\t\t\tconst notification = new Notification(title, {\n\t\t\t\t\t\tbody: body,\n\t\t\t\t\t\ticon: icon,\n\t\t\t\t\t\ttag: `batch_${severity}_${team}_${Date.now()}`,\n\t\t\t\t\t\trequireInteraction: severity === 'critical',\n\t\t\t\t\t\tsilent: false,\n\t\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t\t});\n\n\t\t\t\t\t// Track active notification\n\t\t\t\t\tconst notificationId = `batch_${Date.now()}`;\n\t\t\t\t\tthis.activeNotifications.add(notificationId);\n\n\t\t\t\t\tnotification.onclick = () => {\n\t\t\t\t\t\t// Navigate to primary alert detail page for batched notifications, fallback to dashboard\n\t\t\t\t\t\tconst targetUrl = primaryAlert?.fingerprint ? `/dashboard/alert/${primaryAlert.fingerprint}` : '/dashboard';\n\t\t\t\t\t\twindow.location.href = targetUrl;\n\t\t\t\t\t\tnotification.close();\n\t\t\t\t\t};\n\n\t\t\t\t\t// Auto-close with timeout based on severity\n\t\t\t\t\tconst timeout = severity === 'critical' ? 10000 : \n\t\t\t\t\t\t\t\t   severity === 'warning' ? 7000 : 5000;\n\t\t\t\t\t\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tnotification.close();\n\t\t\t\t\t\tthis.activeNotifications.delete(notificationId);\n\t\t\t\t\t}, timeout);\n\t\t\t\t},\n\n\t\t\t\t// Audio Queue System Functions\n\t\t\t\t\n\t\t\t\taddToAudioQueue(alert) {\n\t\t\t\t\tif (!this.settings.soundEnabled) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst audioItem = {\n\t\t\t\t\t\talert: alert,\n\t\t\t\t\t\tpriority: this.getNotificationPriority(alert.severity),\n\t\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.audioQueue.push(audioItem);\n\t\t\t\t\tthis.sortAudioQueue();\n\n\t\t\t\t\t// Start processing if not already running\n\t\t\t\t\tif (!this.isProcessingAudio) {\n\t\t\t\t\t\tthis.processAudioQueue();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tsortAudioQueue() {\n\t\t\t\t\tthis.audioQueue.sort((a, b) => {\n\t\t\t\t\t\t// First sort by priority (higher first)\n\t\t\t\t\t\tif (a.priority !== b.priority) {\n\t\t\t\t\t\t\treturn b.priority - a.priority;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Then by timestamp (older first)\n\t\t\t\t\t\treturn a.timestamp - b.timestamp;\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\tasync processAudioQueue() {\n\t\t\t\t\tif (this.isProcessingAudio || this.audioQueue.length === 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.isProcessingAudio = true;\n\n\t\t\t\t\twhile (this.audioQueue.length > 0) {\n\t\t\t\t\t\tconst audioItem = this.audioQueue.shift();\n\t\t\t\t\t\tif (!audioItem) break;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.playAlertSound(audioItem.alert);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Add a small delay between sounds to prevent overlap\n\t\t\t\t\t\t\tif (this.audioQueue.length > 0) {\n\t\t\t\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve, 300));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tconsole.error('Error playing queued sound:', error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.isProcessingAudio = false;\n\t\t\t\t},\n\n\t\t\t\t// Clear notification queues\n\t\t\t\tclearNotificationQueues() {\n\t\t\t\t\tthis.notificationQueue = [];\n\t\t\t\t\tthis.audioQueue = [];\n\t\t\t\t\tthis.isProcessingNotifications = false;\n\t\t\t\t\tthis.isProcessingAudio = false;\n\t\t\t\t\t\n\t\t\t\t\tif (this.notificationProcessingTimer) {\n\t\t\t\t\t\tclearTimeout(this.notificationProcessingTimer);\n\t\t\t\t\t\tthis.notificationProcessingTimer = null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (this.audioProcessingTimer) {\n\t\t\t\t\t\tclearTimeout(this.audioProcessingTimer);\n\t\t\t\t\t\tthis.audioProcessingTimer = null;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tshowAlertNotification(alert) {\n\t\t\t\t\tif (!('Notification' in window)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Notification.permission === 'granted') {\n\t\t\t\t\t\t// Enhanced title with visual severity indicators\n\t\t\t\t\t\tlet title = '';\n\t\t\t\t\t\tlet icon = '';\n\t\t\t\t\t\tswitch (alert.severity) {\n\t\t\t\t\t\t\tcase 'critical':\n\t\t\t\t\t\t\t\ttitle = '🚨 CRITICAL ALERT';\n\t\t\t\t\t\t\t\ticon = 'data:image/svg+xml;base64,' + btoa('<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"#dc2626\" width=\"24\" height=\"24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z\" /></svg>');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'warning':\n\t\t\t\t\t\t\t\ttitle = '⚠️ WARNING ALERT';\n\t\t\t\t\t\t\t\ticon = 'data:image/svg+xml;base64,' + btoa('<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"#d97706\" width=\"24\" height=\"24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z\" /></svg>');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'info':\n\t\t\t\t\t\t\t\ttitle = 'ℹ️ INFO ALERT';\n\t\t\t\t\t\t\t\ticon = 'data:image/svg+xml;base64,' + btoa('<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"#2563eb\" width=\"24\" height=\"24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z\" /></svg>');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\ttitle = '❓ ALERT';\n\t\t\t\t\t\t\t\ticon = 'data:image/svg+xml;base64,' + btoa('<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"#6b7280\" width=\"24\" height=\"24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M14.857 17.082a23.848 23.848 0 0 0 5.454-1.31A8.967 8.967 0 0 1 18 9.75V9A6 6 0 0 0 6 9v.75a8.967 8.967 0 0 1-2.312 6.022c1.733.64 3.56 1.085 5.455 1.31m5.714 0a24.255 24.255 0 0 1-5.714 0m5.714 0a3 3 0 1 1-5.714 0\" /></svg>');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Build rich notification content with context\n\t\t\t\t\t\tlet body = `🎯 Alert: ${alert.alertName}`;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (alert.instance && alert.instance !== alert.alertName) {\n\t\t\t\t\t\t\tbody += `\\n🖥️ Instance: ${alert.instance}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (alert.labels && alert.labels.team) {\n\t\t\t\t\t\t\tbody += `\\n👥 Team: ${alert.labels.team}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (alert.summary) {\n\t\t\t\t\t\t\tbody += `\\n📋 Summary: ${alert.summary}`;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add timing information\n\t\t\t\t\t\tif (alert.startsAt) {\n\t\t\t\t\t\t\tconst startTime = new Date(alert.startsAt);\n\t\t\t\t\t\t\tconst duration = Math.floor((Date.now() - startTime.getTime()) / (1000 * 60));\n\t\t\t\t\t\t\tbody += `\\n⏰ Duration: ${duration}m`;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add source information\n\t\t\t\t\t\tif (alert.labels) {\n\t\t\t\t\t\t\tif (alert.labels.job) {\n\t\t\t\t\t\t\t\tbody += `\\n🔧 Job: ${alert.labels.job}`;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (alert.labels.alertmanager) {\n\t\t\t\t\t\t\t\tbody += `\\n📡 Source: ${alert.labels.alertmanager}`;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Smart truncation for browser notification limits\n\t\t\t\t\t\tif (body.length > 300) {\n\t\t\t\t\t\t\tconst lines = body.split('\\n');\n\t\t\t\t\t\t\tlet truncatedBody = '';\n\t\t\t\t\t\t\tfor (const line of lines) {\n\t\t\t\t\t\t\t\tif ((truncatedBody + line + '\\n').length > 280) {\n\t\t\t\t\t\t\t\t\ttruncatedBody += '\\n⋯ (view in dashboard for full details)';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttruncatedBody += line + '\\n';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbody = truncatedBody.trim();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst notification = new Notification(title, {\n\t\t\t\t\t\t\tbody: body,\n\t\t\t\t\t\t\ticon: icon,\n\t\t\t\t\t\t\ttag: alert.fingerprint,\n\t\t\t\t\t\t\tbadge: 'data:image/svg+xml;base64,' + btoa('<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"#3b82f6\" width=\"24\" height=\"24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M14.857 17.082a23.848 23.848 0 0 0 5.454-1.31A8.967 8.967 0 0 1 18 9.75V9A6 6 0 0 0 6 9v.75a8.967 8.967 0 0 1-2.312 6.022c1.733.64 3.56 1.085 5.455 1.31m5.714 0a24.255 24.255 0 0 1-5.714 0m5.714 0a3 3 0 1 1-5.714 0\" /></svg>'),\n\t\t\t\t\t\t\trequireInteraction: alert.severity === 'critical', // Keep critical alerts visible\n\t\t\t\t\t\t\tsilent: false,\n\t\t\t\t\t\t\ttimestamp: alert.startsAt ? new Date(alert.startsAt).getTime() : Date.now()\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Track active notification for queue management\n\t\t\t\t\t\tconst notificationId = alert.fingerprint + '_' + Date.now();\n\t\t\t\t\t\tthis.activeNotifications.add(notificationId);\n\n\t\t\t\t\t\t// Enhanced notification interaction - redirect to alert detail page\n\t\t\t\t\t\tnotification.onclick = () => {\n\t\t\t\t\t\t\t// Navigate to alert detail page, fallback to dashboard if no fingerprint\n\t\t\t\t\t\t\tconst targetUrl = alert.fingerprint ? `/dashboard/alert/${alert.fingerprint}` : '/dashboard';\n\t\t\t\t\t\t\twindow.location.href = targetUrl;\n\t\t\t\t\t\t\tnotification.close();\n\t\t\t\t\t\t\tthis.activeNotifications.delete(notificationId);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Auto-close with different timeouts based on severity\n\t\t\t\t\t\tconst timeout = alert.severity === 'critical' ? 10000 : \n\t\t\t\t\t\t\t\t\t   alert.severity === 'warning' ? 7000 : 5000;\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tnotification.close();\n\t\t\t\t\t\t\tthis.activeNotifications.delete(notificationId);\n\t\t\t\t\t\t}, timeout);\n\t\t\t\t\t} else if (Notification.permission !== 'denied') {\n\t\t\t\t\t\tNotification.requestPermission();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync playAlertSound(alert) {\n\t\t\t\t\tif (!this.settings.soundEnabled || !this.audioContext) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (alert.severity === 'critical') {\n\t\t\t\t\t\t\t// High-pitched urgent beep pattern for critical alerts\n\t\t\t\t\t\t\tawait this.createBeep(800, 0.2);\n\t\t\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve, 100));\n\t\t\t\t\t\t\tawait this.createBeep(1000, 0.2);\n\t\t\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve, 100));\n\t\t\t\t\t\t\tawait this.createBeep(800, 0.2);\n\t\t\t\t\t\t} else if (alert.severity === 'warning') {\n\t\t\t\t\t\t\t// Medium pitch single beep for warning alerts\n\t\t\t\t\t\t\tawait this.createBeep(500, 0.3);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error playing alert sound:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tshowNotification(type, message) {\n\t\t\t\t\tconst notification = document.createElement('div');\n\t\t\t\t\tnotification.className = `mb-2 p-4 rounded-lg shadow-lg transition-all duration-300 ${\n\t\t\t\t\t\ttype === 'success' ? 'bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-200' :\n\t\t\t\t\t\ttype === 'error' ? 'bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-200' :\n\t\t\t\t\t\t'bg-blue-100 text-blue-800 dark:bg-blue-800 dark:text-blue-200'\n\t\t\t\t\t}`;\n\t\t\t\t\tnotification.innerHTML = `\n\t\t\t\t\t\t<div class=\"flex items-center justify-between\">\n\t\t\t\t\t\t\t<span>${message}</span>\n\t\t\t\t\t\t\t<button onclick=\"this.parentElement.parentElement.remove()\" class=\"ml-4 text-sm opacity-70 hover:opacity-100\">&times;</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t`;\n\n\t\t\t\t\tdocument.getElementById('notifications').appendChild(notification);\n\n\t\t\t\t\t// Auto-remove after 5 seconds\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tif (notification.parentElement) {\n\t\t\t\t\t\t\tnotification.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 5000);\n\t\t\t\t},\n\n\t\t\t\t// URL management\n\t\t\t\tupdateURL() {\n\t\t\t\t\tconst params = new URLSearchParams();\n\n\t\t\t\t\tif (this.searchQuery) params.set('search', this.searchQuery);\n\t\t\t\t\tif (this.filters.alertmanagers.length > 0) params.set('alertmanagers', this.filters.alertmanagers.join(','));\n\t\t\t\t\tif (this.filters.severities.length > 0) params.set('severities', this.filters.severities.join(','));\n\t\t\t\t\tif (this.filters.statuses.length > 0) params.set('statuses', this.filters.statuses.join(','));\n\t\t\t\t\tif (this.filters.teams.length > 0) params.set('teams', this.filters.teams.join(','));\n\n\t\t\t\t\tif (this.displayMode !== 'classic') params.set('displayMode', this.displayMode);\n\t\t\t\t\tif (this.viewMode !== 'list') params.set('viewMode', this.viewMode);\n\t\t\t\t\tif (this.sortField !== 'duration') params.set('sortField', this.sortField);\n\t\t\t\t\tif (this.sortDirection !== 'asc') params.set('sortDirection', this.sortDirection);\n\n\t\t\t\t\tif (this.acknowledgmentFilter) params.set('acknowledgment', this.acknowledgmentFilter);\n\t\t\t\t\tif (this.commentsFilter) params.set('comments', this.commentsFilter);\n\n\t\t\t\t\tconst newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;\n\t\t\t\t\twindow.history.replaceState({}, '', newURL);\n\t\t\t\t},\n\n\t\t\t\tloadFiltersFromURL() {\n\t\t\t\t\tconst params = new URLSearchParams(window.location.search);\n\n\t\t\t\t\tthis.searchQuery = params.get('search') || '';\n\t\t\t\t\t\n\t\t\t\t\tconst alertmanagers = params.get('alertmanagers');\n\t\t\t\t\tif (alertmanagers) this.filters.alertmanagers = alertmanagers.split(',');\n\t\t\t\t\t\n\t\t\t\t\tconst severities = params.get('severities');\n\t\t\t\t\tif (severities) this.filters.severities = severities.split(',');\n\t\t\t\t\t\n\t\t\t\t\tconst statuses = params.get('statuses');\n\t\t\t\t\tif (statuses) this.filters.statuses = statuses.split(',');\n\t\t\t\t\t\n\t\t\t\t\tconst teams = params.get('teams');\n\t\t\t\t\tif (teams) this.filters.teams = teams.split(',');\n\n\t\t\t\t\tthis.displayMode = params.get('displayMode') || 'classic';\n\t\t\t\t\tthis.viewMode = params.get('viewMode') || 'list';\n\t\t\t\t\tthis.sortField = params.get('sortField') || 'duration';\n\t\t\t\t\tthis.sortDirection = params.get('sortDirection') || 'asc';\n\n\t\t\t\t\tthis.acknowledgmentFilter = params.get('acknowledgment') || null;\n\t\t\t\t\tthis.commentsFilter = params.get('comments') || null;\n\t\t\t\t},\n\n\t\t\t\t// Utility functions\n\t\t\t\tformatDuration(seconds) {\n\t\t\t\t\tif (seconds < 60) return `${seconds}s`;\n\t\t\t\t\tif (seconds < 3600) return `${Math.floor(seconds / 60)}m`;\n\t\t\t\t\tif (seconds < 86400) return `${Math.floor(seconds / 3600)}h`;\n\t\t\t\t\treturn `${Math.floor(seconds / 86400)}d`;\n\t\t\t\t},\n\n\t\t\t\tgetStatusText() {\n\t\t\t\t\tconst now = new Date();\n\t\t\t\t\tconst lastUpdate = this.metadata.lastUpdate ? new Date(this.metadata.lastUpdate) : null;\n\t\t\t\t\t\n\t\t\t\t\tif (this.loading) {\n\t\t\t\t\t\treturn 'Loading...';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!lastUpdate) {\n\t\t\t\t\t\treturn 'Ready';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconst secondsAgo = Math.floor((now - lastUpdate) / 1000);\n\t\t\t\t\t\n\t\t\t\t\tif (secondsAgo < 10) {\n\t\t\t\t\t\treturn 'Just updated';\n\t\t\t\t\t} else if (secondsAgo < 60) {\n\t\t\t\t\t\treturn `Updated ${secondsAgo}s ago`;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn `Updated ${Math.floor(secondsAgo / 60)}m ago`;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Column resizing methods\n\t\t\t\tloadColumnWidths() {\n\t\t\t\t\tconst savedWidths = localStorage.getItem('dashboardColumnWidths');\n\t\t\t\t\tif (savedWidths) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst parsedWidths = JSON.parse(savedWidths);\n\t\t\t\t\t\t\tthis.columnWidths = { ...this.columnWidths, ...parsedWidths };\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tconsole.warn('Failed to load saved column widths:', error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tstartResize(event, columnField) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\n\t\t\t\t\tthis.isResizing = true;\n\t\t\t\t\tthis.currentColumn = columnField;\n\t\t\t\t\tthis.startX = event.clientX;\n\t\t\t\t\tthis.startWidth = this.columnWidths[columnField];\n\t\t\t\t\t\n\t\t\t\t\t// Add visual feedback\n\t\t\t\t\tdocument.body.style.cursor = 'col-resize';\n\t\t\t\t\tdocument.body.style.userSelect = 'none';\n\t\t\t\t\t\n\t\t\t\t\t// Add a visual indicator\n\t\t\t\t\tevent.target.style.backgroundColor = '#3b82f6';\n\t\t\t\t\tevent.target.style.opacity = '0.8';\n\t\t\t\t},\n\n\t\t\t\thandleMouseMove(event) {\n\t\t\t\t\tif (!this.isResizing || !this.currentColumn) return;\n\t\t\t\t\t\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\n\t\t\t\t\tconst deltaX = event.clientX - this.startX;\n\t\t\t\t\tconst newWidth = Math.max(30, this.startWidth + deltaX); // Lower minimum width\n\t\t\t\t\t\n\t\t\t\t\tthis.columnWidths[this.currentColumn] = newWidth;\n\t\t\t\t},\n\n\t\t\t\thandleMouseUp(event) {\n\t\t\t\t\tif (!this.isResizing) return;\n\t\t\t\t\t\n\t\t\t\t\tthis.isResizing = false;\n\t\t\t\t\tthis.currentColumn = null;\n\t\t\t\t\t\n\t\t\t\t\t// Remove visual feedback\n\t\t\t\t\tdocument.body.style.cursor = '';\n\t\t\t\t\tdocument.body.style.userSelect = '';\n\t\t\t\t\t\n\t\t\t\t\t// Reset resize handle appearance\n\t\t\t\t\tconst resizeHandles = document.querySelectorAll('[title=\"Drag to resize column\"]');\n\t\t\t\t\tresizeHandles.forEach(handle => {\n\t\t\t\t\t\thandle.style.backgroundColor = '';\n\t\t\t\t\t\thandle.style.opacity = '';\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t// Save column widths to localStorage\n\t\t\t\t\tthis.saveColumnWidths();\n\t\t\t\t},\n\n\t\t\t\tsaveColumnWidths() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlocalStorage.setItem('dashboardColumnWidths', JSON.stringify(this.columnWidths));\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.warn('Failed to save column widths:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tresetColumnWidths() {\n\t\t\t\t\t// Reset to default widths\n\t\t\t\t\tthis.columnWidths = {\n\t\t\t\t\t\talertName: 300,\n\t\t\t\t\t\tacknowledge: 75,\n\t\t\t\t\t\tinstance: 350,\n\t\t\t\t\t\tseverity: 150,\n\t\t\t\t\t\tstatus: 150,\n\t\t\t\t\t\tcomments: 130,\n\t\t\t\t\t\tteam: 200,\n\t\t\t\t\t\tsummary: 400,\n\t\t\t\t\t\tduration: 150,\n\t\t\t\t\t\tsource: 180\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\t// Clear saved widths\n\t\t\t\t\tlocalStorage.removeItem('dashboardColumnWidths');\n\t\t\t\t},\n\n\t\t\t\t// Alert Details Modal Functions\n\t\t\t\tasync showAlertDetails(fingerprint) {\n\t\t\t\t\tthis.alertDetailsLoading = true;\n\t\t\t\t\tthis.showAlertModal = true;\n\t\t\t\t\tthis.currentAlertTab = 'overview';\n\t\t\t\t\tthis.alertDetails = null;\n\n\t\t\t\t\t// Update URL without page reload\n\t\t\t\t\tconst currentPath = window.location.pathname;\n\t\t\t\t\tconst newPath = `/dashboard/alert/${fingerprint}`;\n\t\t\t\t\tif (currentPath !== newPath) {\n\t\t\t\t\t\twindow.history.pushState({ alertId: fingerprint }, '', newPath);\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${fingerprint}`, {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.alertDetails = result.data;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to load alert details: ' + result.error);\n\t\t\t\t\t\t\tthis.closeAlertModal();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading alert details:', error);\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to load alert details');\n\t\t\t\t\t\tthis.closeAlertModal();\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.alertDetailsLoading = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tcloseAlertModal() {\n\t\t\t\t\tthis.showAlertModal = false;\n\t\t\t\t\tthis.alertDetails = null;\n\t\t\t\t\tthis.currentAlertTab = 'overview';\n\t\t\t\t\t\n\t\t\t\t\t// Reset comment state\n\t\t\t\t\tthis.newCommentContent = '';\n\t\t\t\t\tthis.commentSubmitting = false;\n\t\t\t\t\tthis.commentDeleting = {};\n\t\t\t\t\t\n\t\t\t\t\t// Update URL back to dashboard\n\t\t\t\t\tif (window.location.pathname.includes('/alert/')) {\n\t\t\t\t\t\twindow.history.pushState({}, '', '/dashboard');\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tacknowledgeCurrentAlert() {\n\t\t\t\t\tif (this.alertDetails?.alert) {\n\t\t\t\t\t\tthis.currentAckAlert = this.alertDetails.alert;\n\t\t\t\t\t\tthis.ackAction = 'single';\n\t\t\t\t\t\tthis.ackReason = '';\n\t\t\t\t\t\tthis.ackError = '';\n\t\t\t\t\t\tthis.showAckModal = true;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tcopyToClipboard(text) {\n\t\t\t\t\tif (navigator.clipboard) {\n\t\t\t\t\t\tnavigator.clipboard.writeText(text).then(() => {\n\t\t\t\t\t\t\tthis.showNotification('success', 'Copied to clipboard');\n\t\t\t\t\t\t}).catch(() => {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to copy to clipboard');\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Fallback for older browsers\n\t\t\t\t\t\tconst textArea = document.createElement('textarea');\n\t\t\t\t\t\ttextArea.value = text;\n\t\t\t\t\t\tdocument.body.appendChild(textArea);\n\t\t\t\t\t\ttextArea.select();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdocument.execCommand('copy');\n\t\t\t\t\t\t\tthis.showNotification('success', 'Copied to clipboard');\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to copy to clipboard');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdocument.body.removeChild(textArea);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tcheckAlertFromURL() {\n\t\t\t\t\t// Check if URL contains an alert ID and open modal\n\t\t\t\t\tconst pathParts = window.location.pathname.split('/');\n\t\t\t\t\tif (pathParts.length >= 4 && pathParts[1] === 'dashboard' && pathParts[2] === 'alert') {\n\t\t\t\t\t\tconst alertId = pathParts[3];\n\t\t\t\t\t\tif (alertId) {\n\t\t\t\t\t\t\t// Wait a bit for initial data to load, then show alert details\n\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\tthis.showAlertDetails(alertId);\n\t\t\t\t\t\t\t}, 500);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Comment Management Functions\n\t\t\t\tasync addComment() {\n\t\t\t\t\tif (!this.newCommentContent.trim()) {\n\t\t\t\t\t\tthis.showNotification('warning', 'Please enter a comment');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\t\tthis.showNotification('error', 'Alert information not available');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.commentSubmitting = true;\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${this.alertDetails.alert.fingerprint}/comments`, {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\tcontent: this.newCommentContent.trim()\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.showNotification('success', 'Comment added successfully');\n\t\t\t\t\t\t\tthis.newCommentContent = '';\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Refresh alert details to show the new comment\n\t\t\t\t\t\t\tawait this.refreshComments();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to add comment: ' + result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error adding comment:', error);\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to add comment');\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.commentSubmitting = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync deleteComment(commentId) {\n\t\t\t\t\tif (!commentId || !this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\t\tthis.showNotification('error', 'Comment information not available');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set deleting state for this specific comment\n\t\t\t\t\tthis.commentDeleting[commentId] = true;\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${this.alertDetails.alert.fingerprint}/comments/${commentId}`, {\n\t\t\t\t\t\t\tmethod: 'DELETE',\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.showNotification('success', 'Comment deleted successfully');\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Refresh alert details to remove the deleted comment\n\t\t\t\t\t\t\tawait this.refreshComments();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.showNotification('error', 'Failed to delete comment: ' + result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error deleting comment:', error);\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to delete comment');\n\t\t\t\t\t} finally {\n\t\t\t\t\t\t// Remove deleting state for this comment\n\t\t\t\t\t\tdelete this.commentDeleting[commentId];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync refreshComments() {\n\t\t\t\t\tif (!this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${this.alertDetails.alert.fingerprint}`, {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Update only the comments and maintain other alert details\n\t\t\t\t\t\t\tthis.alertDetails.comments = result.data.comments || [];\n\t\t\t\t\t\t\t// Update comment count in alert object if it exists\n\t\t\t\t\t\t\tif (this.alertDetails.alert) {\n\t\t\t\t\t\t\t\tthis.alertDetails.alert.commentCount = this.alertDetails.comments.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error refreshing comments:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Get current user info (used for comment ownership checks)\n\t\t\t\tgetCurrentUser() {\n\t\t\t\t\t// This should be populated during initialization\n\t\t\t\t\t// For now, return a placeholder - this would typically come from session data\n\t\t\t\t\treturn this.currentUser;\n\t\t\t\t},\n\n\t\t\t\t// Check if current user can delete a comment\n\t\t\t\tcanDeleteComment(comment) {\n\t\t\t\t\tconst currentUser = this.getCurrentUser();\n\t\t\t\t\treturn currentUser && comment && (\n\t\t\t\t\t\tcurrentUser.id === comment.userId || \n\t\t\t\t\t\tcurrentUser.username === comment.username\n\t\t\t\t\t);\n\t\t\t\t},\n\n\t\t\t\t// Confirm before removing all resolved alerts\n\t\t\t\tconfirmRemoveResolvedAlerts() {\n\t\t\t\t\tif (confirm('Are you sure you want to remove all resolved alerts? This action cannot be undone.')) {\n\t\t\t\t\t\tthis.removeAllResolvedAlerts();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Remove all resolved alerts from backend\n\t\t\t\tasync removeAllResolvedAlerts() {\n\t\t\t\t\tthis.isRemovingResolvedAlerts = true;\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/remove-resolved-alerts', {\n\t\t\t\t\t\t\tmethod: 'DELETE',\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tthis.showNotification('success', 'All resolved alerts have been removed successfully');\n\t\t\t\t\t\t\t// Refresh dashboard data if we're currently viewing resolved alerts\n\t\t\t\t\t\t\tif (this.displayMode === 'resolved') {\n\t\t\t\t\t\t\t\tawait this.loadDashboardData();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.showNotification('error', result.message || 'Failed to remove resolved alerts');\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error removing resolved alerts:', error);\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to remove resolved alerts');\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.isRemovingResolvedAlerts = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Settings Modal Data Handler\n\t\tfunction settingsModalData() {\n\t\t\treturn {\n\t\t\t\tactiveTab: 'general',\n\t\t\t\tcolorPreferences: [],\n\t\t\t\tavailableLabels: {}, // labelKey -> [values]\n\t\t\t\tavailableLabelsLastLoaded: null, // timestamp for cache expiry\n\t\t\t\t\n\t\t\t\tasync init() {\n\t\t\t\t\tconsole.log('Settings modal initializing...');\n\t\t\t\t\tawait this.loadColorPreferences();\n\t\t\t\t\tawait this.loadAvailableLabels();\n\t\t\t\t\t// Ensure the global reference is set\n\t\t\t\t\twindow.currentSettingsModal = this;\n\t\t\t\t\tconsole.log('Settings modal initialized, window.currentSettingsModal set:', !!window.currentSettingsModal);\n\t\t\t\t},\n\n\t\t\t\tasync loadColorPreferences() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/color-preferences', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.colorPreferences = (result.data.preferences || []).map(pref => ({\n\t\t\t\t\t\t\t\t\t...pref,\n\t\t\t\t\t\t\t\t\tlabelConditions: pref.label_conditions || {}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading color preferences:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync loadAvailableLabels() {\n\t\t\t\t\t// Check if we already have cached labels and they're not too old (cache for 5 minutes)\n\t\t\t\t\tif (this.availableLabels && Object.keys(this.availableLabels).length > 0 && \n\t\t\t\t\t\tthis.availableLabelsLastLoaded && \n\t\t\t\t\t\t(Date.now() - this.availableLabelsLastLoaded) < 300000) {\n\t\t\t\t\t\tconsole.log('Using cached available labels');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconsole.log('Fetching available labels from API...');\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/available-labels', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.availableLabels = result.data.labels || {};\n\t\t\t\t\t\t\t\tthis.availableLabelsLastLoaded = Date.now();\n\t\t\t\t\t\t\t\tconsole.log('Loaded available labels:', Object.keys(this.availableLabels).length, 'label types');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading available labels:', error);\n\t\t\t\t\t\t// Fallback to empty object if fetch fails\n\t\t\t\t\t\tthis.availableLabels = {};\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Load available labels only once when needed\n\t\t\t\tensureAvailableLabels() {\n\t\t\t\t\tif (!this.availableLabels || Object.keys(this.availableLabels).length === 0) {\n\t\t\t\t\t\tthis.loadAvailableLabels();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveColorPreferences() {\n\t\t\t\t\tconsole.log('saveColorPreferences called with preferences:', this.colorPreferences);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/color-preferences', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\tpreferences: this.colorPreferences\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\tconsole.log('Color preferences save response:', result);\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Reload color preferences to show saved state in modal\n\t\t\t\t\t\t\tawait this.loadColorPreferences();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to save color preferences:', result.error);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving color preferences:', error);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\taddColorPreference() {\n\t\t\t\t\tthis.colorPreferences.push({\n\t\t\t\t\t\tid: '',\n\t\t\t\t\t\tuserId: '',\n\t\t\t\t\t\tlabelConditions: {},\n\t\t\t\t\t\tcolor: '#3b82f6',\n\t\t\t\t\t\tcolorType: 'custom',\n\t\t\t\t\t\tpriority: 10,\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\tremoveColorPreference(index) {\n\t\t\t\t\tthis.colorPreferences.splice(index, 1);\n\t\t\t\t},\n\n\t\t\t\taddLabelCondition(preference) {\n\t\t\t\t\t// Add a new empty condition\n\t\t\t\t\tif (!preference.labelConditions) {\n\t\t\t\t\t\tpreference.labelConditions = {};\n\t\t\t\t\t}\n\t\t\t\t\tconst key = 'label' + Object.keys(preference.labelConditions).length;\n\t\t\t\t\tpreference.labelConditions[key] = '';\n\t\t\t\t},\n\n\t\t\t\tremoveLabelCondition(preference, key) {\n\t\t\t\t\tdelete preference.labelConditions[key];\n\t\t\t\t},\n\n\t\t\t\tupdateLabelConditionKey(preference, oldKey, newKey) {\n\t\t\t\t\tif (oldKey !== newKey && newKey.trim() !== '') {\n\t\t\t\t\t\tconst value = preference.labelConditions[oldKey];\n\t\t\t\t\t\tdelete preference.labelConditions[oldKey];\n\t\t\t\t\t\tpreference.labelConditions[newKey] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\t\n\t\t// Global function to handle logout response\n\t\tfunction handleLogoutResponse(event) {\n\t\t\tif (event.detail.successful) {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = JSON.parse(event.detail.xhr.responseText);\n\t\t\t\t\tif (response.success && response.data && response.data.redirect) {\n\t\t\t\t\t\t// Redirect to the specified URL\n\t\t\t\t\t\twindow.location.href = response.data.redirect;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Fallback to home page\n\t\t\t\t\t\twindow.location.href = '/';\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error('Error parsing logout response:', e);\n\t\t\t\t\t// Fallback to home page on error\n\t\t\t\t\twindow.location.href = '/';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error('Logout request failed');\n\t\t\t\t// Optionally show an error notification\n\t\t\t\t// You could call a notification function here if you have one\n\t\t\t}\n\t\t}\n\n\t\t// Global dark mode functions\n\t\twindow.darkModeState = {\n\t\t\tdarkMode: false,\n\t\t\tinit() {\n\t\t\t\t// Force light mode for now\n\t\t\t\tthis.darkMode = false;\n\t\t\t\tconsole.log('Dark mode disabled - forced to:', this.darkMode);\n\t\t\t\tthis.updateTheme();\n\t\t\t},\n\t\t\ttoggle() {\n\t\t\t\tthis.darkMode = !this.darkMode;\n\t\t\t\tconsole.log('Dark mode toggled to:', this.darkMode);\n\t\t\t\tlocalStorage.setItem('darkMode', this.darkMode.toString());\n\t\t\t\tconsole.log('Dark mode saved to localStorage:', localStorage.getItem('darkMode'));\n\t\t\t\tthis.updateTheme();\n\t\t\t\t// Dispatch event to update all Alpine components\n\t\t\t\twindow.dispatchEvent(new CustomEvent('darkModeChanged', {\n\t\t\t\t\tdetail: this.darkMode\n\t\t\t\t}));\n\t\t\t},\n\t\t\tupdateTheme() {\n\t\t\t\tconsole.log('Updating theme, darkMode:', this.darkMode);\n\t\t\t\tif (this.darkMode) {\n\t\t\t\t\tdocument.documentElement.classList.add('dark');\n\t\t\t\t\tconsole.log('Added dark class to documentElement');\n\t\t\t\t} else {\n\t\t\t\t\tdocument.documentElement.classList.remove('dark');\n\t\t\t\t\tconsole.log('Removed dark class from documentElement');\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Initialize dark mode immediately (before page load)\n\t\twindow.darkModeState.init();\n\n\t\tfunction darkModeHandler() {\n\t\t\treturn {\n\t\t\t\tdarkMode: false,\n\t\t\t\tinit() {\n\t\t\t\t\t// Initialize from global state (without re-initializing global state)\n\t\t\t\t\tthis.darkMode = window.darkModeState.darkMode;\n\n\t\t\t\t\t// Listen for changes\n\t\t\t\t\twindow.addEventListener('darkModeChanged', (e) => {\n\t\t\t\t\t\tthis.darkMode = e.detail;\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\ttoggle() {\n\t\t\t\t\twindow.darkModeState.toggle();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
