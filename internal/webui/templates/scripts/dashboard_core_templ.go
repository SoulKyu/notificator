// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func DashboardCore() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\tfunction newDashboard() {\n\t\t\treturn {\n\t\t\t\tloading: true,\n\t\t\t\talerts: [],\n\t\t\t\tgroups: [],\n\t\t\t\tmetadata: {\n\t\t\t\t\ttotalAlerts: 0,\n\t\t\t\t\tfilteredCount: 0,\n\t\t\t\t\tlastUpdate: null,\n\t\t\t\t\tcounters: {\n\t\t\t\t\t\tcritical: 0,\n\t\t\t\t\t\twarning: 0,\n\t\t\t\t\t\tinfo: 0,\n\t\t\t\t\t\tfiring: 0,\n\t\t\t\t\t\tresolved: 0,\n\t\t\t\t\t\tacknowledged: 0,\n\t\t\t\t\t\twithComments: 0\n\t\t\t\t\t},\n\t\t\t\t\tavailableFilters: {\n\t\t\t\t\t\talertmanagers: [],\n\t\t\t\t\t\tseverities: [],\n\t\t\t\t\t\tstatuses: [],\n\t\t\t\t\t\tteams: [],\n\t\t\t\t\t\talertNames: []\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsettings: {\n\t\t\t\t\ttheme: 'light',\n\t\t\t\t\trefreshInterval: 5,\n\t\t\t\t\tresolvedAlertsLimit: 100\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tisRemovingResolvedAlerts: false,\n\t\t\t\t\n\t\t\t\thasInitiallyLoaded: false,\n\t\t\t\tsessionStorageKey: 'dashboard_session_state',\n\n\t\t\t\tdisplayMode: 'classic',\n\t\t\t\tviewMode: 'list',\n\t\t\t\tsortField: 'duration',\n\t\t\t\tsortDirection: 'asc',\n\t\t\t\tgroupByLabel: 'alertname', // Default group by alert name\n\t\t\t\tshowSettings: false,\n\t\t\t\t\n\t\t\t\tshowAckModal: false,\n\t\t\t\tackAction: 'single',\n\t\t\t\tackReason: '',\n\t\t\t\tackError: '',\n\t\t\t\tackSubmitting: false,\n\t\t\t\tcurrentAckAlert: null,\n\t\t\t\tcurrentGroupName: '',\n\t\t\t\t\n\t\t\t\tshowSilenceModal: false,\n\t\t\t\tsilenceAction: 'single',\n\t\t\t\tsilenceReason: '',\n\t\t\t\tsilenceError: '',\n\t\t\t\tsilenceSubmitting: false,\n\t\t\t\tcurrentSilenceAlert: null,\n\t\t\t\tsilenceDuration: '1h',\n\t\t\t\tsilenceDurationType: 'preset',\n\t\t\t\tcustomSilenceDuration: '',\n\t\t\t\tcustomDurationError: '',\n\t\t\t\t\n\t\t\t\tshowAlertModal: false,\n\t\t\t\talertDetails: null,\n\t\t\t\tcurrentAlertTab: 'overview',\n\t\t\t\talertDetailsLoading: false,\n\t\t\t\talertHistory: null,\n\t\t\t\thistoryLoading: false,\n\t\t\t\t\n\t\t\t\t// Filter presets modal state\n\t\t\t\tshowFilterPresetsModal: false,\n\t\t\t\tactivePresetName: null, // Track active default preset name\n\t\t\t\tincludeColumnConfig: true, // Whether to include column config when saving filter preset\n\n\t\t\t\t// Column config modal state\n\t\t\t\tshowColumnConfigModal: false,\n\n\t\t\t\tnewCommentContent: '',\n\t\t\t\tcommentSubmitting: false,\n\t\t\t\tcommentDeleting: {},\n\t\t\t\tcurrentUser: null,\n\t\t\t\t\n\t\t\t\tsearchQuery: '',\n\t\t\t\tfilters: {\n\t\t\t\t\talertmanagers: [],\n\t\t\t\t\tseverities: [],\n\t\t\t\t\tstatuses: [],\n\t\t\t\t\tteams: [],\n\t\t\t\t\talertNames: []\n\t\t\t\t},\n\t\t\t\tacknowledgmentFilter: null,\n\t\t\t\tcommentsFilter: null,\n\t\t\t\t\n\t\t\t\tselectedAlerts: [],\n\t\t\t\tselectedGroups: [],\n\t\t\t\texpandedGroups: [],\n\t\t\t\t\n\t\t\t\t// Pagination\n\t\t\t\tcurrentPage: 1,\n\t\t\t\titemsPerPage: 50,\n\t\t\t\ttotalItems: 0,\n\n\t\t\t\t// Resolved alerts state (mixin will add more properties)\n\t\t\t\tresolvedAlerts: [],\n\t\t\t\tresolvedTotalCount: 0,\n\t\t\t\tresolvedLoading: false,\n\n\t\t\t\trefreshInterval: null,\n\t\t\t\tlastUpdateTime: null,\n\t\t\t\t\n\t\t\t\talertColors: {},\n\t\t\t\talertColorsTimestamp: 0,\n\n\t\t\t\t// Annotation button configs\n\t\t\t\tannotationButtonConfigs: [],\n\n\t\t\t\tcolumnWidths: {\n\t\t\t\t\talertName: 300,\n\t\t\t\t\taction: 100,\n\t\t\t\t\tinstance: 350,\n\t\t\t\t\tseverity: 150,\n\t\t\t\t\tstatus: 150,\n\t\t\t\t\tcomments: 130,\n\t\t\t\t\tteam: 200,\n\t\t\t\t\tsummary: 400,\n\t\t\t\t\tduration: 150,\n\t\t\t\t\tsource: 180\n\t\t\t\t},\n\t\t\t\tisResizing: false,\n\t\t\t\tstartX: 0,\n\t\t\t\tstartWidth: 0,\n\t\t\t\tcurrentColumn: null,\n\n\t\t\t\t// Dynamic columns configuration\n\t\t\t\tcolumns: [],\n\t\t\t\tvisibleColumns: [],\n\t\t\t\tresizingColumn: null,\n\t\t\t\tresizeStartX: 0,\n\t\t\t\tresizeStartWidth: 0,\n\t\t\t\tsorting: { field: null, direction: 'asc' },\n\n\t\t\t\tgetDisplayStatus(status) {\n\t\t\t\t\tif (!status?.state) return 'unknown';\n\t\t\t\t\treturn status.state === 'suppressed' ? 'silenced' : status.state;\n\t\t\t\t},\n\n\t\t\t\tstatusMatches(status, value) {\n\t\t\t\t\tconst displayStatus = this.getDisplayStatus(status);\n\t\t\t\t\treturn displayStatus === value;\n\t\t\t\t},\n\n\t\t\t\t// Check if response indicates authentication failure\n\t\t\t\thandleAuthError(response) {\n\t\t\t\t\t// Redirect to login if unauthorized or service unavailable\n\t\t\t\t\tif (response.status === 401 || response.status === 503) {\n\t\t\t\t\t\twindow.location.href = '/login';\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\n\t\t\t\t// Validate session with backend\n\t\t\t\tasync validateSession() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/auth/me', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Check for authentication errors and redirect if needed\n\t\t\t\t\t\tif (this.handleAuthError(response)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn response.ok;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Session validation failed:', error);\n\t\t\t\t\t\t// Redirect to login on network error (backend might be down)\n\t\t\t\t\t\twindow.location.href = '/login';\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync init() {\n\t\t\t\t\tObject.assign(this, window.dashboardDataMixin || {});\n\t\t\t\t\tObject.assign(this, window.dashboardActionsMixin || {});\n\t\t\t\t\tObject.assign(this, window.dashboardUtilitiesMixin || {});\n\t\t\t\t\tObject.assign(this, window.dashboardModalMixin || {});\n\t\t\t\t\tObject.assign(this, window.dashboardFilterPresetsMixin || {});\n\t\t\t\t\tObject.assign(this, window.dashboardResolvedAlertsMixin || {});\n\n\t\t\t\t\twindow.dashboardInstance = this;\n\n\t\t\t\t\tthis.initializeSessionTracking();\n\n\t\t\t\t\t// Initialize resolved alerts auto-load watcher\n\t\t\t\t\tif (this.initResolvedAutoLoad) {\n\t\t\t\t\t\tthis.initResolvedAutoLoad();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Load notification banner dismissed state from localStorage\n\t\t\t\t\tthis.notificationBannerDismissed = localStorage.getItem('notificator_banner_dismissed') === 'true';\n\n\t\t\t\t\tthis.loadSettings();\n\t\t\t\t\tthis.loadColumnWidths();\n\t\t\t\t\tthis.initializeColumns();\n\t\t\t\t\tawait this.loadUserColumnPreferences(); // Load user column preferences\n\t\t\t\t\tthis.loadCurrentUser();\n\t\t\t\t\tthis.loadAnnotationButtonConfigs();\n\n\t\t\t\t\t// Check if URL has filter parameters\n\t\t\t\t\tconst params = new URLSearchParams(window.location.search);\n\t\t\t\t\tconst hasURLFilters = params.has('search') || params.has('alertmanagers') ||\n\t\t\t\t\t\t\t\t\t\t  params.has('severities') || params.has('statuses') ||\n\t\t\t\t\t\t\t\t\t\t  params.has('teams') || params.has('alertNames') ||\n\t\t\t\t\t\t\t\t\t\t  params.has('acknowledged') || params.has('hasComments');\n\n\t\t\t\t\tlet defaultPresetLoaded = false;\n\n\t\t\t\t\tif (!hasURLFilters) {\n\t\t\t\t\t\t// No URL filters - try to load default preset (if exists, it will also load data)\n\t\t\t\t\t\tdefaultPresetLoaded = await this.loadDefaultFilterPreset();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Load filters from URL (will override default preset if URL has filters)\n\t\t\t\t\tthis.loadFiltersFromURL();\n\n\t\t\t\t\tthis.startAutoRefresh();\n\n\t\t\t\t\t// Load data if default preset wasn't loaded or URL has filters\n\t\t\t\t\tif (!defaultPresetLoaded) {\n\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.checkAlertFromURL();\n\n\t\t\t\t\tdocument.addEventListener('visibilitychange', async () => {\n\t\t\t\t\t\tif (!document.hidden) {\n\t\t\t\t\t\t\t// Validate session when page becomes visible\n\t\t\t\t\t\t\tconst sessionValid = await this.validateSession();\n\t\t\t\t\t\t\tif (!sessionValid) {\n\t\t\t\t\t\t\t\t// If session invalid, stop refresh and redirect\n\t\t\t\t\t\t\t\tthis.stopAutoRefresh();\n\t\t\t\t\t\t\t\t// validateSession() will handle redirect to login\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Do one incremental fetch to catch any missed updates\n\t\t\t\t\t\t\t\tthis.loadDashboardIncremental();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Don't stop auto-refresh when hidden - let it continue fetching in background\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tdocument.addEventListener('mousemove', this.handleMouseMove.bind(this));\n\t\t\t\t\tdocument.addEventListener('mouseup', this.handleMouseUp.bind(this));\n\t\t\t\t},\n\n\t\t\t\topenSettings() {\n\t\t\t\t\tthis.showSettings = true;\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tgetStatusText() {\n\t\t\t\t\tif (this.loading) return 'Loading...';\n\t\t\t\t\tif (this.metadata && this.metadata.lastUpdate) {\n\t\t\t\t\t\treturn `Last updated: ${new Date(this.metadata.lastUpdate).toLocaleTimeString()}`;\n\t\t\t\t\t}\n\t\t\t\t\treturn 'Ready';\n\t\t\t\t},\n\n\t\t\t\tinitializeSessionTracking() {\n\t\t\t\t\tconst sessionData = sessionStorage.getItem(this.sessionStorageKey);\n\t\t\t\t\t\n\t\t\t\t\tif (sessionData) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst data = JSON.parse(sessionData);\n\t\t\t\t\t\t\tthis.hasInitiallyLoaded = data.hasInitiallyLoaded || false;\n\t\t\t\t\t\t\tconsole.log('Session tracking restored - hasInitiallyLoaded:', this.hasInitiallyLoaded);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.warn('Failed to parse session data, treating as fresh session');\n\t\t\t\t\t\t\tthis.hasInitiallyLoaded = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log('Fresh session detected');\n\t\t\t\t\t\tthis.hasInitiallyLoaded = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.saveSessionState();\n\t\t\t\t},\n\n\t\t\t\tsaveSessionState() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst sessionData = {\n\t\t\t\t\t\t\thasInitiallyLoaded: this.hasInitiallyLoaded,\n\t\t\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tsessionStorage.setItem(this.sessionStorageKey, JSON.stringify(sessionData));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.warn('Failed to save session state:', e);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tsetDisplayMode(mode) {\n\t\t\t\t\tif (this.displayMode !== mode) {\n\t\t\t\t\t\tconst previousMode = this.displayMode;\n\t\t\t\t\t\tthis.displayMode = mode;\n\t\t\t\t\t\tthis.clearSelection();\n\n\t\t\t\t\t\t// Always reload when switching back from resolved to other views\n\t\t\t\t\t\tif (previousMode === 'resolved' && mode !== 'resolved') {\n\t\t\t\t\t\t\tconsole.log('Switching from resolved to', mode, '- reloading alerts');\n\t\t\t\t\t\t\t// Reset lastUpdateTime to force full reload and avoid stale incremental data\n\t\t\t\t\t\t\tthis.lastUpdateTime = null;\n\t\t\t\t\t\t\t// Initialize empty alerts array to prevent Alpine from trying to render undefined\n\t\t\t\t\t\t\tthis.alerts = [];\n\t\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t\t} else if (mode !== 'resolved') {\n\t\t\t\t\t\t\t// For other transitions between non-resolved modes, load as normal\n\t\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Switching TO resolved mode - reset lastUpdateTime to prevent stale data\n\t\t\t\t\t\t\tthis.lastUpdateTime = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Note: When switching TO resolved mode, don't call loadDashboardData\n\t\t\t\t\t\t// because the resolved view has its own data loading logic\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tsetViewMode(mode) {\n\t\t\t\t\tif (this.viewMode !== mode) {\n\t\t\t\t\t\tthis.viewMode = mode;\n\t\t\t\t\t\tthis.clearSelection();\n\t\t\t\t\t\tif (mode === 'group') {\n\t\t\t\t\t\t\tthis.expandedGroups = this.groups.map(g => g.groupName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tstartAutoRefresh() {\n\t\t\t\t\tthis.stopAutoRefresh();\n\t\t\t\t\tthis.refreshInterval = setInterval(() => {\n\t\t\t\t\t\tthis.loadDashboardIncremental();\n\t\t\t\t\t}, this.settings.refreshInterval * 1000);\n\t\t\t\t},\n\n\t\t\t\tstopAutoRefresh() {\n\t\t\t\t\tif (this.refreshInterval) {\n\t\t\t\t\t\tclearInterval(this.refreshInterval);\n\t\t\t\t\t\tthis.refreshInterval = null;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// Notification banner functions\n\t\t\t\tshouldShowNotificationBanner() {\n\t\t\t\t\t// Don't show if dismissed\n\t\t\t\t\tif (this.notificationBannerDismissed) return false;\n\n\t\t\t\t\t// Don't show if notification service not loaded\n\t\t\t\t\tif (!window.notificationService) return false;\n\n\t\t\t\t\t// Show if either permission not granted OR preference not enabled\n\t\t\t\t\tconst permissionGranted = 'Notification' in window && Notification.permission === 'granted';\n\t\t\t\t\tconst preferenceEnabled = window.notificationService.preferences.browserNotificationsEnabled;\n\n\t\t\t\t\treturn !permissionGranted || !preferenceEnabled;\n\t\t\t\t},\n\n\t\t\t\tasync enableNotifications() {\n\t\t\t\t\tif (!window.notificationService) return;\n\n\t\t\t\t\t// Request permission if needed\n\t\t\t\t\tif (!('Notification' in window)) {\n\t\t\t\t\t\tconsole.warn('Browser does not support notifications');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Notification.permission !== 'granted') {\n\t\t\t\t\t\tconst granted = await window.notificationService.requestPermission();\n\t\t\t\t\t\tif (!granted) {\n\t\t\t\t\t\t\tconsole.log('Notification permission denied');\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Enable and save preference\n\t\t\t\t\twindow.notificationService.preferences.browserNotificationsEnabled = true;\n\t\t\t\t\tawait window.notificationService.savePreferences(window.notificationService.preferences);\n\n\t\t\t\t\t// Update permission status in service\n\t\t\t\t\twindow.notificationService.permissionGranted = Notification.permission === 'granted';\n\n\t\t\t\t\tconsole.log('Notifications enabled successfully');\n\n\t\t\t\t\t// Auto-dismiss the banner since notifications are now enabled\n\t\t\t\t\tthis.dismissNotificationBanner();\n\t\t\t\t},\n\n\t\t\t\tdismissNotificationBanner() {\n\t\t\t\t\tthis.notificationBannerDismissed = true;\n\t\t\t\t\t// Save to localStorage\n\t\t\t\t\tlocalStorage.setItem('notificator_banner_dismissed', 'true');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
