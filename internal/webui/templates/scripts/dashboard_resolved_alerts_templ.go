// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func DashboardResolvedAlertsMixin() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\twindow.dashboardResolvedAlertsMixin = {\n\t\t\t// State (will be merged into dashboard)\n\t\t\tresolvedAlerts: [],\n\t\t\tresolvedTotalCount: 0,\n\t\t\tresolvedLoading: false,\n\n\t\t\t// Time range for resolved alerts (separate from main filters)\n\t\t\tresolvedTimeRange: {\n\t\t\t\tstart: '', // datetime-local format\n\t\t\t\tend: '',   // datetime-local format\n\t\t\t},\n\n\t\t\t// Include silenced alerts in results (default: false - exclude silenced)\n\t\t\tresolvedIncludeSilenced: false,\n\n\t\t\t// Pagination for resolved alerts\n\t\t\tresolvedPagination: {\n\t\t\t\tlimit: 100,\n\t\t\t\toffset: 0\n\t\t\t},\n\n\t\t\t// Initialize time range on component init\n\t\t\tinitResolvedTimeRange() {\n\t\t\t\tconst now = new Date();\n\t\t\t\tconst oneDayAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));\n\n\t\t\t\t// Format for datetime-local input (YYYY-MM-DDTHH:mm)\n\t\t\t\tthis.resolvedTimeRange.end = this.formatDateTimeLocal(now);\n\t\t\t\tthis.resolvedTimeRange.start = this.formatDateTimeLocal(oneDayAgo);\n\t\t\t},\n\n\t\t\t// Format date for datetime-local input\n\t\t\tformatDateTimeLocal(date) {\n\t\t\t\tconst year = date.getFullYear();\n\t\t\t\tconst month = String(date.getMonth() + 1).padStart(2, '0');\n\t\t\t\tconst day = String(date.getDate()).padStart(2, '0');\n\t\t\t\tconst hours = String(date.getHours()).padStart(2, '0');\n\t\t\t\tconst minutes = String(date.getMinutes()).padStart(2, '0');\n\t\t\t\treturn `${year}-${month}-${day}T${hours}:${minutes}`;\n\t\t\t},\n\n\t\t\t// Set time range with preset (hours from now)\n\t\t\tasync setResolvedTimeRange(hours) {\n\t\t\t\tconst now = new Date();\n\t\t\t\tconst startDate = new Date(now.getTime() - (hours * 60 * 60 * 1000));\n\n\t\t\t\tthis.resolvedTimeRange.start = this.formatDateTimeLocal(startDate);\n\t\t\t\tthis.resolvedTimeRange.end = this.formatDateTimeLocal(now);\n\n\t\t\t\tawait this.applyResolvedTimeRange();\n\t\t\t},\n\n\t\t\t// Apply time range change and reload\n\t\t\tasync applyResolvedTimeRange() {\n\t\t\t\tthis.resolvedPagination.offset = 0; // Reset pagination\n\t\t\t\tawait this.loadResolvedAlerts();\n\t\t\t},\n\n\t\t\t// Count active filters from main dashboard\n\t\t\tgetActiveFiltersCount() {\n\t\t\t\tlet count = 0;\n\t\t\t\tif (this.filters.alertmanagers && this.filters.alertmanagers.length > 0) count++;\n\t\t\t\tif (this.filters.severities && this.filters.severities.length > 0) count++;\n\t\t\t\tif (this.filters.statuses && this.filters.statuses.length > 0) count++;\n\t\t\t\tif (this.filters.teams && this.filters.teams.length > 0) count++;\n\t\t\t\tif (this.filters.alertNames && this.filters.alertNames.length > 0) count++;\n\t\t\t\tif (this.searchQuery && this.searchQuery.trim().length > 0) count++;\n\t\t\t\tif (this.acknowledgmentFilter !== null) count++;\n\t\t\t\tif (this.commentsFilter !== null) count++;\n\t\t\t\treturn count;\n\t\t\t},\n\n\t\t\t// Load recently resolved alerts using main dashboard filters + time range\n\t\t\tasync loadResolvedAlerts() {\n\t\t\t\t// Initialize time range if not set\n\t\t\t\tif (!this.resolvedTimeRange.start || !this.resolvedTimeRange.end) {\n\t\t\t\t\tthis.initResolvedTimeRange();\n\t\t\t\t}\n\n\t\t\t\tthis.resolvedLoading = true;\n\n\t\t\t\ttry {\n\t\t\t\t\t// Parse datetime-local to ISO string\n\t\t\t\t\tconst startDate = new Date(this.resolvedTimeRange.start);\n\t\t\t\t\tconst endDate = new Date(this.resolvedTimeRange.end);\n\n\t\t\t\t\t// Build request using main dashboard filters\n\t\t\t\t\tconst requestBody = {\n\t\t\t\t\t\tstart_date: startDate.toISOString(),\n\t\t\t\t\t\tend_date: endDate.toISOString(),\n\t\t\t\t\t\tseverity: this.filters.severities || [],\n\t\t\t\t\t\tteam: (this.filters.teams && this.filters.teams.length > 0) ? this.filters.teams.join(',') : '',\n\t\t\t\t\t\talert_name: (this.filters.alertNames && this.filters.alertNames.length > 0) ? this.filters.alertNames.join(',') : '',\n\t\t\t\t\t\tsearch_query: this.searchQuery || '',\n\t\t\t\t\t\tinclude_silenced: this.resolvedIncludeSilenced,\n\t\t\t\t\t\tlimit: this.resolvedPagination.limit,\n\t\t\t\t\t\toffset: this.resolvedPagination.offset\n\t\t\t\t\t};\n\n\t\t\t\t\tconsole.log('Loading resolved alerts with filters:', requestBody);\n\n\t\t\t\t\tconst response = await fetch('/api/v1/statistics/recently-resolved', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\t\tbody: JSON.stringify(requestBody)\n\t\t\t\t\t});\n\n\t\t\t\t\tconst data = await response.json();\n\n\t\t\t\t\tif (data.success && data.data) {\n\t\t\t\t\t\tthis.resolvedAlerts = data.data.alerts || [];\n\t\t\t\t\t\tthis.resolvedTotalCount = data.data.total_count || 0;\n\t\t\t\t\t\tconsole.log(`Loaded ${this.resolvedAlerts.length} unique fingerprints (${this.resolvedTotalCount} total)`);\n\t\t\t\t\t\tconsole.log('Sample alert:', this.resolvedAlerts[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('Failed to load resolved alerts:', data.message || 'Unknown error');\n\t\t\t\t\t\tthis.resolvedAlerts = [];\n\t\t\t\t\t\tthis.resolvedTotalCount = 0;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error loading resolved alerts:', error);\n\t\t\t\t\tthis.resolvedAlerts = [];\n\t\t\t\t\tthis.resolvedTotalCount = 0;\n\t\t\t\t} finally {\n\t\t\t\t\tthis.resolvedLoading = false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Pagination\n\t\t\tasync loadResolvedPage(offset) {\n\t\t\t\tthis.resolvedPagination.offset = offset;\n\t\t\t\tawait this.loadResolvedAlerts();\n\t\t\t},\n\n\t\t\t// Format duration for display\n\t\t\tformatResolvedDuration(seconds) {\n\t\t\t\tif (!seconds || seconds === 0) return '0s';\n\n\t\t\t\tconst hours = Math.floor(seconds / 3600);\n\t\t\t\tconst minutes = Math.floor((seconds % 3600) / 60);\n\t\t\t\tconst secs = seconds % 60;\n\n\t\t\t\tconst parts = [];\n\t\t\t\tif (hours > 0) parts.push(`${hours}h`);\n\t\t\t\tif (minutes > 0) parts.push(`${minutes}m`);\n\t\t\t\tif (secs > 0 || parts.length === 0) parts.push(`${secs}s`);\n\n\t\t\t\treturn parts.join(' ');\n\t\t\t},\n\n\t\t\t// Get severity badge class\n\t\t\tgetResolvedSeverityClass(severity) {\n\t\t\t\tconst classes = {\n\t\t\t\t\t'critical': 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-400',\n\t\t\t\t\t'warning': 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-400',\n\t\t\t\t\t'info': 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-400'\n\t\t\t\t};\n\t\t\t\treturn classes[severity.toLowerCase()] || 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';\n\t\t\t},\n\n\t\t\t// Show alert details from resolved tab\n\t\t\tasync showResolvedAlertDetails(alert) {\n\t\t\t\t// Reuse existing modal infrastructure\n\t\t\t\t// Convert resolved alert back to DashboardAlert format for compatibility\n\t\t\t\tconst dashboardAlert = {\n\t\t\t\t\tfingerprint: alert.fingerprint,\n\t\t\t\t\talertName: alert.alert_name,\n\t\t\t\t\tseverity: alert.severity,\n\t\t\t\t\tstartsAt: alert.fired_at,\n\t\t\t\t\tendsAt: alert.resolved_at,\n\t\t\t\t\tlabels: alert.labels || {},\n\t\t\t\t\tannotations: alert.annotations || {},\n\t\t\t\t\tsource: alert.source,\n\t\t\t\t\tinstance: alert.instance,\n\t\t\t\t\tisResolved: true,\n\t\t\t\t\tresolvedAt: alert.resolved_at,\n\t\t\t\t\tstatus: { state: 'resolved' }\n\t\t\t\t};\n\n\t\t\t\t// Use existing modal\n\t\t\t\tawait this.showAlertModal(dashboardAlert);\n\t\t\t}\n\t\t};\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
