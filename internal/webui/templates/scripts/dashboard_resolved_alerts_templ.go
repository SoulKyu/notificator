// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func DashboardResolvedAlertsMixin() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\twindow.dashboardResolvedAlertsMixin = {\n\t\t\t// State (will be merged into dashboard)\n\t\t\tresolvedAlerts: [],\n\t\t\tresolvedTotalCount: 0,\n\t\t\tresolvedLoading: false,\n\n\t\t\t// Time range for resolved alerts (separate from main filters)\n\t\t\tresolvedTimeRange: {\n\t\t\t\tstart: '', // datetime-local format\n\t\t\t\tend: '',   // datetime-local format\n\t\t\t},\n\n\t\t\t// Include silenced alerts in results (default: false - exclude silenced)\n\t\t\tresolvedIncludeSilenced: false,\n\n\t\t\t// Pagination for resolved alerts\n\t\t\tresolvedPagination: {\n\t\t\t\tlimit: 100,\n\t\t\t\toffset: 0\n\t\t\t},\n\n\t\t\t// Sorting for resolved alerts\n\t\t\tresolvedSortField: 'last_resolved_at',  // Default sort by last resolved\n\t\t\tresolvedSortDirection: 'desc',          // Most recent first\n\n\t\t\t// Initialize time range on component init\n\t\t\tinitResolvedTimeRange() {\n\t\t\t\tconst now = new Date();\n\t\t\t\tconst oneDayAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));\n\n\t\t\t\t// Format for datetime-local input (YYYY-MM-DDTHH:mm)\n\t\t\t\tthis.resolvedTimeRange.end = this.formatDateTimeLocal(now);\n\t\t\t\tthis.resolvedTimeRange.start = this.formatDateTimeLocal(oneDayAgo);\n\t\t\t},\n\n\t\t\t// Format date for datetime-local input\n\t\t\tformatDateTimeLocal(date) {\n\t\t\t\tconst year = date.getFullYear();\n\t\t\t\tconst month = String(date.getMonth() + 1).padStart(2, '0');\n\t\t\t\tconst day = String(date.getDate()).padStart(2, '0');\n\t\t\t\tconst hours = String(date.getHours()).padStart(2, '0');\n\t\t\t\tconst minutes = String(date.getMinutes()).padStart(2, '0');\n\t\t\t\treturn `${year}-${month}-${day}T${hours}:${minutes}`;\n\t\t\t},\n\n\t\t\t// Set time range with preset (hours from now)\n\t\t\tasync setResolvedTimeRange(hours) {\n\t\t\t\tconst now = new Date();\n\t\t\t\tconst startDate = new Date(now.getTime() - (hours * 60 * 60 * 1000));\n\n\t\t\t\tthis.resolvedTimeRange.start = this.formatDateTimeLocal(startDate);\n\t\t\t\tthis.resolvedTimeRange.end = this.formatDateTimeLocal(now);\n\n\t\t\t\tawait this.applyResolvedTimeRange();\n\t\t\t},\n\n\t\t\t// Apply time range change and reload\n\t\t\tasync applyResolvedTimeRange() {\n\t\t\t\tthis.resolvedPagination.offset = 0; // Reset pagination\n\t\t\t\tawait this.loadResolvedAlerts();\n\t\t\t},\n\n\t\t\t// Count active filters from main dashboard\n\t\t\tgetActiveFiltersCount() {\n\t\t\t\tlet count = 0;\n\t\t\t\tif (this.filters.alertmanagers && this.filters.alertmanagers.length > 0) count++;\n\t\t\t\tif (this.filters.severities && this.filters.severities.length > 0) count++;\n\t\t\t\tif (this.filters.statuses && this.filters.statuses.length > 0) count++;\n\t\t\t\tif (this.filters.teams && this.filters.teams.length > 0) count++;\n\t\t\t\tif (this.filters.alertNames && this.filters.alertNames.length > 0) count++;\n\t\t\t\tif (this.searchQuery && this.searchQuery.trim().length > 0) count++;\n\t\t\t\tif (this.acknowledgmentFilter !== null) count++;\n\t\t\t\tif (this.commentsFilter !== null) count++;\n\t\t\t\treturn count;\n\t\t\t},\n\n\t\t\t// Load recently resolved alerts using main dashboard filters + time range\n\t\t\tasync loadResolvedAlerts() {\n\t\t\t\t// Initialize time range if not set\n\t\t\t\tif (!this.resolvedTimeRange.start || !this.resolvedTimeRange.end) {\n\t\t\t\t\tthis.initResolvedTimeRange();\n\t\t\t\t}\n\n\t\t\t\tthis.resolvedLoading = true;\n\n\t\t\t\ttry {\n\t\t\t\t\t// Parse datetime-local to ISO string\n\t\t\t\t\tconst startDate = new Date(this.resolvedTimeRange.start);\n\t\t\t\t\tconst endDate = new Date(this.resolvedTimeRange.end);\n\n\n\t\t\t\t\t// Build request using main dashboard filters\n\t\t\t\t\tconst requestBody = {\n\t\t\t\t\t\tstart_date: startDate.toISOString(),\n\t\t\t\t\t\tend_date: endDate.toISOString(),\n\t\t\t\t\t\tseverity: this.filters.severities || [],\n\t\t\t\t\t\tteam: (this.filters.teams && this.filters.teams.length > 0) ? this.filters.teams.join(',') : '',\n\t\t\t\t\t\talert_name: (this.filters.alertNames && this.filters.alertNames.length > 0) ? this.filters.alertNames.join(',') : '',\n\t\t\t\t\t\tsearch_query: this.searchQuery || '',\n\t\t\t\t\t\tinclude_silenced: this.resolvedIncludeSilenced,\n\t\t\t\t\t\tlimit: this.resolvedPagination.limit,\n\t\t\t\t\t\toffset: this.resolvedPagination.offset\n\t\t\t\t\t};\n\n\t\t\t\t\tconsole.log('Loading resolved alerts with filters:', requestBody);\n\n\t\t\t\t\tconst response = await fetch('/api/v1/statistics/recently-resolved', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\t\tbody: JSON.stringify(requestBody)\n\t\t\t\t\t});\n\n\t\t\t\t\tconst data = await response.json();\n\n\t\t\t\t\tif (data.success && data.data) {\n\t\t\t\t\t\tthis.resolvedAlerts = data.data.alerts || [];\n\t\t\t\t\t\tthis.resolvedTotalCount = data.data.total_count || 0;\n\t\t\t\t\t\tconsole.log(`Loaded ${this.resolvedAlerts.length} unique fingerprints (${this.resolvedTotalCount} total)`);\n\t\t\t\t\t\tconsole.log('Sample alert:', this.resolvedAlerts[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('Failed to load resolved alerts:', data.message || 'Unknown error');\n\t\t\t\t\t\tthis.resolvedAlerts = [];\n\t\t\t\t\t\tthis.resolvedTotalCount = 0;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error loading resolved alerts:', error);\n\t\t\t\t\tthis.resolvedAlerts = [];\n\t\t\t\t\tthis.resolvedTotalCount = 0;\n\t\t\t\t} finally {\n\t\t\t\t\tthis.resolvedLoading = false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Pagination\n\t\t\tasync loadResolvedPage(offset) {\n\t\t\t\tthis.resolvedPagination.offset = offset;\n\t\t\t\tawait this.loadResolvedAlerts();\n\t\t\t},\n\n\t\t\t// Format duration for display\n\t\t\tformatResolvedDuration(seconds) {\n\t\t\t\tif (!seconds || seconds === 0) return '0s';\n\n\t\t\t\tconst hours = Math.floor(seconds / 3600);\n\t\t\t\tconst minutes = Math.floor((seconds % 3600) / 60);\n\t\t\t\tconst secs = seconds % 60;\n\n\t\t\t\tconst parts = [];\n\t\t\t\tif (hours > 0) parts.push(`${hours}h`);\n\t\t\t\tif (minutes > 0) parts.push(`${minutes}m`);\n\t\t\t\tif (secs > 0 || parts.length === 0) parts.push(`${secs}s`);\n\n\t\t\t\treturn parts.join(' ');\n\t\t\t},\n\n\t\t\t// Get severity badge class\n\t\t\tgetResolvedSeverityClass(severity) {\n\t\t\t\tconst classes = {\n\t\t\t\t\t'critical': 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-400',\n\t\t\t\t\t'warning': 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-400',\n\t\t\t\t\t'info': 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-400'\n\t\t\t\t};\n\t\t\t\treturn classes[severity.toLowerCase()] || 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';\n\t\t\t},\n\n\t\t\t// Show alert details from resolved tab\n\t\t\tasync showResolvedAlertDetails(alert) {\n\t\t\t\t// Use existing modal infrastructure - just pass fingerprint\n\t\t\t\tawait this.showAlertDetails(alert.fingerprint);\n\t\t\t},\n\n\t\t\t// Toggle sort for resolved alerts table\n\t\t\tsortResolvedAlerts(field) {\n\t\t\t\tif (this.resolvedSortField === field) {\n\t\t\t\t\t// Toggle direction if clicking same field\n\t\t\t\t\tthis.resolvedSortDirection = this.resolvedSortDirection === 'asc' ? 'desc' : 'asc';\n\t\t\t\t} else {\n\t\t\t\t\t// New field - default to ascending\n\t\t\t\t\tthis.resolvedSortField = field;\n\t\t\t\t\tthis.resolvedSortDirection = 'asc';\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Get sorted resolved alerts\n\t\t\tgetSortedResolvedAlerts() {\n\t\t\t\tif (!this.resolvedAlerts || this.resolvedAlerts.length === 0) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tconst sorted = [...this.resolvedAlerts];\n\t\t\t\tconst field = this.resolvedSortField;\n\t\t\t\tconst direction = this.resolvedSortDirection;\n\n\t\t\t\tsorted.sort((a, b) => {\n\t\t\t\t\tlet aVal = a[field];\n\t\t\t\t\tlet bVal = b[field];\n\n\t\t\t\t\t// Handle null/undefined values\n\t\t\t\t\tif (aVal === null || aVal === undefined) aVal = '';\n\t\t\t\t\tif (bVal === null || bVal === undefined) bVal = '';\n\n\t\t\t\t\t// Special handling for different data types\n\t\t\t\t\tif (field === 'occurrence_count' || field === 'avg_duration' ||\n\t\t\t\t\t    field === 'avg_mttr' || field === 'total_duration' || field === 'total_mttr') {\n\t\t\t\t\t\t// Numeric comparison\n\t\t\t\t\t\taVal = parseFloat(aVal) || 0;\n\t\t\t\t\t\tbVal = parseFloat(bVal) || 0;\n\t\t\t\t\t} else if (field === 'first_fired_at' || field === 'last_resolved_at') {\n\t\t\t\t\t\t// Date comparison\n\t\t\t\t\t\taVal = new Date(aVal).getTime();\n\t\t\t\t\t\tbVal = new Date(bVal).getTime();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// String comparison (case-insensitive)\n\t\t\t\t\t\taVal = String(aVal).toLowerCase();\n\t\t\t\t\t\tbVal = String(bVal).toLowerCase();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (aVal < bVal) return direction === 'asc' ? -1 : 1;\n\t\t\t\t\tif (aVal > bVal) return direction === 'asc' ? 1 : -1;\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\n\t\t\t\treturn sorted;\n\t\t\t},\n\n\t\t\t// Calculate statistics from resolved alerts\n\t\t\tcalculateResolvedStatistics() {\n\t\t\t\tif (!this.resolvedAlerts || this.resolvedAlerts.length === 0) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttotalResolved: 0,\n\t\t\t\t\t\ttotalOccurrences: 0,\n\t\t\t\t\t\tavgMTTR: 0,\n\t\t\t\t\t\tavgDuration: 0,\n\t\t\t\t\t\tmostFrequent: null,\n\t\t\t\t\t\tfastestResolution: null,\n\t\t\t\t\t\tseverityBreakdown: { critical: 0, warning: 0, info: 0 }\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tlet totalOccurrences = 0;\n\t\t\t\tlet totalDuration = 0;\n\t\t\t\tlet totalMTTR = 0;\n\t\t\t\tconst severityBreakdown = { critical: 0, warning: 0, info: 0 };\n\t\t\t\tlet fastestResolution = null;\n\t\t\t\tlet mostFrequent = null;\n\n\t\t\t\tthis.resolvedAlerts.forEach(alert => {\n\t\t\t\t\t// Count occurrences\n\t\t\t\t\tconst occurrences = alert.occurrences || 1;\n\t\t\t\t\ttotalOccurrences += occurrences;\n\n\t\t\t\t\t// Sum durations\n\t\t\t\t\tif (alert.avg_duration) {\n\t\t\t\t\t\ttotalDuration += alert.avg_duration;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Sum MTTR\n\t\t\t\t\tif (alert.avg_mttr) {\n\t\t\t\t\t\ttotalMTTR += alert.avg_mttr;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Count by severity\n\t\t\t\t\tconst severity = (alert.severity || 'info').toLowerCase();\n\t\t\t\t\tif (severity === 'critical' || severity === 'critical-daytime') {\n\t\t\t\t\t\tseverityBreakdown.critical += occurrences;\n\t\t\t\t\t} else if (severity === 'warning') {\n\t\t\t\t\t\tseverityBreakdown.warning += occurrences;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tseverityBreakdown.info += occurrences;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Find most frequent\n\t\t\t\t\tif (!mostFrequent || occurrences > mostFrequent.occurrences) {\n\t\t\t\t\t\tmostFrequent = alert;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Find fastest resolution\n\t\t\t\t\tif (alert.avg_mttr && (!fastestResolution || alert.avg_mttr < fastestResolution.avg_mttr)) {\n\t\t\t\t\t\tfastestResolution = alert;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tconst alertCount = this.resolvedAlerts.length;\n\n\t\t\t\treturn {\n\t\t\t\t\ttotalResolved: alertCount,\n\t\t\t\t\ttotalOccurrences: totalOccurrences,\n\t\t\t\t\tavgMTTR: alertCount > 0 ? totalMTTR / alertCount : 0,\n\t\t\t\t\tavgDuration: alertCount > 0 ? totalDuration / alertCount : 0,\n\t\t\t\t\tmostFrequent: mostFrequent,\n\t\t\t\t\tfastestResolution: fastestResolution,\n\t\t\t\t\tseverityBreakdown: severityBreakdown\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t// Format duration in seconds to human-readable string\n\t\t\tformatDurationHuman(seconds) {\n\t\t\t\tif (!seconds || seconds < 0) return '0s';\n\n\t\t\t\tconst hours = Math.floor(seconds / 3600);\n\t\t\t\tconst minutes = Math.floor((seconds % 3600) / 60);\n\t\t\t\tconst secs = Math.floor(seconds % 60);\n\n\t\t\t\tif (hours > 0) {\n\t\t\t\t\treturn `${hours}h ${minutes}m`;\n\t\t\t\t} else if (minutes > 0) {\n\t\t\t\t\treturn `${minutes}m ${secs}s`;\n\t\t\t\t} else {\n\t\t\t\t\treturn `${secs}s`;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Format large numbers with K/M suffix\n\t\t\tformatNumber(num) {\n\t\t\t\tif (!num || num < 0) return '0';\n\t\t\t\tif (num >= 1000000) {\n\t\t\t\t\treturn (num / 1000000).toFixed(1) + 'M';\n\t\t\t\t} else if (num >= 1000) {\n\t\t\t\t\treturn (num / 1000).toFixed(1) + 'K';\n\t\t\t\t}\n\t\t\t\treturn num.toString();\n\t\t\t}\n\t\t};\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
