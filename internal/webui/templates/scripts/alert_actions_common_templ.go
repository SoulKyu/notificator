// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

// Common alert actions script shared between dashboard and standalone alert page
func AlertActionsCommon() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\twindow.alertActionsCommonMixin = {\n\t\t\t// Related alerts state variables\n\t\t\trelatedFilter: 'all',\n\t\t\trelatedCurrentPage: 1,\n\t\t\trelatedPageSize: 10,\n\t\t\trelatedTotalResults: 0,\n\t\t\trelatedTotalPages: 0,\n\t\t\trelatedAllAlerts: [],\n\t\t\trelatedSearchQuery: '',\n\t\t\trelatedLoading: false,\n\t\t\trelatedAlerts: [],\n\t\t\t\n\t\t\t// Modal state variables\n\t\t\tshowAckModal: false,\n\t\t\tackAction: 'single', // 'single', 'bulk', or 'group'\n\t\t\tackReason: '',\n\t\t\tackError: '',\n\t\t\tackSubmitting: false,\n\t\t\tcurrentAckAlert: null,\n\t\t\tcurrentGroupName: '',\n\t\t\t\n\t\t\tshowSilenceModal: false,\n\t\t\tsilenceAction: 'single', // 'single', 'bulk', or 'group'\n\t\t\tsilenceReason: '',\n\t\t\tsilenceError: '',\n\t\t\tsilenceSubmitting: false,\n\t\t\tcurrentSilenceAlert: null,\n\t\t\tsilenceDuration: '1h',\n\t\t\tsilenceDurationType: 'preset', // 'preset' or 'custom'\n\t\t\tcustomSilenceDuration: '',\n\t\t\tcustomDurationError: '',\n\n\t\t\t// Acknowledge Modal Functions\n\t\t\tcancelAcknowledgment() {\n\t\t\t\tthis.showAckModal = false;\n\t\t\t\tthis.ackReason = '';\n\t\t\t\tthis.ackError = '';\n\t\t\t\tthis.ackSubmitting = false;\n\t\t\t\tthis.currentAckAlert = null;\n\t\t\t\tthis.currentGroupName = '';\n\t\t\t},\n\t\t\t\n\t\t\tasync submitAcknowledgment() {\n\t\t\t\tif (!this.ackReason.trim()) {\n\t\t\t\t\tthis.ackError = 'Please provide a reason for the acknowledgment';\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.ackSubmitting = true;\n\t\t\t\tthis.ackError = '';\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tlet request;\n\t\t\t\t\tlet successMessage;\n\t\t\t\t\t\n\t\t\t\t\tswitch (this.ackAction) {\n\t\t\t\t\t\tcase 'single':\n\t\t\t\t\t\t\t// Safety check: ensure we have a valid alert with fingerprint\n\t\t\t\t\t\t\tlet alertFingerprint = null;\n\t\t\t\t\t\t\tif (this.currentAckAlert && this.currentAckAlert.fingerprint) {\n\t\t\t\t\t\t\t\talertFingerprint = this.currentAckAlert.fingerprint;\n\t\t\t\t\t\t\t} else if (this.alertDetails && this.alertDetails.alert && this.alertDetails.alert.fingerprint) {\n\t\t\t\t\t\t\t\t// Fallback to alertDetails for standalone context\n\t\t\t\t\t\t\t\talertFingerprint = this.alertDetails.alert.fingerprint;\n\t\t\t\t\t\t\t} else if (this.alertId) {\n\t\t\t\t\t\t\t\t// Final fallback using alertId if available\n\t\t\t\t\t\t\t\talertFingerprint = this.alertId;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!alertFingerprint) {\n\t\t\t\t\t\t\t\tthis.ackError = 'Alert information not available';\n\t\t\t\t\t\t\t\tthis.ackSubmitting = false;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\trequest = {\n\t\t\t\t\t\t\t\talertFingerprints: [alertFingerprint],\n\t\t\t\t\t\t\t\tgroupNames: [],\n\t\t\t\t\t\t\t\taction: 'acknowledge',\n\t\t\t\t\t\t\t\tcomment: this.ackReason\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tsuccessMessage = 'Alert acknowledged successfully';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tcase 'group':\n\t\t\t\t\t\t\trequest = {\n\t\t\t\t\t\t\t\talertFingerprints: [],\n\t\t\t\t\t\t\t\tgroupNames: [this.currentGroupName],\n\t\t\t\t\t\t\t\taction: 'acknowledge',\n\t\t\t\t\t\t\t\tcomment: this.ackReason\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tsuccessMessage = `Group \"${this.currentGroupName}\" acknowledged successfully`;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tcase 'bulk':\n\t\t\t\t\t\t\trequest = {\n\t\t\t\t\t\t\t\talertFingerprints: this.selectedAlerts || [],\n\t\t\t\t\t\t\t\tgroupNames: this.selectedGroups || [],\n\t\t\t\t\t\t\t\taction: 'acknowledge',\n\t\t\t\t\t\t\t\tcomment: this.ackReason\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tconst totalCount = (this.selectedAlerts?.length || 0) + (this.selectedGroups?.length || 0);\n\t\t\t\t\t\t\tsuccessMessage = `${totalCount} items acknowledged successfully`;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthis.ackError = 'Invalid acknowledgment action';\n\t\t\t\t\t\t\tthis.ackSubmitting = false;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t\t});\n\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.showNotification('success', successMessage);\n\t\t\t\t\t\tthis.showAckModal = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Clear selection if bulk action (only if method exists)\n\t\t\t\t\t\tif (this.ackAction === 'bulk' && typeof this.clearSelection === 'function') {\n\t\t\t\t\t\t\tthis.clearSelection();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Refresh data - use appropriate method based on context\n\t\t\t\t\t\tif (typeof this.loadDashboardData === 'function') {\n\t\t\t\t\t\t\tthis.loadDashboardData(); // Dashboard context\n\t\t\t\t\t\t} else if (typeof this.loadAlertDetails === 'function') {\n\t\t\t\t\t\t\tthis.loadAlertDetails(); // Standalone page context\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.ackError = result.error || 'Failed to acknowledge';\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error submitting acknowledgment:', error);\n\t\t\t\t\tthis.ackError = 'Network error: Failed to submit acknowledgment';\n\t\t\t\t} finally {\n\t\t\t\t\tthis.ackSubmitting = false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Silence Modal Functions\n\t\t\tcancelSilence() {\n\t\t\t\tthis.showSilenceModal = false;\n\t\t\t\tthis.silenceReason = '';\n\t\t\t\tthis.silenceError = '';\n\t\t\t\tthis.silenceSubmitting = false;\n\t\t\t\tthis.currentSilenceAlert = null;\n\t\t\t\tthis.currentGroupName = '';\n\t\t\t\tthis.silenceDuration = '1h';\n\t\t\t\tthis.silenceDurationType = 'preset';\n\t\t\t\tthis.customSilenceDuration = '';\n\t\t\t\tthis.customDurationError = '';\n\t\t\t},\n\n\t\t\t\n\t\t\tasync submitSilence() {\n\t\t\t\tif (!this.silenceReason.trim()) {\n\t\t\t\t\tthis.silenceError = 'Please provide a reason for the silence';\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (this.silenceDurationType === 'custom') {\n\t\t\t\t\tif (!this.validateCustomDuration()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.silenceSubmitting = true;\n\t\t\t\tthis.silenceError = '';\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tlet request;\n\t\t\t\t\tlet successMessage;\n\t\t\t\t\t\n\t\t\t\t\tconst durationFields = {};\n\t\t\t\t\tif (this.silenceDurationType === 'custom') {\n\t\t\t\t\t\tdurationFields.silenceDurationType = 'custom';\n\t\t\t\t\t\tdurationFields.customSilenceDuration = this.customSilenceDuration.trim();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdurationFields.silenceDuration = this.parseDurationToSeconds(this.silenceDuration) * 1000000000;\n\t\t\t\t\t\tdurationFields.silenceDurationType = 'preset';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tswitch (this.silenceAction) {\n\t\t\t\t\t\tcase 'single':\n\t\t\t\t\t\t\t// Safety check: ensure we have a valid alert with fingerprint\n\t\t\t\t\t\t\tlet alertFingerprint = null;\n\t\t\t\t\t\t\tif (this.currentSilenceAlert && this.currentSilenceAlert.fingerprint) {\n\t\t\t\t\t\t\t\talertFingerprint = this.currentSilenceAlert.fingerprint;\n\t\t\t\t\t\t\t} else if (this.alertDetails && this.alertDetails.alert && this.alertDetails.alert.fingerprint) {\n\t\t\t\t\t\t\t\t// Fallback to alertDetails for standalone context\n\t\t\t\t\t\t\t\talertFingerprint = this.alertDetails.alert.fingerprint;\n\t\t\t\t\t\t\t} else if (this.alertId) {\n\t\t\t\t\t\t\t\t// Final fallback using alertId if available\n\t\t\t\t\t\t\t\talertFingerprint = this.alertId;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!alertFingerprint) {\n\t\t\t\t\t\t\t\tthis.silenceError = 'Alert information not available';\n\t\t\t\t\t\t\t\tthis.silenceSubmitting = false;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\trequest = {\n\t\t\t\t\t\t\t\talertFingerprints: [alertFingerprint],\n\t\t\t\t\t\t\t\tgroupNames: [],\n\t\t\t\t\t\t\t\taction: 'silence',\n\t\t\t\t\t\t\t\tcomment: this.silenceReason,\n\t\t\t\t\t\t\t\t...durationFields\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tsuccessMessage = 'Alert silenced successfully';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tcase 'group':\n\t\t\t\t\t\t\trequest = {\n\t\t\t\t\t\t\t\talertFingerprints: [],\n\t\t\t\t\t\t\t\tgroupNames: [this.currentGroupName],\n\t\t\t\t\t\t\t\taction: 'silence',\n\t\t\t\t\t\t\t\tcomment: this.silenceReason,\n\t\t\t\t\t\t\t\t...durationFields\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tsuccessMessage = `Group \"${this.currentGroupName}\" silenced successfully`;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tcase 'bulk':\n\t\t\t\t\t\t\trequest = {\n\t\t\t\t\t\t\t\talertFingerprints: this.selectedAlerts || [],\n\t\t\t\t\t\t\t\tgroupNames: this.selectedGroups || [],\n\t\t\t\t\t\t\t\taction: 'silence',\n\t\t\t\t\t\t\t\tcomment: this.silenceReason,\n\t\t\t\t\t\t\t\t...durationFields\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tconst totalCount = (this.selectedAlerts?.length || 0) + (this.selectedGroups?.length || 0);\n\t\t\t\t\t\t\tsuccessMessage = `${totalCount} items silenced successfully`;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthis.silenceError = 'Invalid silence action';\n\t\t\t\t\t\t\tthis.silenceSubmitting = false;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t\t});\n\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.showNotification('success', successMessage);\n\t\t\t\t\t\tthis.showSilenceModal = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Clear selection if bulk action (only if method exists)\n\t\t\t\t\t\tif (this.silenceAction === 'bulk' && typeof this.clearSelection === 'function') {\n\t\t\t\t\t\t\tthis.clearSelection();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Refresh data - use appropriate method based on context\n\t\t\t\t\t\tif (typeof this.loadDashboardData === 'function') {\n\t\t\t\t\t\t\tthis.loadDashboardData(); // Dashboard context\n\t\t\t\t\t\t} else if (typeof this.loadAlertDetails === 'function') {\n\t\t\t\t\t\t\tthis.loadAlertDetails(); // Standalone page context\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.silenceError = result.error || 'Failed to silence';\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error submitting silence:', error);\n\t\t\t\t\tthis.silenceError = 'Network error: Failed to submit silence';\n\t\t\t\t} finally {\n\t\t\t\t\tthis.silenceSubmitting = false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tgetSilenceButtonText(alert) {\n\t\t\t\tif (!alert) return 'Unsilence';\n\t\t\t\tif (alert.status?.state === 'suppressed' || alert.status?.state === 'silenced') {\n\t\t\t\t\treturn 'Unsilence';\n\t\t\t\t}\n\t\t\t\treturn 'Silence';\n\t\t\t},\n\n\t\t\tasync copyAlertLink() {\n\t\t\t\tif (!this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\tthis.showNotification('error', 'Alert information not available');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Build the alert URL\n\t\t\t\tconst baseUrl = window.location.origin;\n\t\t\t\tconst alertUrl = `${baseUrl}/alert/${this.alertDetails.alert.fingerprint}`;\n\n\t\t\t\t// Copy to clipboard\n\t\t\t\tawait this.copyToClipboard(alertUrl);\n\t\t\t\tthis.showNotification('success', 'Alert link copied to clipboard');\n\t\t\t},\n\n\t\t\tasync copyGeneratorURL() {\n\t\t\t\tif (!this.alertDetails?.alert?.generatorURL) {\n\t\t\t\t\tthis.showNotification('error', 'Generator URL not available for this alert');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Copy generator URL to clipboard\n\t\t\t\tawait this.copyToClipboard(this.alertDetails.alert.generatorURL);\n\t\t\t\tthis.showNotification('success', 'Generator URL copied to clipboard');\n\t\t\t},\n\n\t\t\tcalculateDuration() {\n\t\t\t\tif (!this.alertDetails?.duration) {\n\t\t\t\t\treturn 'N/A';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Duration is in nanoseconds, convert to seconds\n\t\t\t\tconst durationSeconds = Math.floor(this.alertDetails.duration / 1000000000);\n\t\t\t\t\n\t\t\t\tif (durationSeconds < 60) {\n\t\t\t\t\treturn `${durationSeconds}s`;\n\t\t\t\t} else if (durationSeconds < 3600) {\n\t\t\t\t\tconst minutes = Math.floor(durationSeconds / 60);\n\t\t\t\t\tconst remainingSeconds = durationSeconds % 60;\n\t\t\t\t\treturn `${minutes}m ${remainingSeconds}s`;\n\t\t\t\t} else if (durationSeconds < 86400) {\n\t\t\t\t\tconst hours = Math.floor(durationSeconds / 3600);\n\t\t\t\t\tconst remainingMinutes = Math.floor((durationSeconds % 3600) / 60);\n\t\t\t\t\treturn `${hours}h ${remainingMinutes}m`;\n\t\t\t\t} else {\n\t\t\t\t\tconst days = Math.floor(durationSeconds / 86400);\n\t\t\t\t\tconst remainingHours = Math.floor((durationSeconds % 86400) / 3600);\n\t\t\t\t\treturn `${days}d ${remainingHours}h`;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync copyAlertAsIssue() {\n\t\t\t\tif (!this.alertDetails?.alert) {\n\t\t\t\t\tthis.showNotification('error', 'Alert information not available');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst alert = this.alertDetails.alert;\n\t\t\t\t\n\t\t\t\t// Build an issue template with alert information\n\t\t\t\tlet issueContent = `## Alert Details\\n\\n`;\n\t\t\t\tissueContent += `**Alert Name:** ${alert.alertName || 'Unknown'}\\n`;\n\t\t\t\tissueContent += `**Severity:** ${alert.severity || 'Unknown'}\\n`;\n\t\t\t\tissueContent += `**Status:** ${alert.status?.state || 'Unknown'}\\n`;\n\t\t\t\tissueContent += `**Instance:** ${alert.instance || 'N/A'}\\n`;\n\t\t\t\t\n\t\t\t\tif (alert.labels?.team) {\n\t\t\t\t\tissueContent += `**Team:** ${alert.labels.team}\\n`;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (alert.summary) {\n\t\t\t\t\tissueContent += `**Summary:** ${alert.summary}\\n`;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (alert.description) {\n\t\t\t\t\tissueContent += `**Description:** ${alert.description}\\n`;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (alert.generatorURL) {\n\t\t\t\t\tissueContent += `**Generator URL:** ${alert.generatorURL}\\n`;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (alert.startsAt) {\n\t\t\t\t\tconst startDate = new Date(alert.startsAt).toLocaleString();\n\t\t\t\t\tissueContent += `**Started At:** ${startDate}\\n`;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Add labels section\n\t\t\t\tif (alert.labels && Object.keys(alert.labels).length > 0) {\n\t\t\t\t\tissueContent += `\\n### Labels\\n`;\n\t\t\t\t\tObject.entries(alert.labels).forEach(([key, value]) => {\n\t\t\t\t\t\tif (key !== 'team') { // Skip team as it's already shown above\n\t\t\t\t\t\t\tissueContent += `- **${key}:** ${value}\\n`;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Add annotations section\n\t\t\t\tif (alert.annotations && Object.keys(alert.annotations).length > 0) {\n\t\t\t\t\tissueContent += `\\n### Annotations\\n`;\n\t\t\t\t\tObject.entries(alert.annotations).forEach(([key, value]) => {\n\t\t\t\t\t\tif (key !== 'summary' && key !== 'description') { // Skip as they're already shown above\n\t\t\t\t\t\t\tissueContent += `- **${key}:** ${value}\\n`;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Add alert link\n\t\t\t\tconst baseUrl = window.location.origin;\n\t\t\t\tconst alertUrl = `${baseUrl}/alert/${alert.fingerprint}`;\n\t\t\t\tissueContent += `\\n**Alert Link:** ${alertUrl}\\n`;\n\n\t\t\t\t// Copy to clipboard\n\t\t\t\tawait this.copyToClipboard(issueContent);\n\t\t\t\tthis.showNotification('success', 'Alert issue template copied to clipboard');\n\t\t\t},\n\n\t\t\tasync loadAlertDetails() {\n\t\t\t\tif (!this.alertId) {\n\t\t\t\t\tthis.error = 'No alert ID provided';\n\t\t\t\t\tthis.loading = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.loading = true;\n\t\t\t\tthis.error = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${this.alertId}`, {\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.alertDetails = result.data;\n\t\t\t\t\t\t// Load related alerts if we're on the related tab and have the loadRelatedAlerts function\n\t\t\t\t\t\tif (this.currentTab === 'related' && typeof this.loadRelatedAlerts === 'function') {\n\t\t\t\t\t\t\tthis.loadRelatedAlerts();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.error = result.error || 'Failed to load alert details';\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error loading alert details:', error);\n\t\t\t\t\tthis.error = 'Network error: Failed to load alert details';\n\t\t\t\t} finally {\n\t\t\t\t\tthis.loading = false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Related alerts functionality\n\t\t\tasync loadRelatedAlerts() {\n\t\t\t\tif (!this.alertDetails?.alert) return;\n\t\t\t\t\n\t\t\t\tthis.relatedLoading = true;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\t// Fetch all alerts from the correct endpoint\n\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/incremental', {\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success && result.data) {\n\t\t\t\t\t\tconst allAlerts = result.data;\n\t\t\t\t\t\tconst currentAlert = this.alertDetails.alert;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Debug: Log the structure of the first few alerts\n\t\t\t\t\t\tconsole.log('Sample alerts from API:', allAlerts.slice(0, 3));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Filter alerts based on selected criteria\n\t\t\t\t\t\tlet filteredAlerts = allAlerts.filter(alert => {\n\t\t\t\t\t\t\t// Validate alert has required properties\n\t\t\t\t\t\t\tif (!alert || !alert.fingerprint || typeof alert.fingerprint !== 'string') {\n\t\t\t\t\t\t\t\tconsole.warn('Alert missing or invalid fingerprint:', alert);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Exclude current alert\n\t\t\t\t\t\t\tif (alert.fingerprint === currentAlert.fingerprint) return false;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tswitch (this.relatedFilter) {\n\t\t\t\t\t\t\t\tcase 'same_source':\n\t\t\t\t\t\t\t\t\treturn alert.source === currentAlert.source;\n\t\t\t\t\t\t\t\tcase 'same_severity':\n\t\t\t\t\t\t\t\t\treturn alert.labels?.severity === currentAlert.labels?.severity || alert.severity === currentAlert.severity;\n\t\t\t\t\t\t\t\tcase 'same_labels':\n\t\t\t\t\t\t\t\t\t// Match on alertname (most common relation)\n\t\t\t\t\t\t\t\t\treturn alert.labels?.alertname === currentAlert.labels?.alertname;\n\t\t\t\t\t\t\t\tdefault: // 'all'\n\t\t\t\t\t\t\t\t\t// Match on alertname primarily, fallback to job or instance\n\t\t\t\t\t\t\t\t\treturn (alert.labels?.alertname === currentAlert.labels?.alertname) ||\n\t\t\t\t\t\t\t\t\t\t   (alert.labels?.job === currentAlert.labels?.job) ||\n\t\t\t\t\t\t\t\t\t\t   (alert.labels?.instance === currentAlert.labels?.instance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Apply search filter if provided\n\t\t\t\t\t\tif (this.relatedSearchQuery.trim()) {\n\t\t\t\t\t\t\tconst searchLower = this.relatedSearchQuery.toLowerCase();\n\t\t\t\t\t\t\tfilteredAlerts = filteredAlerts.filter(alert => {\n\t\t\t\t\t\t\t\treturn (alert.labels?.alertname || '').toLowerCase().includes(searchLower) ||\n\t\t\t\t\t\t\t\t\t   (alert.labels?.instance || '').toLowerCase().includes(searchLower) ||\n\t\t\t\t\t\t\t\t\t   (alert.annotations?.summary || '').toLowerCase().includes(searchLower);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Sort by most recent first\n\t\t\t\t\t\tfilteredAlerts.sort((a, b) => new Date(b.startsAt || 0) - new Date(a.startsAt || 0));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Deduplicate by fingerprint (keep first occurrence)\n\t\t\t\t\t\tconst seenFingerprints = new Set();\n\t\t\t\t\t\tfilteredAlerts = filteredAlerts.filter(alert => {\n\t\t\t\t\t\t\tif (seenFingerprints.has(alert.fingerprint)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tseenFingerprints.add(alert.fingerprint);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Store all filtered results\n\t\t\t\t\t\tthis.relatedAllAlerts = filteredAlerts;\n\t\t\t\t\t\tthis.relatedTotalResults = filteredAlerts.length;\n\t\t\t\t\t\tthis.relatedTotalPages = Math.ceil(filteredAlerts.length / this.relatedPageSize);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Apply pagination\n\t\t\t\t\t\tthis.updateRelatedAlertsPage();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.relatedAlerts = [];\n\t\t\t\t\t\tthis.relatedAllAlerts = [];\n\t\t\t\t\t\tthis.relatedTotalResults = 0;\n\t\t\t\t\t\tthis.relatedTotalPages = 0;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error loading related alerts:', error);\n\t\t\t\t\tthis.relatedAlerts = [];\n\t\t\t\t\tthis.relatedAllAlerts = [];\n\t\t\t\t\tthis.relatedTotalResults = 0;\n\t\t\t\t\tthis.relatedTotalPages = 0;\n\t\t\t\t\tthis.showNotification('error', 'Failed to load related alerts');\n\t\t\t\t} finally {\n\t\t\t\t\tthis.relatedLoading = false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Pagination methods for related alerts\n\t\t\tupdateRelatedAlertsPage() {\n\t\t\t\tconst startIndex = (this.relatedCurrentPage - 1) * this.relatedPageSize;\n\t\t\t\tconst endIndex = startIndex + this.relatedPageSize;\n\t\t\t\tthis.relatedAlerts = this.relatedAllAlerts.slice(startIndex, endIndex);\n\t\t\t},\n\n\t\t\tgoToRelatedPage(page) {\n\t\t\t\tif (page >= 1 && page <= this.relatedTotalPages) {\n\t\t\t\t\tthis.relatedCurrentPage = page;\n\t\t\t\t\tthis.updateRelatedAlertsPage();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tnextRelatedPage() {\n\t\t\t\tif (this.relatedCurrentPage < this.relatedTotalPages) {\n\t\t\t\t\tthis.relatedCurrentPage++;\n\t\t\t\t\tthis.updateRelatedAlertsPage();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tprevRelatedPage() {\n\t\t\t\tif (this.relatedCurrentPage > 1) {\n\t\t\t\t\tthis.relatedCurrentPage--;\n\t\t\t\t\tthis.updateRelatedAlertsPage();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tchangeRelatedPageSize(newSize) {\n\t\t\t\tthis.relatedPageSize = parseInt(newSize);\n\t\t\t\tthis.relatedCurrentPage = 1; // Reset to first page\n\t\t\t\tthis.relatedTotalPages = Math.ceil(this.relatedTotalResults / this.relatedPageSize);\n\t\t\t\tthis.updateRelatedAlertsPage();\n\t\t\t},\n\n\t\t\tsearchRelatedAlerts() {\n\t\t\t\t// Reset to first page when searching\n\t\t\t\tthis.relatedCurrentPage = 1;\n\t\t\t\t// Reload with search filter applied\n\t\t\t\tthis.loadRelatedAlerts();\n\t\t\t},\n\n\t\t\tgetRelatedPageNumbers() {\n\t\t\t\tconst pages = [];\n\t\t\t\tconst current = this.relatedCurrentPage;\n\t\t\t\tconst total = this.relatedTotalPages;\n\t\t\t\t\n\t\t\t\t// Show at most 5 page numbers\n\t\t\t\tlet start = Math.max(1, current - 2);\n\t\t\t\tlet end = Math.min(total, current + 2);\n\t\t\t\t\n\t\t\t\t// Adjust if we're near the beginning or end\n\t\t\t\tif (end - start < 4) {\n\t\t\t\t\tif (start === 1) {\n\t\t\t\t\t\tend = Math.min(total, start + 4);\n\t\t\t\t\t} else if (end === total) {\n\t\t\t\t\t\tstart = Math.max(1, end - 4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (let i = start; i <= end; i++) {\n\t\t\t\t\tpages.push(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn pages;\n\t\t\t},\n\n\t\t\tnavigateToAlert(fingerprint) {\n\t\t\t\t// Validate fingerprint\n\t\t\t\tif (!fingerprint || typeof fingerprint !== 'string') {\n\t\t\t\t\tconsole.error('Invalid fingerprint for navigation:', fingerprint);\n\t\t\t\t\tthis.showNotification('error', 'Invalid alert fingerprint');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Debug: Log the fingerprint being used\n\t\t\t\tconsole.log('Navigating to alert with fingerprint:', fingerprint);\n\t\t\t\t\n\t\t\t\t// Navigate to another alert, preserving query parameters\n\t\t\t\tconst currentQuery = window.location.search;\n\t\t\t\twindow.location.href = `/alert/${fingerprint}${currentQuery}`;\n\t\t\t},\n\n\n\t\t\t// Common unsilence action (for direct unsilence without modal)\n\t\t\tasync processUnsilenceAction(fingerprint) {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\taction: 'unsilence',\n\t\t\t\t\t\t\tfingerprints: [fingerprint],\n\t\t\t\t\t\t\tcomment: 'Unsilenced from alert details'\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.showNotification('success', 'Alert unsilenced successfully');\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Refresh data based on context\n\t\t\t\t\t\tif (typeof this.loadDashboardData === 'function') {\n\t\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t\t} else if (typeof this.loadAlertDetails === 'function') {\n\t\t\t\t\t\t\tthis.loadAlertDetails();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to unsilence alert: ' + result.error);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error unsilencing alert:', error);\n\t\t\t\t\tthis.showNotification('error', 'Failed to unsilence alert');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Common unacknowledge action\n\t\t\tasync processUnacknowledgeAction(fingerprint) {\n\t\t\t\ttry {\n\t\t\t\t\tconst request = {\n\t\t\t\t\t\talertFingerprints: [fingerprint],\n\t\t\t\t\t\taction: 'unacknowledge',\n\t\t\t\t\t\tcomment: 'Unacknowledged from alert details'\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.showNotification('success', 'Alert unacknowledged successfully');\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Refresh data based on context\n\t\t\t\t\t\tif (typeof this.loadDashboardData === 'function') {\n\t\t\t\t\t\t\tthis.loadDashboardData();\n\t\t\t\t\t\t} else if (typeof this.loadAlertDetails === 'function') {\n\t\t\t\t\t\t\tthis.loadAlertDetails();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to unacknowledge alert: ' + result.error);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error unacknowledging alert:', error);\n\t\t\t\t\tthis.showNotification('error', 'Failed to unacknowledge alert');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Duration parsing functions (copied from dashboard_actions.templ)\n\t\t\tparseDurationToSeconds(duration) {\n\t\t\t\tif (!duration) return 0;\n\t\t\t\t\n\t\t\t\tif (duration.match(/^\\d+[hd]$/)) {\n\t\t\t\t\tconst value = parseInt(duration.slice(0, -1));\n\t\t\t\t\tconst unit = duration.slice(-1);\n\t\t\t\t\t\n\t\t\t\t\tswitch (unit) {\n\t\t\t\t\t\tcase 'h':\n\t\t\t\t\t\t\treturn value * 3600;\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\treturn value * 86400;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn value * 3600;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this.parseComplexDurationToSeconds(duration);\n\t\t\t},\n\t\t\t\n\t\t\tparseComplexDurationToSeconds(duration) {\n\t\t\t\tif (!duration) return 0;\n\t\t\t\t\n\t\t\t\tlet totalSeconds = 0;\n\t\t\t\tconst units = {\n\t\t\t\t\t'ns': 0.000000001,\n\t\t\t\t\t'µs': 0.000001,\n\t\t\t\t\t'us': 0.000001,\n\t\t\t\t\t'ms': 0.001,\n\t\t\t\t\t's': 1,\n\t\t\t\t\t'm': 60,\n\t\t\t\t\t'h': 3600\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tconst regex = /(\\d+(?:\\.\\d+)?)(ns|µs|us|ms|s|m|h)/g;\n\t\t\t\tlet match;\n\t\t\t\t\n\t\t\t\twhile ((match = regex.exec(duration)) !== null) {\n\t\t\t\t\tconst value = parseFloat(match[1]);\n\t\t\t\t\tconst unit = match[2];\n\t\t\t\t\t\n\t\t\t\t\tif (units[unit]) {\n\t\t\t\t\t\ttotalSeconds += value * units[unit];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn Math.round(totalSeconds);\n\t\t\t},\n\t\t\t\n\t\t\tvalidateCustomDuration() {\n\t\t\t\tif (this.silenceDurationType !== 'custom' || !this.customSilenceDuration) {\n\t\t\t\t\tthis.customDurationError = '';\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst duration = this.customSilenceDuration.trim();\n\t\t\t\t\n\t\t\t\tif (!duration) {\n\t\t\t\t\tthis.customDurationError = 'Duration cannot be empty';\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst validFormat = /^(\\d+(?:\\.\\d+)?)(ns|µs|us|ms|s|m|h)(\\d+(?:\\.\\d+)?(ns|µs|us|ms|s|m|h))*$/;\n\t\t\t\tif (!validFormat.test(duration)) {\n\t\t\t\t\tthis.customDurationError = 'Invalid format. Use combinations like 1h30m, 2h15m30s';\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst totalSeconds = this.parseComplexDurationToSeconds(duration);\n\t\t\t\t\n\t\t\t\tif (totalSeconds <= 0) {\n\t\t\t\t\tthis.customDurationError = 'Duration must be positive';\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (totalSeconds < 1) {\n\t\t\t\t\tthis.customDurationError = 'Duration must be at least 1 second';\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst maxSeconds = 30 * 24 * 3600;\n\t\t\t\tif (totalSeconds > maxSeconds) {\n\t\t\t\t\tthis.customDurationError = 'Duration cannot exceed 30 days';\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.customDurationError = '';\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
