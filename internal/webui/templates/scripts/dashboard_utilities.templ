package scripts

templ DashboardUtilities() {
	<script>
		// Utility functions for dashboard
		window.dashboardUtilitiesMixin = {
			// URL and state management
			updateURL() {
				const params = new URLSearchParams();
				
				if (this.searchQuery) params.set('search', this.searchQuery);
				if (this.filters.alertmanagers.length > 0) params.set('alertmanagers', this.filters.alertmanagers.join(','));
				if (this.filters.severities.length > 0) params.set('severities', this.filters.severities.join(','));
				if (this.filters.statuses.length > 0) params.set('statuses', this.filters.statuses.join(','));
				if (this.filters.teams.length > 0) params.set('teams', this.filters.teams.join(','));
				if (this.displayMode !== 'classic') params.set('displayMode', this.displayMode);
				if (this.viewMode !== 'list') params.set('viewMode', this.viewMode);
				if (this.sortField !== 'duration') params.set('sortField', this.sortField);
				if (this.sortDirection !== 'asc') params.set('sortDirection', this.sortDirection);
				if (this.acknowledgmentFilter) params.set('acknowledged', this.acknowledgmentFilter);
				if (this.commentsFilter) params.set('hasComments', this.commentsFilter);
				
				const queryString = params.toString();
				const newURL = queryString ? `${window.location.pathname}?${queryString}` : window.location.pathname;
				
				// Only update if URL has changed to avoid unnecessary history entries
				if (window.location.href !== window.location.origin + newURL) {
					window.history.replaceState({}, '', newURL);
				}
			},

			loadFiltersFromURL() {
				const params = new URLSearchParams(window.location.search);
				
				this.searchQuery = params.get('search') || '';
				this.filters.alertmanagers = params.get('alertmanagers') ? params.get('alertmanagers').split(',') : [];
				this.filters.severities = params.get('severities') ? params.get('severities').split(',') : [];
				this.filters.statuses = params.get('statuses') ? params.get('statuses').split(',') : [];
				this.filters.teams = params.get('teams') ? params.get('teams').split(',') : [];
				this.displayMode = params.get('displayMode') || 'classic';
				this.viewMode = params.get('viewMode') || 'list';
				this.sortField = params.get('sortField') || 'duration';
				this.sortDirection = params.get('sortDirection') || 'asc';
				this.acknowledgmentFilter = params.get('acknowledged') || null;
				this.commentsFilter = params.get('hasComments') || null;
			},

			checkAlertFromURL() {
				// Check if URL contains an alert ID and open modal
				const pathParts = window.location.pathname.split('/');
				if (pathParts.length >= 4 && pathParts[1] === 'dashboard' && pathParts[2] === 'alert') {
					const alertId = pathParts[3];
					if (alertId) {
						// Wait a bit for initial data to load, then show alert details
						setTimeout(() => {
							this.showAlertDetails(alertId);
						}, 500);
					}
				}
			},

			// Clipboard operations
			copyToClipboard(text) {
				if (navigator.clipboard) {
					navigator.clipboard.writeText(text).then(() => {
						this.showNotification('success', 'Copied to clipboard');
					}).catch(() => {
						this.showNotification('error', 'Failed to copy to clipboard');
					});
				} else {
					// Fallback for older browsers
					const textArea = document.createElement('textarea');
					textArea.value = text;
					document.body.appendChild(textArea);
					textArea.select();
					try {
						document.execCommand('copy');
						this.showNotification('success', 'Copied to clipboard');
					} catch (err) {
						this.showNotification('error', 'Failed to copy to clipboard');
					}
					document.body.removeChild(textArea);
				}
			},

			// Filtering utilities
			applyFilters() {
				// Debounced filter application happens automatically via data loading
				this.loadDashboardData();
			},

			clearAllFilters() {
				this.searchQuery = '';
				this.filters = {
					alertmanagers: [],
					severities: [],
					statuses: [],
					teams: []
				};
				this.acknowledgmentFilter = null;
				this.commentsFilter = null;
				this.loadDashboardData();
			},

			clearFilter(filterType) {
				this.filters[filterType] = [];
				this.applyFilters();
			},

			removeFilter(filterType, value) {
				const index = this.filters[filterType].indexOf(value);
				if (index > -1) {
					this.filters[filterType].splice(index, 1);
					this.applyFilters();
				}
			},

			hasActiveFilters() {
				return this.searchQuery.length > 0 ||
					   this.filters.alertmanagers.length > 0 ||
					   this.filters.severities.length > 0 ||
					   this.filters.statuses.length > 0 ||
					   this.filters.teams.length > 0 ||
					   this.acknowledgmentFilter !== null ||
					   this.commentsFilter !== null;
			},

			// Selection management
			toggleAlert(fingerprint) {
				const index = this.selectedAlerts.indexOf(fingerprint);
				if (index > -1) {
					this.selectedAlerts.splice(index, 1);
				} else {
					this.selectedAlerts.push(fingerprint);
				}
			},

			toggleGroup(groupName) {
				const index = this.selectedGroups.indexOf(groupName);
				if (index > -1) {
					this.selectedGroups.splice(index, 1);
				} else {
					this.selectedGroups.push(groupName);
				}
			},

			selectAll() {
				if (this.viewMode === 'list') {
					this.selectedAlerts = this.alerts.map(a => a.fingerprint);
				} else {
					this.selectedGroups = this.groups.map(g => g.groupName);
				}
			},

			clearSelection() {
				this.selectedAlerts = [];
				this.selectedGroups = [];
			},

			toggleSelectAll(event) {
				if (event.target.checked) {
					this.selectAll();
				} else {
					this.clearSelection();
				}
			},

			// Group expansion
			toggleGroupExpanded(groupName) {
				const index = this.expandedGroups.indexOf(groupName);
				if (index > -1) {
					this.expandedGroups.splice(index, 1);
				} else {
					this.expandedGroups.push(groupName);
				}
			},

			// Sorting
			sortBy(field) {
				if (this.sortField === field) {
					this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
				} else {
					this.sortField = field;
					this.sortDirection = 'asc';
				}
				this.loadDashboardData();
			},

			// Settings management
			loadSettings() {
				const saved = localStorage.getItem('dashboardSettings');
				if (saved) {
					try {
						const settings = JSON.parse(saved);
						this.settings = { ...this.settings, ...settings };
					} catch (e) {
						console.warn('Failed to parse saved settings:', e);
					}
				}
				
				this.applyTheme();
				this.applyNotificationSettings();
			},

			async saveSettings() {
				try {
					// Save settings to backend
					const settingsResponse = await fetch('/api/v1/dashboard/settings', {
						method: 'POST',
						credentials: 'include',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify(this.settings)
					});

					const settingsResult = await settingsResponse.json();
					
					if (!settingsResult.success) {
						this.showNotification('error', 'Failed to save settings: ' + settingsResult.error);
						return;
					}

					// Save to localStorage as well
					localStorage.setItem('dashboardSettings', JSON.stringify(this.settings));

					// Apply theme change
					this.applyTheme();

					// Apply notification queue settings
					this.applyNotificationSettings();

					this.showNotification('success', 'Settings saved');
					this.showSettings = false;
					
					// Apply theme change
					this.applyTheme();
					
					// Restart auto-refresh with new interval
					this.startAutoRefresh();
				} catch (error) {
					console.error('Error saving settings:', error);
					this.showNotification('error', 'Failed to save settings');
				}
			},

			applyTheme() {
				const isDark = this.settings.theme === 'dark';
				document.documentElement.classList.toggle('dark', isDark);
				
				// Update meta theme-color for mobile browsers
				const metaThemeColor = document.querySelector('meta[name="theme-color"]');
				if (metaThemeColor) {
					metaThemeColor.setAttribute('content', isDark ? '#1f2937' : '#ffffff');
				}
			},

			applyNotificationSettings() {
				// Update notification delay from settings
				this.notificationDelay = this.settings.notificationDelay || 1500;
				
				// Update max concurrent notifications from settings  
				this.maxConcurrentNotifications = this.settings.maxConcurrentNotifications || 3;
				
				// Log the updated settings for debugging
				console.log('Notification settings applied:', {
					notificationDelay: this.notificationDelay,
					maxConcurrentNotifications: this.maxConcurrentNotifications,
					notificationBatching: this.settings.notificationBatching,
					prioritizedNotifications: this.settings.prioritizedNotifications
				});
			},

			// Current user management
			async loadCurrentUser() {
				try {
					const response = await fetch('/api/v1/auth/profile', {
						credentials: 'include'
					});
					if (response.ok) {
						const result = await response.json();
						if (result.success && result.data) {
							this.currentUser = {
								id: result.data.id,
								username: result.data.username,
								email: result.data.email
							};
						}
					}
				} catch (error) {
					console.warn('Failed to load current user:', error);
				}
			},

			getCurrentUser() {
				return this.currentUser;
			},

			canDeleteComment(comment) {
				const currentUser = this.getCurrentUser();
				return currentUser && comment && (
					currentUser.id === comment.userId || 
					currentUser.username === comment.username
				);
			},

			// Column resizing utilities
			loadColumnWidths() {
				const saved = localStorage.getItem('dashboardColumnWidths');
				if (saved) {
					try {
						const widths = JSON.parse(saved);
						this.columnWidths = { ...this.columnWidths, ...widths };
					} catch (e) {
						console.warn('Failed to parse saved column widths:', e);
					}
				}
			},

			saveColumnWidths() {
				localStorage.setItem('dashboardColumnWidths', JSON.stringify(this.columnWidths));
			},

			startResize(event, column) {
				this.isResizing = true;
				this.currentColumn = column;
				this.startX = event.clientX;
				this.startWidth = this.columnWidths[column];
				
				event.preventDefault();
				document.body.style.cursor = 'col-resize';
				document.body.style.userSelect = 'none';
			},

			handleMouseMove(event) {
				if (!this.isResizing || !this.currentColumn) return;
				
				const diff = event.clientX - this.startX;
				const newWidth = Math.max(50, this.startWidth + diff); // Minimum width of 50px
				this.columnWidths[this.currentColumn] = newWidth;
			},

			handleMouseUp() {
				if (this.isResizing) {
					this.isResizing = false;
					this.currentColumn = null;
					this.saveColumnWidths();
					
					document.body.style.cursor = '';
					document.body.style.userSelect = '';
				}
			},

			resetColumnWidths() {
				// Reset to default widths
				this.columnWidths = {
					alertName: 300,
					acknowledge: 75,
					instance: 350,
					severity: 150,
					status: 150,
					comments: 130,
					team: 200,
					summary: 400,
					duration: 150,
					source: 180
				};
				
				// Clear saved widths
				localStorage.removeItem('dashboardColumnWidths');
			},

			// Format utilities
			formatDuration(seconds) {
				if (seconds < 60) {
					return `${Math.floor(seconds)}s`;
				} else if (seconds < 3600) {
					const minutes = Math.floor(seconds / 60);
					const remainingSeconds = Math.floor(seconds % 60);
					return `${minutes}m ${remainingSeconds}s`;
				} else {
					const hours = Math.floor(seconds / 3600);
					const remainingMinutes = Math.floor((seconds % 3600) / 60);
					return `${hours}h ${remainingMinutes}m`;
				}
			},

			formatTimestamp(timestamp) {
				return new Date(timestamp).toLocaleString();
			},

			// Alert color utilities
			getAlertColor(alert, colorType = 'backgroundColor') {
				const fingerprint = alert.fingerprint;
				if (this.alertColors[fingerprint]) {
					const colorResult = this.alertColors[fingerprint];
					switch (colorType) {
						case 'backgroundColor': return colorResult.backgroundColor;
						case 'textColor': return colorResult.textColor;
						case 'borderColor': return colorResult.borderColor;
						case 'badgeColor': return colorResult.badgeColor;
						default: return colorResult.backgroundColor;
					}
				}
				
				// Fallback to default severity colors
				return this.getDefaultSeverityColor(alert, colorType);
			},

			// Get default severity color (fallback)
			getDefaultSeverityColor(alert, colorType = 'backgroundColor') {
				const severity = alert.severity || 'default';
				const colorMap = {
					critical: {
						backgroundColor: '#fee2e2', // red-100
						textColor: '#991b1b',       // red-800
						borderColor: '#dc2626',     // red-600
						badgeColor: '#dc2626'       // red-600
					},
					'critical-daytime': {
						backgroundColor: '#ffe4e6', // rose-100
						textColor: '#9f1239',       // rose-800
						borderColor: '#be123c',     // rose-700
						badgeColor: '#be123c'       // rose-700
					},
					warning: {
						backgroundColor: '#fef3c7', // amber-100
						textColor: '#92400e',       // amber-800
						borderColor: '#d97706',     // amber-600
						badgeColor: '#d97706'       // amber-600
					},
					info: {
						backgroundColor: '#dbeafe', // blue-100
						textColor: '#1e40af',       // blue-800
						borderColor: '#2563eb',     // blue-600
						badgeColor: '#2563eb'       // blue-600
					},
					default: {
						backgroundColor: '#f3f4f6', // gray-100
						textColor: '#374151',       // gray-700
						borderColor: '#6b7280',     // gray-500
						badgeColor: '#6b7280'       // gray-500
					}
				};
				
				const colors = colorMap[severity] || colorMap.default;
				return colors[colorType] || colors.backgroundColor;
			},

			getAlertBgColor(alert) {
				if (!alert || !alert.fingerprint) return '';
				
				const colorData = this.alertColors[alert.fingerprint];
				if (!colorData || !colorData.bgColor) return '';
				
				return `background-color: ${colorData.bgColor}; color: ${colorData.textColor || '#000000'};`;
			},

			getAlertTextColor(alert) {
				if (!alert || !alert.fingerprint) return '';
				
				const colorData = this.alertColors[alert.fingerprint];
				if (!colorData || !colorData.textColor) return '';
				
				return colorData.textColor;
			}
		};
	</script>
}