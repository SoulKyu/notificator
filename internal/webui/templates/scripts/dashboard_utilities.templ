package scripts

templ DashboardUtilities() {
	<script>
		window.dashboardUtilitiesMixin = {
			updateURL() {
				const params = new URLSearchParams();
				
				if (this.searchQuery) params.set('search', this.searchQuery);
				if (this.filters.alertmanagers.length > 0) params.set('alertmanagers', this.filters.alertmanagers.join(','));
				if (this.filters.severities.length > 0) params.set('severities', this.filters.severities.join(','));
				if (this.filters.statuses.length > 0) params.set('statuses', this.filters.statuses.join(','));
				if (this.filters.teams.length > 0) params.set('teams', this.filters.teams.join(','));
				if (this.displayMode !== 'classic') params.set('displayMode', this.displayMode);
				if (this.viewMode !== 'list') params.set('viewMode', this.viewMode);
				if (this.sortField !== 'duration') params.set('sortField', this.sortField);
				if (this.sortDirection !== 'asc') params.set('sortDirection', this.sortDirection);
				if (this.acknowledgmentFilter) params.set('acknowledged', this.acknowledgmentFilter);
				if (this.commentsFilter) params.set('hasComments', this.commentsFilter);
				
				const queryString = params.toString();
				const newURL = queryString ? `${window.location.pathname}?${queryString}` : window.location.pathname;
				
				if (window.location.href !== window.location.origin + newURL) {
					window.history.replaceState({}, '', newURL);
				}
			},

			loadFiltersFromURL() {
				const params = new URLSearchParams(window.location.search);
				
				this.searchQuery = params.get('search') || '';
				this.filters.alertmanagers = params.get('alertmanagers') ? params.get('alertmanagers').split(',') : [];
				this.filters.severities = params.get('severities') ? params.get('severities').split(',') : [];
				this.filters.statuses = params.get('statuses') ? params.get('statuses').split(',') : [];
				this.filters.teams = params.get('teams') ? params.get('teams').split(',') : [];
				this.displayMode = params.get('displayMode') || 'classic';
				this.viewMode = params.get('viewMode') || 'list';
				this.sortField = params.get('sortField') || 'duration';
				this.sortDirection = params.get('sortDirection') || 'asc';
				this.acknowledgmentFilter = params.get('acknowledged') || null;
				this.commentsFilter = params.get('hasComments') || null;
			},

			checkAlertFromURL() {
				// Check if URL contains an alert ID and open modal
				const pathParts = window.location.pathname.split('/');
				if (pathParts.length >= 4 && pathParts[1] === 'dashboard' && pathParts[2] === 'alert') {
					const alertId = pathParts[3];
					if (alertId) {
						// Wait a bit for initial data to load, then show alert details
						setTimeout(() => {
							this.showAlertDetails(alertId);
						}, 500);
					}
				}
			},

			copyToClipboard(text) {
				if (navigator.clipboard) {
					navigator.clipboard.writeText(text).then(() => {
						this.showNotification('success', 'Copied to clipboard');
					}).catch(() => {
						this.showNotification('error', 'Failed to copy to clipboard');
					});
				} else {
					const textArea = document.createElement('textarea');
					textArea.value = text;
					document.body.appendChild(textArea);
					textArea.select();
					try {
						document.execCommand('copy');
						this.showNotification('success', 'Copied to clipboard');
					} catch (err) {
						this.showNotification('error', 'Failed to copy to clipboard');
					}
					document.body.removeChild(textArea);
				}
			},

			// Filtering utilities
			applyFilters() {
				// Debounced filter application happens automatically via data loading
				this.loadDashboardData();
			},

			clearAllFilters() {
				this.searchQuery = '';
				this.filters = {
					alertmanagers: [],
					severities: [],
					statuses: [],
					teams: []
				};
				this.acknowledgmentFilter = null;
				this.commentsFilter = null;
				this.loadDashboardData();
			},

			clearFilter(filterType) {
				this.filters[filterType] = [];
				this.applyFilters();
			},

			removeFilter(filterType, value) {
				const index = this.filters[filterType].indexOf(value);
				if (index > -1) {
					this.filters[filterType].splice(index, 1);
					this.applyFilters();
				}
			},

			hasActiveFilters() {
				return this.searchQuery.length > 0 ||
					   this.filters.alertmanagers.length > 0 ||
					   this.filters.severities.length > 0 ||
					   this.filters.statuses.length > 0 ||
					   this.filters.teams.length > 0 ||
					   this.acknowledgmentFilter !== null ||
					   this.commentsFilter !== null;
			},

			// Selection management
			toggleAlert(fingerprint) {
				const index = this.selectedAlerts.indexOf(fingerprint);
				if (index > -1) {
					this.selectedAlerts.splice(index, 1);
				} else {
					this.selectedAlerts.push(fingerprint);
				}
			},

			toggleGroup(groupName) {
				const index = this.selectedGroups.indexOf(groupName);
				if (index > -1) {
					this.selectedGroups.splice(index, 1);
				} else {
					this.selectedGroups.push(groupName);
				}
			},

			selectAll() {
				if (this.viewMode === 'list') {
					this.selectedAlerts = this.alerts.map(a => a.fingerprint);
				} else {
					this.selectedGroups = this.groups.map(g => g.groupName);
				}
			},

			clearSelection() {
				this.selectedAlerts = [];
				this.selectedGroups = [];
			},

			toggleSelectAll(event) {
				if (event.target.checked) {
					this.selectAll();
				} else {
					this.clearSelection();
				}
			},

			// Group expansion
			toggleGroupExpanded(groupName) {
				const index = this.expandedGroups.indexOf(groupName);
				if (index > -1) {
					this.expandedGroups.splice(index, 1);
				} else {
					this.expandedGroups.push(groupName);
				}
			},

			// Sorting
			sortBy(field) {
				if (this.sortField === field) {
					this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
				} else {
					this.sortField = field;
					this.sortDirection = 'asc';
				}
				this.loadDashboardData();
			},

			// Settings management
			loadSettings() {
				const saved = localStorage.getItem('dashboardSettings');
				if (saved) {
					try {
						const settings = JSON.parse(saved);
						this.settings = { ...this.settings, ...settings };
					} catch (e) {
						console.warn('Failed to parse saved settings:', e);
					}
				}
				
				this.applyTheme();
				this.applyNotificationSettings();
			},

			async saveSettings() {
				try {
					// Get the settings modal instance to check active tab
					const settingsModal = window.currentSettingsModal;
					
					// Check which tab is active and save appropriate settings
					if (settingsModal && settingsModal.activeTab === 'colors') {
						// Save color preferences
						const success = await settingsModal.saveColorPreferences();
						if (success) {
							this.showNotification('success', 'Color preferences saved');
							this.showSettings = false;
						}
						return;
					} else if (settingsModal && settingsModal.activeTab === 'notifications') {
						// Save notification preferences
						await settingsModal.saveNotificationPreferences();
						this.showSettings = false;
						return;
					}
					
					// Otherwise, save general settings
					const settingsResponse = await fetch('/api/v1/dashboard/settings', {
						method: 'POST',
						credentials: 'include',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify(this.settings)
					});

					const settingsResult = await settingsResponse.json();
					
					if (!settingsResult.success) {
						this.showNotification('error', 'Failed to save settings: ' + settingsResult.error);
						return;
					}

					// Save to localStorage as well
					localStorage.setItem('dashboardSettings', JSON.stringify(this.settings));

					// Apply theme change
					this.applyTheme();

					// Apply notification queue settings
					this.applyNotificationSettings();

					this.showNotification('success', 'Settings saved');
					this.showSettings = false;
					
					// Apply theme change
					this.applyTheme();
					
					// Restart auto-refresh with new interval
					this.startAutoRefresh();
				} catch (error) {
					console.error('Error saving settings:', error);
					this.showNotification('error', 'Failed to save settings');
				}
			},

			applyTheme() {
				const isDark = this.settings.theme === 'dark';
				document.documentElement.classList.toggle('dark', isDark);
				
				// Update meta theme-color for mobile browsers
				const metaThemeColor = document.querySelector('meta[name="theme-color"]');
				if (metaThemeColor) {
					metaThemeColor.setAttribute('content', isDark ? '#1f2937' : '#ffffff');
				}
			},

			applyNotificationSettings() {
				// Update notification delay from settings
				this.notificationDelay = this.settings.notificationDelay || 1500;
				
				// Update max concurrent notifications from settings  
				this.maxConcurrentNotifications = this.settings.maxConcurrentNotifications || 3;
				
				// Log the updated settings for debugging
				console.log('Notification settings applied:', {
					notificationDelay: this.notificationDelay,
					maxConcurrentNotifications: this.maxConcurrentNotifications,
					notificationBatching: this.settings.notificationBatching,
					prioritizedNotifications: this.settings.prioritizedNotifications
				});
			},

			async testNotification() {
				// Check if browser notifications are supported
				if (!('Notification' in window)) {
					this.showNotification('error', 'Browser notifications are not supported');
					return;
				}

				// Check current permission status
				if (Notification.permission === 'denied') {
					this.showNotification('error', 'Notifications are blocked. Please enable them in your browser settings.');
					return;
				}

				// Request permission if not granted
				if (Notification.permission !== 'granted') {
					try {
						const permission = await Notification.requestPermission();
						if (permission !== 'granted') {
							this.showNotification('warning', 'Notification permission denied. Please enable notifications to receive alerts.');
							return;
						}
					} catch (error) {
						this.showNotification('error', 'Failed to request notification permission');
						return;
					}
				}

				// Create test alert object
				const testAlert = {
					fingerprint: 'test-notification',
					alertname: 'Test Notification',
					summary: 'This is a test notification from the Notificator dashboard',
					severity: 'info',
					status: 'firing',
					labels: {
						alertname: 'Test Notification',
						severity: 'info'
					},
					annotations: {
						summary: 'This is a test notification from the Notificator dashboard'
					}
				};

				// Send both in-app and browser notifications
				this.showInAppNotification(testAlert, 'Test notification sent successfully!');
				
				// Send browser notification with heroicon
				try {
					const notification = new Notification('Test Notification', {
						body: 'This is a test notification from the Notificator dashboard',
						icon: '/static/images/info-icon.png',
						tag: 'test-notification',
						requireInteraction: false
					});

					// Auto-close after 5 seconds
					setTimeout(() => {
						notification.close();
					}, 5000);

					this.showNotification('success', 'Test notification sent! Check your system notifications.');
				} catch (error) {
					console.error('Failed to send browser notification:', error);
					this.showNotification('warning', 'In-app notification sent, but browser notification failed');
				}
			},

			// Current user management
			async loadCurrentUser() {
				try {
					const response = await fetch('/api/v1/auth/profile', {
						credentials: 'include'
					});
					if (response.ok) {
						const result = await response.json();
						if (result.success && result.data) {
							this.currentUser = {
								id: result.data.id,
								username: result.data.username,
								email: result.data.email
							};
						}
					}
				} catch (error) {
					console.warn('Failed to load current user:', error);
				}
			},

			getCurrentUser() {
				return this.currentUser;
			},

			getUserInitials() {
				const currentUser = this.getCurrentUser();
				if (!currentUser || !currentUser.username) {
					return 'U'; // Fallback to 'U' if no user data
				}
				
				const username = currentUser.username.trim();
				if (username.length === 0) {
					return 'U';
				} else if (username.length === 1) {
					return username.toUpperCase();
				} else {
					// Get first 2 characters and convert to uppercase
					return username.substring(0, 2).toUpperCase();
				}
			},

			// Alias for backward compatibility
			getInitials(username) {
				if (!username) {
					// If no username provided, use current user
					return this.getUserInitials();
				}
				
				// Direct username provided
				const cleanUsername = username.trim();
				if (cleanUsername.length === 0) {
					return 'U';
				} else if (cleanUsername.length === 1) {
					return cleanUsername.toUpperCase();
				} else {
					// Get first 2 characters and convert to uppercase
					return cleanUsername.substring(0, 2).toUpperCase();
				}
			},

			canDeleteComment(comment) {
				const currentUser = this.getCurrentUser();
				return currentUser && comment && (
					currentUser.id === comment.userId || 
					currentUser.username === comment.username
				);
			},

			// Column resizing utilities
			loadColumnWidths() {
				const saved = localStorage.getItem('dashboardColumnWidths');
				if (saved) {
					try {
						const widths = JSON.parse(saved);
						this.columnWidths = { ...this.columnWidths, ...widths };
					} catch (e) {
						console.warn('Failed to parse saved column widths:', e);
					}
				}
			},

			saveColumnWidths() {
				localStorage.setItem('dashboardColumnWidths', JSON.stringify(this.columnWidths));
			},

			startResize(event, column) {
				this.isResizing = true;
				this.currentColumn = column;
				this.startX = event.clientX;
				this.startWidth = this.columnWidths[column];
				
				event.preventDefault();
				document.body.style.cursor = 'col-resize';
				document.body.style.userSelect = 'none';
			},

			handleMouseMove(event) {
				if (!this.isResizing || !this.currentColumn) return;
				
				const diff = event.clientX - this.startX;
				const newWidth = Math.max(50, this.startWidth + diff); // Minimum width of 50px
				this.columnWidths[this.currentColumn] = newWidth;
			},

			handleMouseUp() {
				if (this.isResizing) {
					this.isResizing = false;
					this.currentColumn = null;
					this.saveColumnWidths();
					
					document.body.style.cursor = '';
					document.body.style.userSelect = '';
				}
			},

			resetColumnWidths() {
				// Reset to default widths
				this.columnWidths = {
					alertName: 300,
					acknowledge: 75,
					instance: 350,
					severity: 150,
					status: 150,
					comments: 130,
					team: 200,
					summary: 400,
					duration: 150,
					source: 180
				};
				
				// Clear saved widths
				localStorage.removeItem('dashboardColumnWidths');
			},

			// Format utilities
			formatDuration(seconds) {
				if (seconds < 60) {
					return `${Math.floor(seconds)}s`;
				} else if (seconds < 3600) {
					const minutes = Math.floor(seconds / 60);
					const remainingSeconds = Math.floor(seconds % 60);
					return `${minutes}m ${remainingSeconds}s`;
				} else {
					const hours = Math.floor(seconds / 3600);
					const remainingMinutes = Math.floor((seconds % 3600) / 60);
					return `${hours}h ${remainingMinutes}m`;
				}
			},

			formatTimestamp(timestamp) {
				return new Date(timestamp).toLocaleString();
			},

			// Alert color utilities
			getAlertColor(alert, colorType = 'backgroundColor') {
				const fingerprint = alert.fingerprint;
				if (this.alertColors[fingerprint]) {
					const colorResult = this.alertColors[fingerprint];
					switch (colorType) {
						case 'backgroundColor': return colorResult.backgroundColor;
						case 'textColor': return colorResult.textColor;
						case 'borderColor': return colorResult.borderColor;
						case 'badgeColor': return colorResult.badgeColor;
						default: return colorResult.backgroundColor;
					}
				}
				
				// Fallback to default severity colors
				return this.getDefaultSeverityColor(alert, colorType);
			},

			// Get default severity color (fallback)
			getDefaultSeverityColor(alert, colorType = 'backgroundColor') {
				const severity = alert.severity || 'default';
				const colorMap = {
					critical: {
						backgroundColor: '#fee2e2', // red-100
						textColor: '#991b1b',       // red-800
						borderColor: '#dc2626',     // red-600
						badgeColor: '#dc2626'       // red-600
					},
					'critical-daytime': {
						backgroundColor: '#ffe4e6', // rose-100
						textColor: '#9f1239',       // rose-800
						borderColor: '#be123c',     // rose-700
						badgeColor: '#be123c'       // rose-700
					},
					warning: {
						backgroundColor: '#fef3c7', // amber-100
						textColor: '#92400e',       // amber-800
						borderColor: '#d97706',     // amber-600
						badgeColor: '#d97706'       // amber-600
					},
					info: {
						backgroundColor: '#dbeafe', // blue-100
						textColor: '#1e40af',       // blue-800
						borderColor: '#2563eb',     // blue-600
						badgeColor: '#2563eb'       // blue-600
					},
					default: {
						backgroundColor: '#f3f4f6', // gray-100
						textColor: '#374151',       // gray-700
						borderColor: '#6b7280',     // gray-500
						badgeColor: '#6b7280'       // gray-500
					}
				};
				
				const colors = colorMap[severity] || colorMap.default;
				return colors[colorType] || colors.backgroundColor;
			},

			getAlertBgColor(alert) {
				if (!alert || !alert.fingerprint) return '';
				
				const colorData = this.alertColors[alert.fingerprint];
				if (!colorData || !colorData.bgColor) return '';
				
				return `background-color: ${colorData.bgColor}; color: ${colorData.textColor || '#000000'};`;
			},

			getAlertTextColor(alert) {
				if (!alert || !alert.fingerprint) return '';
				
				const colorData = this.alertColors[alert.fingerprint];
				if (!colorData || !colorData.textColor) return '';
				
				return colorData.textColor;
			},

			// Quick Preview functionality
			previewTimeout: null,
			currentPreview: null,

			showPreview(event, alert, delay = 300) {
				// Clear any existing preview or timeout
				this.hidePreview();
				
				// Set timeout to show preview after delay
				this.previewTimeout = setTimeout(() => {
					this.createPreview(event, alert);
				}, delay);
			},

			hidePreview() {
				// Clear timeout if it exists
				if (this.previewTimeout) {
					clearTimeout(this.previewTimeout);
					this.previewTimeout = null;
				}
				
				// Remove existing preview
				if (this.currentPreview) {
					this.currentPreview.remove();
					this.currentPreview = null;
				}
			},

			createPreview(event, alert) {
				// Create preview tooltip
				const preview = document.createElement('div');
				preview.className = 'fixed z-50 bg-white dark:bg-dark-bg-secondary border border-gray-200 dark:border-dark-border-DEFAULT rounded-lg shadow-xl p-4 max-w-sm';
				preview.style.pointerEvents = 'none';
				
				// Build content
				const severity = alert.severity || 'unknown';
				const status = alert.status?.state || 'unknown';
				const duration = this.calculateAlertDuration(alert);
				
				let previewContent = '<div class="space-y-3"><div>';
				previewContent += '<h4 class="font-semibold text-gray-900 dark:text-white text-sm line-clamp-2">' + (alert.alertName || 'Unknown Alert') + '</h4>';
				previewContent += '</div><div class="flex items-center space-x-2">';
				previewContent += '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ' + this.getSeverityClasses(severity) + '">';
				previewContent += severity.toUpperCase() + '</span>';
				previewContent += '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ' + this.getStatusClasses(status) + '">';
				previewContent += status.toUpperCase() + '</span>';
				if (alert.isAcknowledged) {
					previewContent += '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-200">ACK</span>';
				}
				previewContent += '</div>';
				if (alert.summary) {
					previewContent += '<p class="text-xs text-gray-600 dark:text-gray-400 line-clamp-3">' + alert.summary + '</p>';
				}
				previewContent += '<div class="text-xs text-gray-500 dark:text-gray-400">';
				previewContent += '<div>Duration: ' + duration + '</div>';
				if (alert.instance) {
					previewContent += '<div>Instance: ' + alert.instance + '</div>';
				}
				if (alert.source) {
					previewContent += '<div>Source: ' + alert.source + '</div>';
				}
				previewContent += '</div></div>';
				
				preview.innerHTML = previewContent;
				
				// Position the preview
				document.body.appendChild(preview);
				
				// Calculate position
				const rect = event.target.closest('tr').getBoundingClientRect();
				const previewRect = preview.getBoundingClientRect();
				
				let left = rect.left + rect.width + 10;
				let top = rect.top + window.scrollY;
				
				// Adjust if it would go off screen
				if (left + previewRect.width > window.innerWidth) {
					left = rect.left - previewRect.width - 10;
				}
				
				if (top + previewRect.height > window.innerHeight + window.scrollY) {
					top = window.innerHeight + window.scrollY - previewRect.height - 10;
				}
				
				preview.style.left = Math.max(10, left) + 'px';
				preview.style.top = Math.max(10, top) + 'px';
				
				this.currentPreview = preview;
			},

			calculateAlertDuration(alert) {
				if (!alert.startsAt) return 'N/A';
				
				const start = new Date(alert.startsAt);
				const end = alert.endsAt ? new Date(alert.endsAt) : new Date();
				const diffMs = end - start;
				
				const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));
				const hours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
				const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
				
				if (days > 0) return `${days}d ${hours}h`;
				if (hours > 0) return `${hours}h ${minutes}m`;
				return `${minutes}m`;
			},

			getSeverityClasses(severity) {
				switch (severity.toLowerCase()) {
					case 'critical': return 'bg-red-100 text-red-800 dark:bg-red-900/50 dark:text-red-200';
					case 'warning': return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-200';
					case 'info': return 'bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-200';
					default: return 'bg-gray-100 text-gray-800 dark:bg-gray-900/50 dark:text-gray-200';
				}
			},

			getStatusClasses(status) {
				switch (status.toLowerCase()) {
					case 'firing': return 'bg-red-100 text-red-800 dark:bg-red-900/50 dark:text-red-200';
					case 'resolved': return 'bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-200';
					case 'suppressed': return 'bg-purple-100 text-purple-800 dark:bg-purple-900/50 dark:text-purple-200';
					default: return 'bg-gray-100 text-gray-800 dark:bg-gray-900/50 dark:text-gray-200';
				}
			},
		};

		// Global function to handle logout response
		window.handleLogoutResponse = function(event) {
			try {
				const xhr = event.detail.xhr;
				
				if (xhr.status === 200) {
					// Successful logout
					const response = JSON.parse(xhr.responseText);
					if (response.success) {
						// Clear any cached user data
						localStorage.removeItem('dashboardSettings');
						localStorage.removeItem('dashboardColumnWidths');
						
						// Show success message briefly before redirect
						if (window.dashboardInstance && window.dashboardInstance.showNotification) {
							window.dashboardInstance.showNotification('success', 'Logged out successfully');
						}
						
						// Redirect to login page after a brief delay
						setTimeout(() => {
							window.location.href = '/login';
						}, 500);
					} else {
						// Logout failed
						if (window.dashboardInstance && window.dashboardInstance.showNotification) {
							window.dashboardInstance.showNotification('error', 'Logout failed: ' + (response.error || 'Unknown error'));
						}
					}
				} else {
					// HTTP error status
					if (window.dashboardInstance && window.dashboardInstance.showNotification) {
						window.dashboardInstance.showNotification('error', 'Logout failed with status: ' + xhr.status);
					}
				}
			} catch (error) {
				console.error('Error handling logout response:', error);
				if (window.dashboardInstance && window.dashboardInstance.showNotification) {
					window.dashboardInstance.showNotification('error', 'Error processing logout response');
				}
				
				// Fallback: redirect to login anyway in case of error
				setTimeout(() => {
					window.location.href = '/login';
				}, 1000);
			}
		};
	</script>
}