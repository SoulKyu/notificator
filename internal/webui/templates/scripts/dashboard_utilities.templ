package scripts

templ DashboardUtilities() {
	<script>
		window.dashboardUtilitiesMixin = {
			updateURL() {
				const params = new URLSearchParams();
				
				if (this.searchQuery) params.set('search', this.searchQuery);
				if (this.filters.alertmanagers.length > 0) params.set('alertmanagers', this.filters.alertmanagers.join(','));
				if (this.filters.severities.length > 0) params.set('severities', this.filters.severities.join(','));
				if (this.filters.statuses.length > 0) params.set('statuses', this.filters.statuses.join(','));
				if (this.filters.teams.length > 0) params.set('teams', this.filters.teams.join(','));
				if (this.filters.alertNames && this.filters.alertNames.length > 0) params.set('alertNames', this.filters.alertNames.join(','));
				if (this.displayMode !== 'classic') params.set('displayMode', this.displayMode);
				if (this.viewMode !== 'list') params.set('viewMode', this.viewMode);
				if (this.sortField !== 'duration') params.set('sortField', this.sortField);
				if (this.sortDirection !== 'asc') params.set('sortDirection', this.sortDirection);
				if (this.acknowledgmentFilter) params.set('acknowledged', this.acknowledgmentFilter);
				if (this.commentsFilter) params.set('hasComments', this.commentsFilter);
				
				const queryString = params.toString();
				const newURL = queryString ? `${window.location.pathname}?${queryString}` : window.location.pathname;
				
				if (window.location.href !== window.location.origin + newURL) {
					window.history.replaceState({}, '', newURL);
				}
			},

			loadFiltersFromURL() {
				const params = new URLSearchParams(window.location.search);
				
				this.searchQuery = params.get('search') || '';
				this.filters.alertmanagers = params.get('alertmanagers') ? params.get('alertmanagers').split(',') : [];
				this.filters.severities = params.get('severities') ? params.get('severities').split(',') : [];
				this.filters.statuses = params.get('statuses') ? params.get('statuses').split(',') : [];
				this.filters.teams = params.get('teams') ? params.get('teams').split(',') : [];
				this.filters.alertNames = params.get('alertNames') ? params.get('alertNames').split(',') : [];
				this.displayMode = params.get('displayMode') || 'classic';
				this.viewMode = params.get('viewMode') || 'list';
				this.sortField = params.get('sortField') || 'duration';
				this.sortDirection = params.get('sortDirection') || 'asc';
				this.acknowledgmentFilter = params.get('acknowledged') || null;
				this.commentsFilter = params.get('hasComments') || null;
			},

			checkAlertFromURL() {
				// Check if URL contains an alert ID and open modal
				const pathParts = window.location.pathname.split('/');
				if (pathParts.length >= 4 && pathParts[1] === 'dashboard' && pathParts[2] === 'alert') {
					const alertId = pathParts[3];
					if (alertId) {
						// Wait a bit for initial data to load, then show alert details
						setTimeout(() => {
							this.showAlertDetails(alertId);
						}, 500);
					}
				}
			},

			copyToClipboard(text) {
				if (navigator.clipboard) {
					navigator.clipboard.writeText(text).then(() => {
						console.log('Copied to clipboard')
					}).catch(() => {
						console.error('Failed to copy to clipboard')
					});
				} else {
					const textArea = document.createElement('textarea');
					textArea.value = text;
					document.body.appendChild(textArea);
					textArea.select();
					try {
						document.execCommand('copy');
						console.log('Copied to clipboard')
					} catch (err) {
						console.log('Failed to copy to clipboard')
					}
					document.body.removeChild(textArea);
				}
			},

			// Filtering utilities
			applyFilters() {
				// Debounced filter application happens automatically via data loading
				this.loadDashboardData();
			},

			clearAllFilters() {
				this.searchQuery = '';
				this.filters = {
					alertmanagers: [],
					severities: [],
					statuses: [],
					teams: [],
					alertNames: []
				};
				this.acknowledgmentFilter = null;
				this.commentsFilter = null;
				this.activePresetName = null; // Clear active preset indicator
				this.loadDashboardData();
			},

			clearFilter(filterType) {
				this.filters[filterType] = [];
				this.applyFilters();
			},

			removeFilter(filterType, value) {
				const index = this.filters[filterType].indexOf(value);
				if (index > -1) {
					this.filters[filterType].splice(index, 1);
					this.applyFilters();
				}
			},

			hasActiveFilters() {
				return this.searchQuery.length > 0 ||
					   this.filters.alertmanagers.length > 0 ||
					   this.filters.severities.length > 0 ||
					   this.filters.statuses.length > 0 ||
					   this.filters.teams.length > 0 ||
					   this.filters.alertNames.length > 0 ||
					   this.acknowledgmentFilter !== null ||
					   this.commentsFilter !== null;
			},

			// Selection management
			toggleAlert(fingerprint) {
				const index = this.selectedAlerts.indexOf(fingerprint);
				if (index > -1) {
					this.selectedAlerts.splice(index, 1);
				} else {
					this.selectedAlerts.push(fingerprint);
				}
			},

			toggleGroup(groupName) {
				const index = this.selectedGroups.indexOf(groupName);
				if (index > -1) {
					this.selectedGroups.splice(index, 1);
				} else {
					this.selectedGroups.push(groupName);
				}
			},

			selectAll() {
				if (this.viewMode === 'list') {
					this.selectedAlerts = this.alerts.map(a => a.fingerprint);
				} else {
					this.selectedGroups = this.groups.map(g => g.groupName);
				}
			},

			clearSelection() {
				this.selectedAlerts = [];
				this.selectedGroups = [];
			},

			toggleSelectAll(event) {
				if (event.target.checked) {
					this.selectAll();
				} else {
					this.clearSelection();
				}
			},

			// Group expansion
			toggleGroupExpanded(groupName) {
				const index = this.expandedGroups.indexOf(groupName);
				if (index > -1) {
					this.expandedGroups.splice(index, 1);
				} else {
					this.expandedGroups.push(groupName);
				}
			},

			// Sorting
			sortBy(field) {
				if (this.sortField === field) {
					this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
				} else {
					this.sortField = field;
					this.sortDirection = 'asc';
				}
				this.loadDashboardData();
			},

			// Settings management
			loadSettings() {
				const saved = localStorage.getItem('dashboardSettings');
				if (saved) {
					try {
						const settings = JSON.parse(saved);
						this.settings = { ...this.settings, ...settings };
					} catch (e) {
						console.warn('Failed to parse saved settings:', e);
					}
				}
				
				this.applyTheme();
			},

			async saveSettings() {
				try {
					// Get the settings modal instance to check active tab
					const settingsModal = window.currentSettingsModal;

					// Check which tab is active and save appropriate settings
					if (settingsModal && settingsModal.activeTab === 'colors') {
						// Save color preferences
						const success = await settingsModal.saveColorPreferences();
						if (success) {
							this.showSettings = false;
						}
						return;
					}

					if (settingsModal && settingsModal.activeTab === 'notifications') {
						// Save notification preferences
						const success = await settingsModal.saveNotificationPreferences();
						if (success) {
							this.showSettings = false;
						}
						return;
					}

					// Otherwise, save general settings
					const settingsResponse = await fetch('/api/v1/dashboard/settings', {
						method: 'POST',
						credentials: 'include',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify(this.settings)
					});

					const settingsResult = await settingsResponse.json();
					
					if (!settingsResult.success) {
						return;
					}

					// Save to localStorage as well
					localStorage.setItem('dashboardSettings', JSON.stringify(this.settings));

					// Apply theme change
					this.applyTheme();

					this.showSettings = false;
					
					// Apply theme change
					this.applyTheme();
					
					// Restart auto-refresh with new interval
					this.startAutoRefresh();
				} catch (error) {
					console.error('Error saving settings:', error);
				}
			},

			applyTheme() {
				const isDark = this.settings.theme === 'dark';
				document.documentElement.classList.toggle('dark', isDark);

				// Update meta theme-color for mobile browsers
				const metaThemeColor = document.querySelector('meta[name="theme-color"]');
				if (metaThemeColor) {
					metaThemeColor.setAttribute('content', isDark ? '#1f2937' : '#ffffff');
				}
			},

			// Current user management
			async loadCurrentUser() {
				try {
					const response = await fetch('/api/v1/auth/profile', {
						credentials: 'include'
					});
					if (response.ok) {
						const result = await response.json();
						if (result.success && result.data) {
							this.currentUser = {
								id: result.data.id,
								username: result.data.username,
								email: result.data.email
							};

							// Initialize notification service with user ID
							if (window.notificationService) {
								await window.notificationService.init(this.currentUser.id);
								console.log('Notification service initialized for user:', this.currentUser.id);
							}
						}
					}
				} catch (error) {
					console.warn('Failed to load current user:', error);
				}
			},

			async loadAnnotationButtonConfigs() {
				try {
					const response = await fetch('/api/v1/dashboard/annotation-buttons', {
						credentials: 'include'
					});
					if (response.ok) {
						const result = await response.json();
						if (result.success && result.data && result.data.configs) {
							// Sanitize colors when loading to ensure safety
							this.annotationButtonConfigs = result.data.configs.map(config => ({
								...config,
								color: this.sanitizeColor(config.color)
							}));
							console.log('Loaded annotation button configs:', this.annotationButtonConfigs.length);
						}
					}
				} catch (error) {
					console.warn('Failed to load annotation button configs:', error);
					// Use default configs if loading fails
					this.annotationButtonConfigs = [];
				}
			},

			// Color sanitization for security
			sanitizeColor(color) {
				const hexColorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
				if (hexColorRegex.test(color)) {
					return color;
				}
				return '#6366f1'; // Default indigo-600
			},

			getCurrentUser() {
				return this.currentUser;
			},

			getUserInitials() {
				const currentUser = this.getCurrentUser();
				if (!currentUser || !currentUser.username) {
					return 'U'; // Fallback to 'U' if no user data
				}
				
				const username = currentUser.username.trim();
				if (username.length === 0) {
					return 'U';
				} else if (username.length === 1) {
					return username.toUpperCase();
				} else {
					// Get first 2 characters and convert to uppercase
					return username.substring(0, 2).toUpperCase();
				}
			},

			canDeleteComment(comment) {
				const currentUser = this.getCurrentUser();
				return currentUser && comment && (
					currentUser.id === comment.userId || 
					currentUser.username === comment.username
				);
			},

			// Column resizing utilities
			loadColumnWidths() {
				const saved = localStorage.getItem('dashboardColumnWidths');
				if (saved) {
					try {
						const widths = JSON.parse(saved);
						this.columnWidths = { ...this.columnWidths, ...widths };
					} catch (e) {
						console.warn('Failed to parse saved column widths:', e);
					}
				}
			},

			saveColumnWidths() {
				localStorage.setItem('dashboardColumnWidths', JSON.stringify(this.columnWidths));
			},

			startResize(event, column) {
				this.isResizing = true;
				this.currentColumn = column;
				this.startX = event.clientX;
				this.startWidth = this.columnWidths[column];
				
				event.preventDefault();
				document.body.style.cursor = 'col-resize';
				document.body.style.userSelect = 'none';
			},

			handleMouseMove(event) {
				if (!this.isResizing || !this.currentColumn) return;
				
				const diff = event.clientX - this.startX;
				const newWidth = Math.max(50, this.startWidth + diff); // Minimum width of 50px
				this.columnWidths[this.currentColumn] = newWidth;
			},

			handleMouseUp() {
				if (this.isResizing) {
					this.isResizing = false;
					this.currentColumn = null;
					this.saveColumnWidths();
					
					document.body.style.cursor = '';
					document.body.style.userSelect = '';
				}
			},

			resetColumnWidths() {
				// Reset to default widths
				this.columnWidths = {
					alertName: 300,
					acknowledge: 75,
					instance: 350,
					severity: 150,
					status: 150,
					comments: 130,
					team: 200,
					summary: 400,
					duration: 150,
					source: 180
				};
				
				// Clear saved widths
				localStorage.removeItem('dashboardColumnWidths');
			},

			// Format utilities
			formatDuration(seconds) {
				if (seconds < 60) {
					return `${Math.floor(seconds)}s`;
				} else if (seconds < 3600) {
					const minutes = Math.floor(seconds / 60);
					const remainingSeconds = Math.floor(seconds % 60);
					return `${minutes}m ${remainingSeconds}s`;
				} else if (seconds < 86400) { // Less than 24 hours
					const hours = Math.floor(seconds / 3600);
					const remainingMinutes = Math.floor((seconds % 3600) / 60);
					return `${hours}h ${remainingMinutes}m`;
				} else { // 24 hours or more - show days and hours
					const days = Math.floor(seconds / 86400);
					const remainingHours = Math.floor((seconds % 86400) / 3600);
					if (remainingHours > 0) {
						return `${days}d ${remainingHours}h`;
					} else {
						return `${days}d`;
					}
				}
			},

			formatTimestamp(timestamp) {
				return new Date(timestamp).toLocaleString();
			},
			
			// Pagination utilities
			getTotalPages() {
				return Math.ceil(this.totalItems / this.itemsPerPage);
			},
			
			getPaginationStartIndex() {
				if (this.totalItems === 0) return 0;
				return ((this.currentPage - 1) * this.itemsPerPage) + 1;
			},
			
			getPaginationEndIndex() {
				const end = this.currentPage * this.itemsPerPage;
				return end > this.totalItems ? this.totalItems : end;
			},
			
			getPageNumbers() {
				const totalPages = this.getTotalPages();
				const pages = [];
				
				if (totalPages <= 7) {
					// Show all pages if 7 or less
					for (let i = 1; i <= totalPages; i++) {
						pages.push(i);
					}
				} else {
					// Show first, last, and pages around current
					if (this.currentPage <= 3) {
						for (let i = 1; i <= 5; i++) {
							pages.push(i);
						}
						pages.push('...');
						pages.push(totalPages);
					} else if (this.currentPage >= totalPages - 2) {
						pages.push(1);
						pages.push('...');
						for (let i = totalPages - 4; i <= totalPages; i++) {
							pages.push(i);
						}
					} else {
						pages.push(1);
						pages.push('...');
						for (let i = this.currentPage - 1; i <= this.currentPage + 1; i++) {
							pages.push(i);
						}
						pages.push('...');
						pages.push(totalPages);
					}
				}
				
				return pages;
			},
			
			setItemsPerPage(value) {
				this.itemsPerPage = parseInt(value);
				this.currentPage = 1; // Reset to first page
				this.loadDashboardData();
			},
			
			goToPage(page) {
				if (page !== '...' && page !== this.currentPage) {
					this.currentPage = page;
					this.loadDashboardData();
				}
			},
			
			nextPage() {
				if (this.currentPage < this.getTotalPages()) {
					this.currentPage++;
					this.loadDashboardData();
				}
			},
			
			previousPage() {
				if (this.currentPage > 1) {
					this.currentPage--;
					this.loadDashboardData();
				}
			},
			
			// Group-by selector
			setGroupByLabel(label) {
				this.groupByLabel = label;
				this.loadDashboardData();
			},

			// Alert color utilities
			getAlertColor(alert, colorType = 'backgroundColor') {
				const fingerprint = alert.fingerprint;
				if (this.alertColors[fingerprint]) {
					const colorResult = this.alertColors[fingerprint];
					switch (colorType) {
						case 'backgroundColor': return colorResult.backgroundColor;
						case 'textColor': return colorResult.textColor;
						case 'borderColor': return colorResult.borderColor;
						case 'badgeColor': return colorResult.badgeColor;
						default: return colorResult.backgroundColor;
					}
				}
				
				// Fallback to default severity colors
				return this.getDefaultSeverityColor(alert, colorType);
			},

			// Get default severity color (fallback)
			getDefaultSeverityColor(alert, colorType = 'backgroundColor') {
				const severity = alert.severity || 'default';
				const colorMap = {
					critical: {
						backgroundColor: '#fee2e2', // red-100
						textColor: '#991b1b',       // red-800
						borderColor: '#dc2626',     // red-600
						badgeColor: '#dc2626'       // red-600
					},
					'critical-daytime': {
						backgroundColor: '#ffe4e6', // rose-100
						textColor: '#9f1239',       // rose-800
						borderColor: '#be123c',     // rose-700
						badgeColor: '#be123c'       // rose-700
					},
					warning: {
						backgroundColor: '#fef3c7', // amber-100
						textColor: '#92400e',       // amber-800
						borderColor: '#d97706',     // amber-600
						badgeColor: '#d97706'       // amber-600
					},
					info: {
						backgroundColor: '#dbeafe', // blue-100
						textColor: '#1e40af',       // blue-800
						borderColor: '#2563eb',     // blue-600
						badgeColor: '#2563eb'       // blue-600
					},
					default: {
						backgroundColor: '#f3f4f6', // gray-100
						textColor: '#374151',       // gray-700
						borderColor: '#6b7280',     // gray-500
						badgeColor: '#6b7280'       // gray-500
					}
				};
				
				const colors = colorMap[severity] || colorMap.default;
				return colors[colorType] || colors.backgroundColor;
			},

			getAlertBgColor(alert) {
				if (!alert || !alert.fingerprint) return '';
				
				const colorData = this.alertColors[alert.fingerprint];
				if (!colorData || !colorData.bgColor) return '';
				
				return `background-color: ${colorData.bgColor}; color: ${colorData.textColor || '#000000'};`;
			},

			getAlertTextColor(alert) {
				if (!alert || !alert.fingerprint) return '';

				const colorData = this.alertColors[alert.fingerprint];
				if (!colorData || !colorData.textColor) return '';

				return colorData.textColor;
			},

			initializeColumns() {
				// Try to get columns from current filter preset
				const currentPreset = this.filterPresets && this.filterPresets.length > 0
					? this.filterPresets.find(p => p.is_default) || this.filterPresets[0]
					: null;

				if (currentPreset && currentPreset.column_configs && currentPreset.column_configs.length > 0) {
					this.columns = currentPreset.column_configs;
					console.log('Loaded columns from preset:', currentPreset.name);
				} else {
					// Use default column configuration
					this.columns = this.getDefaultColumns();
					console.log('Using default column configuration');
				}

				this.updateVisibleColumns();
			},

			updateVisibleColumns() {
				this.visibleColumns = this.columns
					.filter(col => col.visible)
					.sort((a, b) => a.order - b.order);
			},

			getDefaultColumns() {
				return [
					{id: "col_select", label: "", field_type: "system", field_path: "select", formatter: "checkbox", width: 50, sortable: false, visible: true, order: 0, resizable: false, critical: true},
					{id: "col_alertname", label: "Alert Name", field_type: "system", field_path: "alertName", formatter: "text", width: 300, sortable: true, visible: true, order: 1, resizable: true, critical: true},
					{id: "col_actions", label: "Actions", field_type: "system", field_path: "actions", formatter: "actions", width: 100, sortable: false, visible: true, order: 2, resizable: false, critical: true},
					{id: "col_instance", label: "Instance", field_type: "system", field_path: "instance", formatter: "text", width: 350, sortable: true, visible: true, order: 3, resizable: true, critical: false},
					{id: "col_severity", label: "Severity", field_type: "system", field_path: "severity", formatter: "badge", width: 150, sortable: true, visible: true, order: 4, resizable: true, critical: false},
					{id: "col_status", label: "Status", field_type: "system", field_path: "status", formatter: "badge", width: 150, sortable: true, visible: true, order: 5, resizable: true, critical: false},
					{id: "col_comments", label: "Comments", field_type: "system", field_path: "commentCount", formatter: "count", width: 130, sortable: false, visible: true, order: 6, resizable: true, critical: false},
					{id: "col_team", label: "Team", field_type: "system", field_path: "team", formatter: "text", width: 200, sortable: true, visible: true, order: 7, resizable: true, critical: false},
					{id: "col_summary", label: "Summary", field_type: "system", field_path: "summary", formatter: "text", width: 400, sortable: false, visible: true, order: 8, resizable: true, critical: false},
					{id: "col_duration", label: "Duration", field_type: "system", field_path: "duration", formatter: "duration", width: 150, sortable: true, visible: true, order: 9, resizable: true, critical: false},
					{id: "col_source", label: "Alertmanager", field_type: "system", field_path: "source", formatter: "text", width: 180, sortable: true, visible: true, order: 10, resizable: true, critical: false},
				];
			},

			renderCell(alert, column) {
				const value = this.getFieldValue(alert, column.field_path);

				switch(column.formatter) {
					case 'checkbox':
						return this.renderCheckbox(alert);
					case 'text':
						return this.renderText(value);
					case 'badge':
						return this.renderBadge(value, column.field_path);
					case 'duration':
						return this.renderDuration(value);
					case 'timestamp':
						return this.renderTimestamp(value);
					case 'count':
						return this.renderCount(value);
					case 'actions':
						return this.renderActions(alert);
					default:
						return this.renderText(value);
				}
			},

			getFieldValue(alert, fieldPath) {
				if (!fieldPath || fieldPath === 'select' || fieldPath === 'actions') {
					return '';
				}

				const parts = fieldPath.split('.');
				let value = alert;

				for (const part of parts) {
					if (value === null || value === undefined) return '';
					value = value[part];
				}

				return value !== null && value !== undefined ? value : '';
			},

			renderText(value) {
				if (!value && value !== 0) return '<span class="text-gray-400 dark:text-gray-500">-</span>';
				const escaped = this.escapeHtml(String(value));
				return `<div class="text-sm font-medium text-gray-900 dark:text-gray-100 truncate" title="${escaped}">${escaped}</div>`;
			},

			renderBadge(value, fieldPath) {
				if (!value && value !== 0) return '<span class="text-gray-400 dark:text-gray-500">-</span>';

				// Extract actual value based on field type
				let strValue;
				if (fieldPath === 'status') {
					// Status is an object with { state: "firing|resolved|suppressed" }
					if (typeof value === 'object' && value !== null && value.state) {
						strValue = value.state === 'suppressed' ? 'silenced' : value.state;
					} else if (typeof value === 'string') {
						strValue = value;
					} else {
						strValue = 'unknown';
					}
				} else {
					// For other fields, convert to string
					strValue = String(value);
				}

				let colorClass = 'bg-gray-100 text-gray-700 dark:bg-gray-700 dark:text-gray-200';
				let dotColor = 'bg-gray-500';

				if (fieldPath === 'severity') {
					const colors = {
						'critical': {
							badge: 'bg-red-100 text-red-800 ring-1 ring-red-200 dark:bg-red-900/40 dark:text-red-200 dark:ring-red-800/50',
							dot: 'bg-red-600 dark:bg-red-400'
						},
						'warning': {
							badge: 'bg-amber-100 text-amber-800 ring-1 ring-amber-200 dark:bg-amber-900/40 dark:text-amber-200 dark:ring-amber-800/50',
							dot: 'bg-amber-600 dark:bg-amber-400'
						},
						'info': {
							badge: 'bg-blue-100 text-blue-800 ring-1 ring-blue-200 dark:bg-blue-900/40 dark:text-blue-200 dark:ring-blue-800/50',
							dot: 'bg-blue-600 dark:bg-blue-400'
						},
					};
					const scheme = colors[strValue.toLowerCase()];
					if (scheme) {
						colorClass = scheme.badge;
						dotColor = scheme.dot;
					}
				} else if (fieldPath === 'status') {
					const colors = {
						'firing': {
							badge: 'bg-red-100 text-red-800 ring-1 ring-red-200 dark:bg-red-900/40 dark:text-red-200 dark:ring-red-800/50',
							dot: 'bg-red-600 dark:bg-red-400'
						},
						'resolved': {
							badge: 'bg-emerald-100 text-emerald-800 ring-1 ring-emerald-200 dark:bg-emerald-900/40 dark:text-emerald-200 dark:ring-emerald-800/50',
							dot: 'bg-emerald-600 dark:bg-emerald-400'
						},
						'suppressed': {
							badge: 'bg-gray-100 text-gray-700 ring-1 ring-gray-200 dark:bg-gray-700 dark:text-gray-200 dark:ring-gray-600',
							dot: 'bg-gray-500'
						},
						'silenced': {
							badge: 'bg-gray-100 text-gray-700 ring-1 ring-gray-200 dark:bg-gray-700 dark:text-gray-200 dark:ring-gray-600',
							dot: 'bg-gray-500'
						},
					};
					const scheme = colors[strValue.toLowerCase()];
					if (scheme) {
						colorClass = scheme.badge;
						dotColor = scheme.dot;
					}
				}

				return `<span class="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full text-xs font-semibold ${colorClass}">
					<span class="w-1.5 h-1.5 rounded-full ${dotColor}"></span>
					${this.escapeHtml(strValue)}
				</span>`;
			},

			renderDuration(seconds) {
				if (!seconds || seconds < 0) return '<span class="text-gray-400 dark:text-gray-500">-</span>';

				const hours = Math.floor(seconds / 3600);
				const minutes = Math.floor((seconds % 3600) / 60);
				const secs = seconds % 60;

				let result = '';
				if (hours > 0) result = `${hours}h ${minutes}m`;
				else if (minutes > 0) result = `${minutes}m ${secs}s`;
				else result = `${secs}s`;

				return `<span class="text-sm text-gray-900 dark:text-white">${result}</span>`;
			},

			renderTimestamp(timestamp) {
				if (!timestamp) return '<span class="text-gray-400 dark:text-gray-500">-</span>';

				try {
					const date = new Date(timestamp);
					const formatted = date.toLocaleString();
					return `<span class="text-sm text-gray-900 dark:text-white">${this.escapeHtml(formatted)}</span>`;
				} catch (e) {
					return `<span class="text-sm text-gray-900 dark:text-white">${this.escapeHtml(String(timestamp))}</span>`;
				}
			},

			renderCount(count) {
				if (!count || count === 0) {
					return '<span class="text-gray-400 dark:text-gray-500">-</span>';
				}
				return `<span class="inline-flex items-center gap-1.5 px-2 py-1 rounded-md text-xs font-semibold bg-blue-50 text-blue-700 ring-1 ring-blue-100 dark:bg-blue-900/30 dark:text-blue-200 dark:ring-blue-800/50">
					<svg class="w-3.5 h-3.5" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none">
						<path stroke-linecap="round" stroke-linejoin="round" d="M7.5 8.25h9m-9 3H12m-9.75 1.51c0 1.6 1.123 2.994 2.707 3.227 1.129.166 2.27.293 3.423.379.35.026.67.21.865.501L12 21l2.755-4.133a1.14 1.14 0 0 1 .865-.501 48.172 48.172 0 0 0 3.423-.379c1.584-.233 2.707-1.626 2.707-3.228V6.741c0-1.602-1.123-2.995-2.707-3.228A48.394 48.394 0 0 0 12 3c-2.392 0-4.744.175-7.043.513C3.373 3.746 2.25 5.14 2.25 6.741v6.018Z" />
					</svg>
					<span>${count}</span>
				</span>`;
			},

			renderCheckbox(alert) {
				const checked = this.selectedAlerts.includes(alert.fingerprint) ? 'checked' : '';
				return `<input
					type="checkbox"
					${checked}
					onclick="event.stopPropagation(); window.dashboardInstance.toggleAlert('${alert.fingerprint}')"
					class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded cursor-pointer"
				>`;
			},

			renderActions(alert) {
				let html = '<div class="flex items-center gap-1.5">';

				if (alert.isAcknowledged) {
					html += `<div class="inline-flex items-center gap-1 px-2.5 py-1 rounded-md text-xs font-semibold bg-emerald-100 text-emerald-700 ring-1 ring-emerald-200 dark:bg-emerald-900/40 dark:text-emerald-200 dark:ring-emerald-800/50">
						<svg class="w-3.5 h-3.5" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none">
							<path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" />
						</svg>
						<span>ACK</span>
					</div>`;
				} else {
					html += `<button
						onclick="event.stopPropagation(); window.dashboardInstance.acknowledgeAlert('${alert.fingerprint}')"
						class="p-1.5 rounded-md text-gray-400 hover:text-emerald-600 hover:bg-emerald-50 dark:hover:text-emerald-400 dark:hover:bg-emerald-900/30 transition-all duration-150"
						title="Acknowledge Alert">
						<svg class="w-4 h-4" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none">
							<path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" />
						</svg>
					</button>`;
				}

				html += `<button
					onclick="event.stopPropagation(); window.dashboardInstance.silenceAlert('${alert.fingerprint}')"
					class="p-1.5 rounded-md text-gray-400 hover:text-amber-600 hover:bg-amber-50 dark:hover:text-amber-400 dark:hover:bg-amber-900/30 transition-all duration-150"
					title="Silence Alert">
					<svg class="w-4 h-4" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none">
						<path stroke-linecap="round" stroke-linejoin="round" d="M17.25 9.75 19.5 12m0 0 2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6 4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.59-.79-1.59-1.78V9.51c0-.88.79-1.59 1.78-1.59h1.78Z"/>
					</svg>
				</button>`;

				html += '</div>';
				return html;
			},

			escapeHtml(text) {
				const str = String(text);
				let result = '';
				for (let i = 0; i < str.length; i++) {
					const char = str[i];
					if (char === '&') result += '&amp;';
					else if (char === '<') result += '&lt;';
					else if (char === '>') result += '&gt;';
					else if (char === '"') result += '&quot;';
					else if (char === "'") result += '&#039;';
					else result += char;
				}
				return result;
			},

			sortByColumn(column) {
				if (!column.sortable) return;

				const field = column.field_path;

				// Toggle direction or set new field
				if (this.sortField === field) {
					this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
				} else {
					this.sortField = field;
					this.sortDirection = 'asc';
				}

				console.log('Sorting by:', field, this.sortDirection);
				this.applyFilters();
			},

			startColumnResize(event, column) {
				event.preventDefault();
				event.stopPropagation();

				const self = this;
				self.resizingColumn = column;
				self.resizeStartX = event.clientX;
				self.resizeStartWidth = column.width;

				const handleMove = (e) => {
					if (!self.resizingColumn) return;
					const delta = e.clientX - self.resizeStartX;
					const newWidth = Math.max(50, Math.min(800, self.resizeStartWidth + delta));
					self.resizingColumn.width = newWidth;
				};

				const handleEnd = () => {
					if (self.resizingColumn) {
						console.log('Column resized:', self.resizingColumn.id, 'to', self.resizingColumn.width);
						self.resizingColumn = null;
					}
					document.removeEventListener('mousemove', handleMove);
					document.removeEventListener('mouseup', handleEnd);
				};

				document.addEventListener('mousemove', handleMove);
				document.addEventListener('mouseup', handleEnd);
			},

			// =========================================
			// Column Management State
			// =========================================
			showAddColumnDialog: false,
			editingColumn: null,
			draggingColumn: null,
			newColumnConfig: {
				label: '',
				field_type: 'label',
				field_name: '',
				formatter: 'text',
				width: 200
			},

			// =========================================
			// Column Management Functions
			// =========================================

			resetNewColumnConfig() {
				this.newColumnConfig = {
					label: '',
					field_type: 'label',
					field_name: '',
					formatter: 'text',
					width: 200
				};
			},

			updateFieldPathPlaceholder() {
				// Helper to update placeholder based on field type
				// This is called from the UI when field_type changes
			},

			resetColumnsToDefaults() {
				if (confirm('Reset all columns to default configuration? This will remove all custom columns.')) {
					this.columns = this.getDefaultColumns();
					this.updateVisibleColumns();
					console.log('Columns reset to defaults');
				}
			},

			async saveUserColumnPreferences() {
				try {
					const response = await fetch('/api/v1/dashboard/column-preferences', {
						method: 'PUT',
						headers: { 'Content-Type': 'application/json' },
						credentials: 'include',
						body: JSON.stringify({ column_configs: this.columns })
					});

					if (this.handleAuthError(response)) {
						return false;
					}

					if (!response.ok) {
						const errorData = await response.json();
						console.error('Failed to save column preferences:', errorData);
						return false;
					}

					console.log('Column preferences saved successfully');
					return true;
				} catch (error) {
					console.error('Error saving column preferences:', error);
					return false;
				}
			},

			async loadUserColumnPreferences() {
				try {
					const response = await fetch('/api/v1/dashboard/column-preferences', {
						method: 'GET',
						credentials: 'include'
					});

					if (this.handleAuthError(response)) {
						return false;
					}

					if (!response.ok) {
						// User preferences don't exist yet - that's okay, use defaults
						console.log('No user column preferences found, using defaults');
						return false;
					}

					const data = await response.json();
					if (data.column_configs && Array.isArray(data.column_configs) && data.column_configs.length > 0) {
						this.columns = data.column_configs;
						this.updateVisibleColumns();
						console.log('User column preferences loaded successfully');
						return true;
					}

					return false;
				} catch (error) {
					console.error('Error loading column preferences:', error);
					return false;
				}
			},

			// Drag and drop handlers
			startColumnDrag(event, column, index) {
				if (column.locked) {
					event.preventDefault();
					return;
				}
				this.draggingColumn = column.id;
				event.dataTransfer.effectAllowed = 'move';
				event.dataTransfer.setData('text/html', event.target.innerHTML);
				event.dataTransfer.setData('columnIndex', index);
			},

			endColumnDrag(event) {
				this.draggingColumn = null;
			},

			handleColumnDragOver(event, targetIndex) {
				event.preventDefault();
				event.dataTransfer.dropEffect = 'move';
			},

			handleColumnDrop(event, targetIndex) {
				event.preventDefault();

				const sourceIndex = parseInt(event.dataTransfer.getData('columnIndex'));
				if (sourceIndex === targetIndex) return;

				// Don't allow moving locked columns
				if (this.columns[sourceIndex].locked) return;

				// Reorder columns
				const newColumns = [...this.columns];
				const [movedColumn] = newColumns.splice(sourceIndex, 1);
				newColumns.splice(targetIndex, 0, movedColumn);

				// Update order property
				newColumns.forEach((col, idx) => {
					col.order = idx;
				});

				this.columns = newColumns;
				this.updateVisibleColumns();
				this.draggingColumn = null;

				console.log('Column reordered:', movedColumn.label, 'from', sourceIndex, 'to', targetIndex);
			},

			editColumn(column) {
				this.editingColumn = column;
				this.newColumnConfig = {
					label: column.label,
					field_type: column.field_type,
					field_name: column.field_path.split('.').pop(), // Extract field name from path
					formatter: column.formatter,
					width: column.width
				};
				this.showAddColumnDialog = true;
			},

			deleteColumn(columnId) {
				const column = this.columns.find(col => col.id === columnId);
				const columnName = column ? column.label : 'this column';
				if (confirm(`Delete "${columnName}"?\n\nThis action cannot be undone. The column will be removed from your current configuration.`)) {
					this.columns = this.columns.filter(col => col.id !== columnId);
					this.updateVisibleColumns();
					console.log('Column deleted:', columnId);
				}
			},

			saveCustomColumn() {
				const config = this.newColumnConfig;

				// Validation with improved error messages
				if (!config.label) {
					alert('Column Label Required\n\nPlease enter a display name for your custom column (e.g., "Environment", "Pod Name").');
					return;
				}

				if (!config.field_name) {
					alert('Field Name Required\n\nPlease enter the field name without prefix.\n\nExamples:\n• For labels: "environment", "team", "cluster"\n• For annotations: "runbook_url", "dashboard"');
					return;
				}

				if (config.width < 50 || config.width > 800) {
					alert(`Invalid Column Width\n\nWidth must be between 50 and 800 pixels.\nYou entered: ${config.width}px\n\nRecommended widths:\n• Short text: 100-150px\n• Medium text: 200-300px\n• Long text: 400-600px`);
					return;
				}

				// Build field path
				const fieldPath = config.field_type === 'label'
					? `labels.${config.field_name}`
					: config.field_type === 'annotation'
					? `annotations.${config.field_name}`
					: config.field_name;

				if (this.editingColumn) {
					// Update existing column
					const index = this.columns.findIndex(col => col.id === this.editingColumn.id);
					if (index !== -1) {
						this.columns[index] = {
							...this.columns[index],
							label: config.label,
							field_type: config.field_type,
							field_path: fieldPath,
							formatter: config.formatter,
							width: config.width
						};
					}
					console.log('Column updated:', this.editingColumn.id);
				} else {
					// Add new column
					const columnId = `col_custom_${config.field_type}_${config.field_name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}`;

					// Check for duplicate ID
					if (this.columns.some(col => col.id === columnId)) {
						alert(`Duplicate Column\n\nA column for "${config.field_type}.${config.field_name}" already exists.\n\nPlease use a different field name or edit the existing column instead.`);
						return;
					}

					const newColumn = {
						id: columnId,
						label: config.label,
						field_type: config.field_type,
						field_path: fieldPath,
						formatter: config.formatter,
						width: config.width,
						sortable: config.formatter === 'text' || config.formatter === 'badge',
						visible: true,
						order: this.columns.length,
						resizable: true,
						locked: false
					};

					this.columns.push(newColumn);
					console.log('Column added:', columnId);
				}

				this.updateVisibleColumns();
				this.showAddColumnDialog = false;
				this.editingColumn = null;
				this.resetNewColumnConfig();
			}
		};

		// Global function to handle logout response
		window.handleLogoutResponse = function(event) {
			try {
				const xhr = event.detail.xhr;
				
				if (xhr.status === 200) {
					// Successful logout
					const response = JSON.parse(xhr.responseText);
					if (response.success) {
						// Clear any cached user data
						localStorage.removeItem('dashboardSettings');
						localStorage.removeItem('dashboardColumnWidths');
						
						
						// Redirect to login page after a brief delay
						setTimeout(() => {
							window.location.href = '/login';
						}, 500);
					} else {
						// Logout failed
						console.error('Logout Failed')
					}
				} else {
					// HTTP error status
					console.log('HTTP error status')
				}
			} catch (error) {
				console.error('Error handling logout response:', error);
				// Fallback: redirect to login anyway in case of error
				setTimeout(() => {
					window.location.href = '/login';
				}, 1000);
			}
		};
	</script>
}
