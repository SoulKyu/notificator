// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func DashboardNotifications() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\t// Notification and sound system for dashboard - Desktop pattern implementation\n\t\twindow.dashboardNotificationsMixin = {\n\t\t\t// Notification configuration (loaded from backend)\n\t\t\tnotificationConfig: {\n\t\t\t\tenabled: true,\n\t\t\t\tsoundEnabled: true,\n\t\t\t\tbrowserNotifications: true,\n\t\t\t\tcooldownSeconds: 300,\n\t\t\t\tmaxNotifications: 5,\n\t\t\t\trespectFilters: true,\n\t\t\t\tseverityRules: {\n\t\t\t\t\t'critical': true,\n\t\t\t\t\t'major': true,\n\t\t\t\t\t'warning': true,\n\t\t\t\t\t'minor': false,\n\t\t\t\t\t'info': false,\n\t\t\t\t\t'unknown': false\n\t\t\t\t},\n\t\t\t\tsoundConfig: {\n\t\t\t\t\tcriticalFrequency: 800,\n\t\t\t\t\tcriticalDuration: 200,\n\t\t\t\t\tcriticalType: 'square',\n\t\t\t\t\twarningFrequency: 600,\n\t\t\t\t\twarningDuration: 150,\n\t\t\t\t\twarningType: 'sine',\n\t\t\t\t\tinfoFrequency: 400,\n\t\t\t\t\tinfoDuration: 100,\n\t\t\t\t\tinfoType: 'sine'\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Desktop-pattern notification state\n\t\t\tlastNotifications: new Map(), // alertKey -> timestamp for cooldown\n\t\t\tnotificationQueue: [],\n\t\t\tactiveNotifications: new Set(),\n\t\t\tisProcessingNotifications: false,\n\t\t\tnotificationDelay: 1500,\n\n\t\t\t// Initialize notification system\n\t\t\tasync initializeNotificationSystem() {\n\t\t\t\tawait this.loadNotificationPreferences();\n\t\t\t\tthis.initializeSounds();\n\t\t\t\tthis.requestNotificationPermission();\n\t\t\t},\n\n\t\t\t// Load user notification preferences from backend\n\t\t\tasync loadNotificationPreferences() {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/notification-preferences', {\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\tif (result.success && result.data.preference) {\n\t\t\t\t\t\t\tconst preferences = result.data.preference;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Normalize severity rules to ensure all keys are lowercase\n\t\t\t\t\t\t\tif (preferences.severity_rules) {\n\t\t\t\t\t\t\t\tconst normalizedSeverityRules = {};\n\t\t\t\t\t\t\t\tObject.keys(preferences.severity_rules).forEach(severity => {\n\t\t\t\t\t\t\t\t\tnormalizedSeverityRules[severity.toLowerCase()] = preferences.severity_rules[severity];\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tpreferences.severityRules = normalizedSeverityRules;\n\t\t\t\t\t\t\t\t// Clean up the old key format\n\t\t\t\t\t\t\t\tdelete preferences.severity_rules;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Handle sound config format normalization\n\t\t\t\t\t\t\tif (preferences.sound_config) {\n\t\t\t\t\t\t\t\t// Map sound_config to soundConfig for notification system compatibility\n\t\t\t\t\t\t\t\tpreferences.soundConfig = { ...preferences.sound_config };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.notificationConfig = { ...this.notificationConfig, ...preferences };\n\t\t\t\t\t\t\tconsole.log('Loaded user notification preferences:', this.notificationConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.warn('Failed to load notification preferences, using defaults:', error);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Save notification preferences to backend\n\t\t\tasync saveNotificationPreferences() {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/notification-preferences', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\tbody: JSON.stringify({ preference: this.notificationConfig })\n\t\t\t\t\t});\n\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\tconsole.log('Notification preferences saved successfully');\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Failed to save notification preferences:', error);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Initialize sound objects\n\t\t\tinitializeSounds() {\n\t\t\t\tif (this.notificationConfig.soundEnabled) {\n\t\t\t\t\tthis.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n\t\t\t\t}\n\n\t\t\t\t// Initialize audio context on first user interaction\n\t\t\t\tdocument.addEventListener('click', () => {\n\t\t\t\t\tif (this.audioContext && this.audioContext.state === 'suspended') {\n\t\t\t\t\t\tthis.audioContext.resume();\n\t\t\t\t\t}\n\t\t\t\t}, { once: true });\n\t\t\t},\n\n\t\t\t// Request notification permission\n\t\t\trequestNotificationPermission() {\n\t\t\t\tif ('Notification' in window && Notification.permission === 'default') {\n\t\t\t\t\tNotification.requestPermission().then(permission => {\n\t\t\t\t\t\tconsole.log('Notification permission:', permission);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Process alerts for notifications - Desktop pattern implementation\n\t\t\tprocessAlertsForNotifications(oldAlerts, newAlerts) {\n\t\t\t\tif (!this.notificationConfig.enabled) {\n\t\t\t\t\tconsole.log('Notifications disabled - skipping notification processing');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Handle initial load case\n\t\t\t\tif (!this.hasInitiallyLoaded) {\n\t\t\t\t\tconsole.log('Initial load - skipping notifications for existing alerts');\n\t\t\t\t\tthis.hasInitiallyLoaded = true;\n\t\t\t\t\t// Save session state to prevent notifications on page refresh\n\t\t\t\t\tif (this.saveSessionState) {\n\t\t\t\t\t\tthis.saveSessionState();\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconsole.log(`Processing alerts for notifications: ${oldAlerts.length} old alerts, ${newAlerts.length} new alerts`);\n\n\t\t\t\t// Create alert keys for comparison\n\t\t\t\tconst oldAlertKeys = new Set(oldAlerts.map(alert => this.generateAlertKey(alert)));\n\t\t\t\tconst processedNotifications = [];\n\n\t\t\t\t// Check each new alert\n\t\t\t\tfor (const alert of newAlerts) {\n\t\t\t\t\tconst alertKey = this.generateAlertKey(alert);\n\t\t\t\t\t\n\t\t\t\t\t// Skip if alert existed before\n\t\t\t\t\tif (oldAlertKeys.has(alertKey)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if we should notify for this alert\n\t\t\t\t\tif (this.shouldNotify(alert)) {\n\t\t\t\t\t\tprocessedNotifications.push(alert);\n\t\t\t\t\t\tconsole.log(`Will notify for new alert: ${alert.alertname || alert.alertName} (${alert.severity})`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Process notifications if any\n\t\t\t\tif (processedNotifications.length > 0) {\n\t\t\t\t\tconsole.log(`Processing ${processedNotifications.length} notifications`);\n\t\t\t\t\tprocessedNotifications.forEach(alert => {\n\t\t\t\t\t\tthis.queueNotification(alert);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Generate alert key for comparison (similar to desktop pattern)\n\t\t\tgenerateAlertKey(alert) {\n\t\t\t\treturn alert.fingerprint || `${alert.alertname || alert.alertName}_${alert.instance || ''}_${alert.job || ''}`;\n\t\t\t},\n\n\t\t\t// Check if we should notify for this alert (desktop pattern)\n\t\t\tshouldNotify(alert) {\n\t\t\t\t// Skip resolved alerts\n\t\t\t\tif (this.isAlertResolved(alert)) {\n\t\t\t\t\tconsole.log(`Skipping resolved alert: ${alert.alertname || alert.alertName}`);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Skip silenced alerts\n\t\t\t\tif (this.isAlertSilenced(alert)) {\n\t\t\t\t\tconsole.log(`Skipping silenced alert: ${alert.alertname || alert.alertName}`);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Check severity rules\n\t\t\t\tconst severity = (alert.severity || 'unknown').toLowerCase();\n\t\t\t\tif (!this.notificationConfig.severityRules[severity]) {\n\t\t\t\t\tconsole.log(`Skipping alert with disabled severity: ${severity}`);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Check cooldown\n\t\t\t\tconst alertKey = this.generateAlertKey(alert);\n\t\t\t\tconst now = Date.now();\n\t\t\t\tconst lastNotification = this.lastNotifications.get(alertKey);\n\t\t\t\tif (lastNotification && (now - lastNotification) < (this.notificationConfig.cooldownSeconds * 1000)) {\n\t\t\t\t\tconsole.log(`Skipping alert due to cooldown: ${alert.alertname || alert.alertName}`);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Check filter respect (if enabled and dashboard has filters)\n\t\t\t\tif (this.notificationConfig.respectFilters && window.dashboardInstance) {\n\t\t\t\t\tif (!this.matchesFilters(alert)) {\n\t\t\t\t\t\tconsole.log(`Skipping alert that doesn't match current filters: ${alert.alertname || alert.alertName}`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t// Check if alert is resolved\n\t\t\tisAlertResolved(alert) {\n\t\t\t\treturn alert.status === 'resolved' ||\n\t\t\t\t\t   alert.status?.state === 'resolved' ||\n\t\t\t\t\t   alert.Status?.State === 'resolved';\n\t\t\t},\n\n\t\t\t// Check if alert is silenced\n\t\t\tisAlertSilenced(alert) {\n\t\t\t\treturn alert.status === 'suppressed' ||\n\t\t\t\t\t   alert.status?.state === 'suppressed' ||\n\t\t\t\t\t   alert.Status?.State === 'suppressed' ||\n\t\t\t\t\t   alert.status === 'silenced' ||\n\t\t\t\t\t   alert.status?.state === 'silenced' ||\n\t\t\t\t\t   alert.Status?.State === 'silenced' ||\n\t\t\t\t\t   (alert.status?.silencedBy && alert.status.silencedBy.length > 0) ||\n\t\t\t\t\t   (alert.Status?.SilencedBy && alert.Status.SilencedBy.length > 0);\n\t\t\t},\n\n\t\t\t// Check if alert matches current dashboard filters\n\t\t\tmatchesFilters(alert) {\n\t\t\t\tif (!window.dashboardInstance || !window.dashboardInstance.filters) {\n\t\t\t\t\treturn true; // No filters means all alerts match\n\t\t\t\t}\n\n\t\t\t\tconst filters = window.dashboardInstance.filters;\n\t\t\t\t\n\t\t\t\t// Check search filter\n\t\t\t\tif (filters.search && filters.search.trim()) {\n\t\t\t\t\tconst searchTerm = filters.search.toLowerCase();\n\t\t\t\t\tconst alertText = `${alert.alertname || alert.alertName} ${alert.summary || ''} ${alert.description || ''}`.toLowerCase();\n\t\t\t\t\tif (!alertText.includes(searchTerm)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Check severity filter\n\t\t\t\tif (filters.severity && filters.severity !== 'all') {\n\t\t\t\t\tif ((alert.severity || 'unknown').toLowerCase() !== filters.severity.toLowerCase()) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Check status filter\n\t\t\t\tif (filters.status && filters.status !== 'all') {\n\t\t\t\t\tconst alertStatus = (alert.status?.state || alert.Status?.State || alert.status || 'firing').toLowerCase();\n\t\t\t\t\tif (alertStatus !== filters.status.toLowerCase()) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t},\n\n\n\t\t\tqueueNotification(alert, highPriority = false) {\n\t\t\t\t// Check max notifications limit\n\t\t\t\tif (this.notificationQueue.length >= this.notificationConfig.maxNotifications) {\n\t\t\t\t\tconsole.log('Notification queue full, skipping notification');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (highPriority) {\n\t\t\t\t\tthis.notificationQueue.unshift(alert);\n\t\t\t\t} else {\n\t\t\t\t\tthis.notificationQueue.push(alert);\n\t\t\t\t}\n\t\t\t\tthis.processNotificationQueue();\n\t\t\t},\n\n\n\t\t\tasync processNotificationQueue() {\n\t\t\t\tif (this.isProcessingNotifications || this.notificationQueue.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Limit concurrent notifications based on config\n\t\t\t\tconst maxConcurrent = this.notificationConfig.maxNotifications || 5;\n\t\t\t\tif (this.activeNotifications.size >= maxConcurrent) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.isProcessingNotifications = true;\n\n\t\t\t\twhile (this.notificationQueue.length > 0 && this.activeNotifications.size < maxConcurrent) {\n\t\t\t\t\tconst alert = this.notificationQueue.shift();\n\t\t\t\t\tawait this.displayNotification(alert);\n\n\t\t\t\t\t// Add delay between notifications if there are more queued\n\t\t\t\t\tif (this.notificationQueue.length > 0) {\n\t\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve, this.notificationDelay));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.isProcessingNotifications = false;\n\n\t\t\t\t// Schedule next batch if queue is not empty\n\t\t\t\tif (this.notificationQueue.length > 0) {\n\t\t\t\t\tthis.notificationProcessingTimer = setTimeout(() => {\n\t\t\t\t\t\tthis.processNotificationQueue();\n\t\t\t\t\t}, this.notificationDelay);\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\tasync displayNotification(alert) {\n\t\t\t\tconst alertKey = this.generateAlertKey(alert);\n\t\t\t\tconst now = Date.now();\n\t\t\t\t\n\t\t\t\t// Update last notification time\n\t\t\t\tthis.lastNotifications.set(alertKey, now);\n\n\t\t\t\tlet title, body;\n\t\t\t\tconst severity = (alert.severity || 'unknown').toLowerCase();\n\t\t\t\tconst alertName = alert.alertname || alert.alertName || 'Unknown Alert';\n\n\t\t\t\tif (alert.isBatch) {\n\t\t\t\t\ttitle = `${alert.count} New ${severity.charAt(0).toUpperCase() + severity.slice(1)} Alerts`;\n\t\t\t\t\tbody = `${alert.count} new ${severity} alerts have been received`;\n\t\t\t\t} else {\n\t\t\t\t\ttitle = `New ${severity.charAt(0).toUpperCase() + severity.slice(1)} Alert`;\n\t\t\t\t\tbody = alertName + (alert.instance ? ` on ${alert.instance}` : '');\n\t\t\t\t}\n\n\t\t\t\t// Play sound if enabled\n\t\t\t\tif (this.notificationConfig.soundEnabled) {\n\t\t\t\t\tthis.playNotificationSound(severity);\n\t\t\t\t}\n\n\t\t\t\t// Try browser notification first\n\t\t\t\tif (this.notificationConfig.browserNotifications && 'Notification' in window && Notification.permission === 'granted') {\n\t\t\t\t\t// Dynamic icon selection based on alert severity\n\t\t\t\t\tlet iconPath;\n\t\t\t\t\tif (alert.severity === 'critical') {\n\t\t\t\t\t\ticonPath = '/static/images/critical-icon.png';\n\t\t\t\t\t} else if (alert.severity === 'warning') {\n\t\t\t\t\t\ticonPath = '/static/images/warning-icon.png';\n\t\t\t\t\t} else if (alert.severity === 'success') {\n\t\t\t\t\t\ticonPath = '/static/images/success-icon.png';\n\t\t\t\t\t} else if (alert.severity === 'info') {\n\t\t\t\t\t\ticonPath = '/static/images/info-icon.png';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Default icon for other severity levels (minor, major, etc.)\n\t\t\t\t\t\ticonPath = '/static/images/default-icon.png';\n\t\t\t\t\t}\n\n\t\t\t\t\tconst notification = new Notification(title, {\n\t\t\t\t\t\tbody: body,\n\t\t\t\t\t\ticon: iconPath,\n\t\t\t\t\t\ttag: alert.isBatch ? `batch-${alert.severity}` : alert.fingerprint,\n\t\t\t\t\t\trequireInteraction: alert.severity === 'critical'\n\t\t\t\t\t});\n\n\t\t\t\t\t// Track active notification\n\t\t\t\t\tconst notificationId = alert.isBatch ? `batch-${alert.severity}` : alert.fingerprint;\n\t\t\t\t\tthis.activeNotifications.add(notificationId);\n\n\t\t\t\t\t// Remove from active when closed\n\t\t\t\t\tnotification.onclose = () => {\n\t\t\t\t\t\tthis.activeNotifications.delete(notificationId);\n\t\t\t\t\t};\n\n\t\t\t\t\t// Auto-close after some time for non-critical alerts\n\t\t\t\t\tif (alert.severity !== 'critical') {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tnotification.close();\n\t\t\t\t\t\t}, 5000);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle click - focus window and show alert details\n\t\t\t\t\tnotification.onclick = () => {\n\t\t\t\t\t\twindow.focus();\n\t\t\t\t\t\tif (!alert.isBatch && alert.fingerprint) {\n\t\t\t\t\t\t\tthis.showAlertDetails(alert.fingerprint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnotification.close();\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\t// Fallback to in-app notification\n\t\t\t\t\tthis.showInAppNotification(alert.severity, title + ': ' + body);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tshowInAppNotification(type, message) {\n\t\t\t\t// Create a unique ID for this notification\n\t\t\t\tconst notificationId = 'notif-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);\n\t\t\t\tthis.activeNotifications.add(notificationId);\n\n\t\t\t\t// Play sound for the notification\n\t\t\t\tthis.playNotificationSound(type);\n\n\t\t\t\tconst notification = document.createElement('div');\n\t\t\t\tnotification.id = notificationId;\n\t\t\t\tnotification.className = `mb-2 p-4 rounded-lg shadow-lg transition-all duration-300 ${\n\t\t\t\t\ttype === 'success' ? 'bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-200' :\n\t\t\t\t\ttype === 'error' ? 'bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-200' :\n\t\t\t\t\ttype === 'warning' ? 'bg-yellow-100 text-yellow-800 dark:bg-yellow-800 dark:text-yellow-200' :\n\t\t\t\t\ttype === 'critical' ? 'bg-red-200 text-red-900 dark:bg-red-900 dark:text-red-100 border-2 border-red-500' :\n\t\t\t\t\ttype === 'info' ? 'bg-blue-100 text-blue-800 dark:bg-blue-800 dark:text-blue-200' :\n\t\t\t\t\t// Default styling for other severity levels (similar to info but with gray)\n\t\t\t\t\t'bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200'\n\t\t\t\t}`;\n\t\t\t\t\n\t\t\t\t// Get icon based on notification type\n\t\t\t\tlet iconSvg;\n\t\t\t\tif (type === 'success') {\n\t\t\t\t\ticonSvg = `<svg class=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z\"></path></svg>`;\n\t\t\t\t} else if (type === 'error' || type === 'critical') {\n\t\t\t\t\ticonSvg = `<svg class=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z\"></path></svg>`;\n\t\t\t\t} else if (type === 'warning') {\n\t\t\t\t\ticonSvg = `<svg class=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\"></path></svg>`;\n\t\t\t\t} else if (type === 'info') {\n\t\t\t\t\ticonSvg = `<svg class=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"></path></svg>`;\n\t\t\t\t} else {\n\t\t\t\t\t// Default icon for other severity levels (bell icon)\n\t\t\t\t\ticonSvg = `<svg class=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9\"></path></svg>`;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnotification.innerHTML = `\n\t\t\t\t\t<div class=\"flex items-center justify-between\">\n\t\t\t\t\t\t<div class=\"flex items-center\">\n\t\t\t\t\t\t\t<div class=\"flex-shrink-0 mr-3\">\n\t\t\t\t\t\t\t\t${iconSvg}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"text-sm font-medium\">${message}</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<button onclick=\"this.parentElement.parentElement.remove(); window.dashboardInstance?.activeNotifications?.delete('${notificationId}')\" class=\"ml-4 text-lg leading-none hover:opacity-70\">Ã—</button>\n\t\t\t\t\t</div>\n\t\t\t\t`;\n\n\t\t\t\t// Get or create notification container\n\t\t\t\tlet container = document.getElementById('notification-container');\n\t\t\t\tif (!container) {\n\t\t\t\t\tcontainer = document.createElement('div');\n\t\t\t\t\tcontainer.id = 'notification-container';\n\t\t\t\t\tcontainer.className = 'fixed top-4 right-4 z-50 max-w-sm';\n\t\t\t\t\tdocument.body.appendChild(container);\n\t\t\t\t}\n\n\t\t\t\tcontainer.appendChild(notification);\n\n\t\t\t\t// Auto-remove after delay\n\t\t\t\tconst autoRemoveDelay = type === 'critical' ? 10000 : type === 'error' ? 7000 : 5000;\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (notification.parentElement) {\n\t\t\t\t\t\tnotification.style.opacity = '0';\n\t\t\t\t\t\tnotification.style.transform = 'translateX(100%)';\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tif (notification.parentElement) {\n\t\t\t\t\t\t\t\tnotification.remove();\n\t\t\t\t\t\t\t\tthis.activeNotifications.delete(notificationId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, 300);\n\t\t\t\t\t}\n\t\t\t\t}, autoRemoveDelay);\n\t\t\t},\n\n\t\t\tshowNotification(type, message) {\n\t\t\t\tthis.showInAppNotification(type, message);\n\t\t\t},\n\n\t\t\tplayNotificationSound(severity) {\n\t\t\t\tif (!this.notificationConfig.soundEnabled || !this.audioContext) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst soundConfig = this.getSoundConfigForSeverity(severity);\n\t\t\t\t\t\n\t\t\t\t\tconst oscillator = this.audioContext.createOscillator();\n\t\t\t\t\tconst gainNode = this.audioContext.createGain();\n\t\t\t\t\t\n\t\t\t\t\toscillator.connect(gainNode);\n\t\t\t\t\tgainNode.connect(this.audioContext.destination);\n\t\t\t\t\t\n\t\t\t\t\toscillator.frequency.setValueAtTime(soundConfig.frequency, this.audioContext.currentTime);\n\t\t\t\t\toscillator.type = soundConfig.type;\n\t\t\t\t\t\n\t\t\t\t\tgainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);\n\t\t\t\t\tgainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + soundConfig.duration / 1000);\n\t\t\t\t\t\n\t\t\t\t\toscillator.start(this.audioContext.currentTime);\n\t\t\t\t\toscillator.stop(this.audioContext.currentTime + soundConfig.duration / 1000);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.warn('Failed to play notification sound:', error);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Get sound configuration for severity level\n\t\t\tgetSoundConfigForSeverity(severity) {\n\t\t\t\tconst config = this.notificationConfig.soundConfig || {};\n\t\t\t\tconst severityLower = severity.toLowerCase();\n\t\t\t\t\n\t\t\t\t// First try the new dynamic format (severity_frequency)\n\t\t\t\tconst freqKey = `${severityLower}_frequency`;\n\t\t\t\tconst durKey = `${severityLower}_duration`;\n\t\t\t\tconst typeKey = `${severityLower}_type`;\n\t\t\t\t\n\t\t\t\tif (config[freqKey] !== undefined) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfrequency: config[freqKey] || 500,\n\t\t\t\t\t\tduration: config[durKey] || 150,\n\t\t\t\t\t\ttype: config[typeKey] || 'sine'\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Fallback to legacy hardcoded format for backward compatibility\n\t\t\t\tswitch (severityLower) {\n\t\t\t\t\tcase 'critical':\n\t\t\t\t\tcase 'major':\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tfrequency: config.criticalFrequency || 800,\n\t\t\t\t\t\t\tduration: config.criticalDuration || 200,\n\t\t\t\t\t\t\ttype: config.criticalType || 'square'\n\t\t\t\t\t\t};\n\t\t\t\t\tcase 'warning':\n\t\t\t\t\tcase 'minor':\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tfrequency: config.warningFrequency || 600,\n\t\t\t\t\t\t\tduration: config.warningDuration || 150,\n\t\t\t\t\t\t\ttype: config.warningType || 'sine'\n\t\t\t\t\t\t};\n\t\t\t\t\tcase 'info':\n\t\t\t\t\tcase 'information':\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tfrequency: config.infoFrequency || 400,\n\t\t\t\t\t\t\tduration: config.infoDuration || 100,\n\t\t\t\t\t\t\ttype: config.infoType || 'sine'\n\t\t\t\t\t\t};\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Default configuration for unknown severities\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tfrequency: 500,\n\t\t\t\t\t\t\tduration: 120,\n\t\t\t\t\t\t\ttype: 'triangle'\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Legacy method for backward compatibility\n\t\t\tplaySound(severity) {\n\t\t\t\tthis.playNotificationSound(severity);\n\t\t\t},\n\n\t\t\t// Apply notification settings (called when settings change)\n\t\t\tapplyNotificationSettings() {\n\t\t\t\t// Update notification delays and limits\n\t\t\t\tthis.notificationDelay = 1500; // Fixed delay between notifications\n\n\t\t\t\t// Clear existing timers\n\t\t\t\tif (this.notificationProcessingTimer) {\n\t\t\t\t\tclearTimeout(this.notificationProcessingTimer);\n\t\t\t\t\tthis.notificationProcessingTimer = null;\n\t\t\t\t}\n\n\t\t\t\t// Request notification permission if browser notifications are enabled\n\t\t\t\tif (this.notificationConfig.browserNotifications && 'Notification' in window && Notification.permission === 'default') {\n\t\t\t\t\tNotification.requestPermission().then(permission => {\n\t\t\t\t\t\tconsole.log('Notification permission:', permission);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Reinitialize sounds if sound settings changed\n\t\t\t\tif (this.notificationConfig.soundEnabled && !this.audioContext) {\n\t\t\t\t\tthis.initializeSounds();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Update notification configuration (called when user changes preferences)\n\t\t\tupdateNotificationConfig(newConfig) {\n\t\t\t\t// Normalize severity rules to ensure all keys are lowercase\n\t\t\t\tif (newConfig.severity_rules) {\n\t\t\t\t\tconst normalizedSeverityRules = {};\n\t\t\t\t\tObject.keys(newConfig.severity_rules).forEach(severity => {\n\t\t\t\t\t\tnormalizedSeverityRules[severity.toLowerCase()] = newConfig.severity_rules[severity];\n\t\t\t\t\t});\n\t\t\t\t\tnewConfig.severityRules = normalizedSeverityRules;\n\t\t\t\t\t// Clean up the old key format\n\t\t\t\t\tdelete newConfig.severity_rules;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Normalize sound config format (keep both formats for compatibility)\n\t\t\t\tif (newConfig.sound_config) {\n\t\t\t\t\t// The sound_config is already in the correct format (severity_frequency)\n\t\t\t\t\t// Just ensure it's mapped to soundConfig for the notification system\n\t\t\t\t\tnewConfig.soundConfig = { ...newConfig.sound_config };\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.notificationConfig = { ...this.notificationConfig, ...newConfig };\n\t\t\t\tthis.applyNotificationSettings();\n\t\t\t\tthis.saveNotificationPreferences();\n\t\t\t},\n\n\t\t\t// Legacy compatibility methods for dashboard integration\n\t\t\tcheckForNewAlerts(oldAlerts, newAlerts) {\n\t\t\t\t// Redirect to new desktop-pattern method\n\t\t\t\tthis.processAlertsForNotifications(oldAlerts, newAlerts);\n\t\t\t}\n\t\t};\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
