// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func DashboardNotifications() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\t// Notification and sound system for dashboard\n\t\twindow.dashboardNotificationsMixin = {\n\t\t\t// Initialize sound objects\n\t\t\tinitializeSounds() {\n\t\t\t\tif (this.settings.soundEnabled) {\n\t\t\t\t\tthis.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n\t\t\t\t}\n\n\t\t\t\t// Critical alert sound (higher frequency, more urgent)\n\t\t\t\tthis.criticalSound = {\n\t\t\t\t\tfrequency: 800,\n\t\t\t\t\tduration: 200,\n\t\t\t\t\ttype: 'square'\n\t\t\t\t};\n\n\t\t\t\t// Warning alert sound (medium frequency)\n\t\t\t\tthis.warningSound = {\n\t\t\t\t\tfrequency: 600,\n\t\t\t\t\tduration: 150,\n\t\t\t\t\ttype: 'sine'\n\t\t\t\t};\n\n\t\t\t\t// Initialize audio context on first user interaction\n\t\t\t\tdocument.addEventListener('click', () => {\n\t\t\t\t\tif (this.audioContext && this.audioContext.state === 'suspended') {\n\t\t\t\t\t\tthis.audioContext.resume();\n\t\t\t\t\t}\n\t\t\t\t}, { once: true });\n\t\t\t},\n\n\t\t\tcheckForNewAlerts(oldAlerts, newAlerts) {\n\t\t\t\tif (!this.settings.notificationsEnabled || oldAlerts.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst oldFingerprints = new Set(oldAlerts.map(a => a.fingerprint));\n\t\t\t\tconst newlyArrivedAlerts = newAlerts.filter(alert => !oldFingerprints.has(alert.fingerprint));\n\n\t\t\t\tif (newlyArrivedAlerts.length > 0) {\n\t\t\t\t\tconsole.log(`Found ${newlyArrivedAlerts.length} new alerts`);\n\n\t\t\t\t\tif (this.settings.notificationBatching) {\n\t\t\t\t\t\t// Batch notifications and sounds\n\t\t\t\t\t\tthis.batchNotifications(newlyArrivedAlerts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Individual notifications\n\t\t\t\t\t\tnewlyArrivedAlerts.forEach(alert => {\n\t\t\t\t\t\t\tthis.queueNotification(alert);\n\t\t\t\t\t\t\tthis.queueSound(alert);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tbatchNotifications(alerts) {\n\t\t\t\t// Group by severity for better batching\n\t\t\t\tconst groupedBySeverity = alerts.reduce((acc, alert) => {\n\t\t\t\t\tif (!acc[alert.severity]) acc[alert.severity] = [];\n\t\t\t\t\tacc[alert.severity].push(alert);\n\t\t\t\t\treturn acc;\n\t\t\t\t}, {});\n\n\t\t\t\t// Handle critical alerts with higher priority\n\t\t\t\tif (this.settings.prioritizedNotifications) {\n\t\t\t\t\t// Critical alerts get individual notifications\n\t\t\t\t\tif (groupedBySeverity.critical) {\n\t\t\t\t\t\tgroupedBySeverity.critical.forEach(alert => {\n\t\t\t\t\t\t\tthis.queueNotification(alert, true); // High priority\n\t\t\t\t\t\t\tthis.queueSound(alert);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tdelete groupedBySeverity.critical;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Batch remaining alerts by severity\n\t\t\t\tObject.entries(groupedBySeverity).forEach(([severity, severityAlerts]) => {\n\t\t\t\t\tif (severityAlerts.length === 1) {\n\t\t\t\t\t\tthis.queueNotification(severityAlerts[0]);\n\t\t\t\t\t\tthis.queueSound(severityAlerts[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Create a batch notification\n\t\t\t\t\t\tconst batchNotification = {\n\t\t\t\t\t\t\tseverity: severity,\n\t\t\t\t\t\t\tcount: severityAlerts.length,\n\t\t\t\t\t\t\tisBatch: true,\n\t\t\t\t\t\t\talerts: severityAlerts\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis.queueNotification(batchNotification);\n\t\t\t\t\t\tthis.queueSound(severityAlerts[0]); // Play sound for the first alert of this severity\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tqueueNotification(alert, highPriority = false) {\n\t\t\t\tif (highPriority) {\n\t\t\t\t\tthis.notificationQueue.unshift(alert);\n\t\t\t\t} else {\n\t\t\t\t\tthis.notificationQueue.push(alert);\n\t\t\t\t}\n\t\t\t\tthis.processNotificationQueue();\n\t\t\t},\n\n\t\t\tqueueSound(alert) {\n\t\t\t\tthis.audioQueue.push(alert);\n\t\t\t\tthis.processAudioQueue();\n\t\t\t},\n\n\t\t\tasync processNotificationQueue() {\n\t\t\t\tif (this.isProcessingNotifications || this.notificationQueue.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Limit concurrent notifications\n\t\t\t\tif (this.activeNotifications.size >= this.maxConcurrentNotifications) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.isProcessingNotifications = true;\n\n\t\t\t\twhile (this.notificationQueue.length > 0 && this.activeNotifications.size < this.maxConcurrentNotifications) {\n\t\t\t\t\tconst alert = this.notificationQueue.shift();\n\t\t\t\t\tawait this.displayNotification(alert);\n\n\t\t\t\t\t// Add delay between notifications if there are more queued\n\t\t\t\t\tif (this.notificationQueue.length > 0) {\n\t\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve, this.notificationDelay));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.isProcessingNotifications = false;\n\n\t\t\t\t// Schedule next batch if queue is not empty\n\t\t\t\tif (this.notificationQueue.length > 0) {\n\t\t\t\t\tthis.notificationProcessingTimer = setTimeout(() => {\n\t\t\t\t\t\tthis.processNotificationQueue();\n\t\t\t\t\t}, this.notificationDelay);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync processAudioQueue() {\n\t\t\t\tif (this.isProcessingAudio || this.audioQueue.length === 0 || !this.settings.soundEnabled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.isProcessingAudio = true;\n\n\t\t\t\twhile (this.audioQueue.length > 0) {\n\t\t\t\t\tconst alert = this.audioQueue.shift();\n\t\t\t\t\tthis.playSound(alert.severity);\n\n\t\t\t\t\t// Small delay between sounds\n\t\t\t\t\tif (this.audioQueue.length > 0) {\n\t\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve, 200));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.isProcessingAudio = false;\n\t\t\t},\n\n\t\t\tasync displayNotification(alert) {\n\t\t\t\tlet title, body;\n\n\t\t\t\tif (alert.isBatch) {\n\t\t\t\t\ttitle = `${alert.count} New ${alert.severity.charAt(0).toUpperCase() + alert.severity.slice(1)} Alerts`;\n\t\t\t\t\tbody = `${alert.count} new ${alert.severity} alerts have been received`;\n\t\t\t\t} else {\n\t\t\t\t\ttitle = `New ${alert.severity.charAt(0).toUpperCase() + alert.severity.slice(1)} Alert`;\n\t\t\t\t\tbody = alert.alertName + (alert.instance ? ` on ${alert.instance}` : '');\n\t\t\t\t}\n\n\t\t\t\t// Try browser notification first\n\t\t\t\tif ('Notification' in window && Notification.permission === 'granted') {\n\t\t\t\t\tconst notification = new Notification(title, {\n\t\t\t\t\t\tbody: body,\n\t\t\t\t\t\ticon: '/static/images/alert-icon.png',\n\t\t\t\t\t\ttag: alert.isBatch ? `batch-${alert.severity}` : alert.fingerprint,\n\t\t\t\t\t\trequireInteraction: alert.severity === 'critical'\n\t\t\t\t\t});\n\n\t\t\t\t\t// Track active notification\n\t\t\t\t\tconst notificationId = alert.isBatch ? `batch-${alert.severity}` : alert.fingerprint;\n\t\t\t\t\tthis.activeNotifications.add(notificationId);\n\n\t\t\t\t\t// Remove from active when closed\n\t\t\t\t\tnotification.onclose = () => {\n\t\t\t\t\t\tthis.activeNotifications.delete(notificationId);\n\t\t\t\t\t};\n\n\t\t\t\t\t// Auto-close after some time for non-critical alerts\n\t\t\t\t\tif (alert.severity !== 'critical') {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tnotification.close();\n\t\t\t\t\t\t}, 5000);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle click - focus window and show alert details\n\t\t\t\t\tnotification.onclick = () => {\n\t\t\t\t\t\twindow.focus();\n\t\t\t\t\t\tif (!alert.isBatch && alert.fingerprint) {\n\t\t\t\t\t\t\tthis.showAlertDetails(alert.fingerprint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnotification.close();\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\t// Fallback to in-app notification\n\t\t\t\t\tthis.showInAppNotification(alert.severity, title + ': ' + body);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tshowInAppNotification(type, message) {\n\t\t\t\t// Create a unique ID for this notification\n\t\t\t\tconst notificationId = 'notif-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);\n\t\t\t\tthis.activeNotifications.add(notificationId);\n\n\t\t\t\tconst notification = document.createElement('div');\n\t\t\t\tnotification.id = notificationId;\n\t\t\t\tnotification.className = `mb-2 p-4 rounded-lg shadow-lg transition-all duration-300 ${\n\t\t\t\t\ttype === 'success' ? 'bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-200' :\n\t\t\t\t\ttype === 'error' ? 'bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-200' :\n\t\t\t\t\ttype === 'warning' ? 'bg-yellow-100 text-yellow-800 dark:bg-yellow-800 dark:text-yellow-200' :\n\t\t\t\t\ttype === 'critical' ? 'bg-red-200 text-red-900 dark:bg-red-900 dark:text-red-100 border-2 border-red-500' :\n\t\t\t\t\t'bg-blue-100 text-blue-800 dark:bg-blue-800 dark:text-blue-200'\n\t\t\t\t}`;\n\t\t\t\t\n\t\t\t\tnotification.innerHTML = `\n\t\t\t\t\t<div class=\"flex items-center justify-between\">\n\t\t\t\t\t\t<div class=\"flex items-center\">\n\t\t\t\t\t\t\t<div class=\"flex-shrink-0 mr-3\">\n\t\t\t\t\t\t\t\t${type === 'success' ? '✓' : type === 'error' || type === 'critical' ? '✕' : type === 'warning' ? '⚠' : 'ℹ'}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"text-sm font-medium\">${message}</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<button onclick=\"this.parentElement.parentElement.remove(); window.dashboardInstance?.activeNotifications?.delete('${notificationId}')\" class=\"ml-4 text-lg leading-none hover:opacity-70\">×</button>\n\t\t\t\t\t</div>\n\t\t\t\t`;\n\n\t\t\t\t// Get or create notification container\n\t\t\t\tlet container = document.getElementById('notification-container');\n\t\t\t\tif (!container) {\n\t\t\t\t\tcontainer = document.createElement('div');\n\t\t\t\t\tcontainer.id = 'notification-container';\n\t\t\t\t\tcontainer.className = 'fixed top-4 right-4 z-50 max-w-sm';\n\t\t\t\t\tdocument.body.appendChild(container);\n\t\t\t\t}\n\n\t\t\t\tcontainer.appendChild(notification);\n\n\t\t\t\t// Auto-remove after delay\n\t\t\t\tconst autoRemoveDelay = type === 'critical' ? 10000 : type === 'error' ? 7000 : 5000;\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (notification.parentElement) {\n\t\t\t\t\t\tnotification.style.opacity = '0';\n\t\t\t\t\t\tnotification.style.transform = 'translateX(100%)';\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tif (notification.parentElement) {\n\t\t\t\t\t\t\t\tnotification.remove();\n\t\t\t\t\t\t\t\tthis.activeNotifications.delete(notificationId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, 300);\n\t\t\t\t\t}\n\t\t\t\t}, autoRemoveDelay);\n\t\t\t},\n\n\t\t\tshowNotification(type, message) {\n\t\t\t\tthis.showInAppNotification(type, message);\n\t\t\t},\n\n\t\t\tplaySound(severity) {\n\t\t\t\tif (!this.settings.soundEnabled || !this.audioContext) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst soundConfig = severity === 'critical' ? this.criticalSound : this.warningSound;\n\t\t\t\t\t\n\t\t\t\t\tconst oscillator = this.audioContext.createOscillator();\n\t\t\t\t\tconst gainNode = this.audioContext.createGain();\n\t\t\t\t\t\n\t\t\t\t\toscillator.connect(gainNode);\n\t\t\t\t\tgainNode.connect(this.audioContext.destination);\n\t\t\t\t\t\n\t\t\t\t\toscillator.frequency.setValueAtTime(soundConfig.frequency, this.audioContext.currentTime);\n\t\t\t\t\toscillator.type = soundConfig.type;\n\t\t\t\t\t\n\t\t\t\t\tgainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);\n\t\t\t\t\tgainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + soundConfig.duration / 1000);\n\t\t\t\t\t\n\t\t\t\t\toscillator.start(this.audioContext.currentTime);\n\t\t\t\t\toscillator.stop(this.audioContext.currentTime + soundConfig.duration / 1000);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.warn('Failed to play sound:', error);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Apply notification settings (called when settings change)\n\t\t\tapplyNotificationSettings() {\n\t\t\t\tthis.maxConcurrentNotifications = this.settings.maxConcurrentNotifications || 3;\n\t\t\t\tthis.notificationDelay = this.settings.notificationDelay || 1500;\n\n\t\t\t\t// Clear existing timers\n\t\t\t\tif (this.notificationProcessingTimer) {\n\t\t\t\t\tclearTimeout(this.notificationProcessingTimer);\n\t\t\t\t\tthis.notificationProcessingTimer = null;\n\t\t\t\t}\n\t\t\t\tif (this.audioProcessingTimer) {\n\t\t\t\t\tclearTimeout(this.audioProcessingTimer);\n\t\t\t\t\tthis.audioProcessingTimer = null;\n\t\t\t\t}\n\n\t\t\t\t// Request notification permission if notifications are enabled\n\t\t\t\tif (this.settings.notificationsEnabled && 'Notification' in window && Notification.permission === 'default') {\n\t\t\t\t\tNotification.requestPermission();\n\t\t\t\t}\n\n\t\t\t\t// Reinitialize sounds if sound settings changed\n\t\t\t\tif (this.settings.soundEnabled && !this.audioContext) {\n\t\t\t\t\tthis.initializeSounds();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
