package scripts

// Filter Presets Mixin
templ DashboardFilterPresetsMixin() {
	<script type="text/javascript">
	// Filter presets management functions
	window.dashboardFilterPresetsMixin = {
		presets: [],
		newPreset: {
			name: '',
			description: '',
			is_shared: false
		},
		editingPreset: null,
		activeTab: 'list',

		// Filter-specific hidden alerts state
		activeFilterPresetId: null,
		filterHiddenAlerts: [],
		filterHiddenRules: [],
		showFilterHiddenManager: false,
		newFilterRule: {
			name: '',
			label_key: '',
			label_value: '',
			is_regex: false,
			is_enabled: true
		},

		// Available labels for autocomplete
		filterAvailableLabels: {},
		filterAvailableLabelsLastLoaded: null,

		// Load available labels for autocomplete
		async loadFilterAvailableLabels() {
			// Check if we already have cached labels and they're not too old (cache for 5 minutes)
			if (this.filterAvailableLabels && Object.keys(this.filterAvailableLabels).length > 0 &&
				this.filterAvailableLabelsLastLoaded &&
				(Date.now() - this.filterAvailableLabelsLastLoaded) < 300000) {
				return;
			}

			try {
				const response = await fetch('/api/v1/dashboard/available-labels', {
					credentials: 'include'
				});
				if (response.ok) {
					const result = await response.json();
					if (result.success) {
						this.filterAvailableLabels = result.data.labels || {};
						this.filterAvailableLabelsLastLoaded = Date.now();
						console.log('Loaded available labels for filter rules:', Object.keys(this.filterAvailableLabels).length, 'label types');
					}
				}
			} catch (error) {
				console.error('Error loading available labels:', error);
			}
		},

		// Ensure labels are loaded (call on focus)
		ensureFilterAvailableLabels() {
			if (!this.filterAvailableLabels || Object.keys(this.filterAvailableLabels).length === 0) {
				this.loadFilterAvailableLabels();
			}
		},

		// Get available values for a specific label key
		getFilterAvailableValues(labelKey) {
			if (!labelKey || !this.filterAvailableLabels) return [];
			return this.filterAvailableLabels[labelKey] || [];
		},

		// Load all filter presets
		async loadFilterPresets() {
			try {
				const response = await fetch('/api/v1/dashboard/filter-presets?include_shared=true');
				const data = await response.json();

				if (data.success) {
					this.presets = data.presets || [];
					console.log('Loaded', this.presets.length, 'filter presets');
				} else {
					console.error('Failed to load filter presets:', data.message);
				}
			} catch (error) {
				console.error('Error loading filter presets:', error);
			}
		},

		// Load default filter preset on init
		// Returns true if a default preset was loaded, false otherwise
		async loadDefaultFilterPreset() {
			try {
				const response = await fetch('/api/v1/dashboard/filter-presets/default');
				const data = await response.json();

				if (data.success && data.preset) {
					console.log('Loading default filter preset:', data.preset.name);
					await this.applyFilterPreset(data.preset);
					// Track that this is the active default preset
					this.activePresetName = data.preset.name;
					return true;
				}
			} catch (error) {
				console.error('Error loading default filter preset:', error);
			}
			return false;
		},

		// Save new filter preset
		async saveNewPreset() {
			if (!this.newPreset.name.trim()) {
				alert('Please enter a name for the filter preset');
				return;
			}

			try {
				const filterData = this.captureCurrentFilterState();
				const payload = {
					name: this.newPreset.name.trim(),
					description: this.newPreset.description.trim(),
					is_shared: this.newPreset.is_shared,
					filter_data: filterData
				};

				let response;
				if (this.editingPreset) {
					// Update existing preset
					response = await fetch(`/api/v1/dashboard/filter-presets/${this.editingPreset.id}`, {
						method: 'PUT',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(payload)
					});
				} else {
					// Create new preset
					response = await fetch('/api/v1/dashboard/filter-presets', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(payload)
					});
				}

				const data = await response.json();

				if (data.success) {
					alert(this.editingPreset ? 'Filter preset updated!' : 'Filter preset saved!');
					await this.loadFilterPresets();
					this.resetNewPresetForm();
					this.activeTab = 'list';
				} else {
					alert('Failed to save filter preset: ' + data.message);
				}
			} catch (error) {
				console.error('Error saving filter preset:', error);
				alert('Error saving filter preset');
			}
		},

		// Apply a filter preset to the dashboard
		async applyFilterPreset(preset) {
			console.log('Applying filter preset:', preset.name);
			const data = preset.filter_data;

			// Track active preset
			this.activeFilterPresetId = preset.id;
			this.activePresetName = preset.name;

			// Apply filters
			this.searchQuery = data.search || '';
			this.filters.alertmanagers = data.alertmanagers || [];
			this.filters.severities = data.severities || [];
			this.filters.statuses = data.statuses || [];
			this.filters.teams = data.teams || [];
			this.filters.alertNames = data.alert_names || [];
			this.acknowledgmentFilter = data.acknowledged || 'all';
			this.commentsFilter = data.comments || 'all';

			// Apply display settings
			if (data.display_mode) this.displayMode = data.display_mode;
			if (data.view_mode) this.viewMode = data.view_mode;
			if (data.group_by) this.groupByLabel = data.group_by;

			// Apply sorting
			if (data.sort_by) this.sortField = data.sort_by;
			if (data.sort_direction) this.sortDirection = data.sort_direction;

			// Apply pagination
			if (data.items_per_page) this.itemsPerPage = data.items_per_page;

			// Apply column configurations
			if (data.column_configs && Array.isArray(data.column_configs) && data.column_configs.length > 0) {
				this.columns = data.column_configs;
				this.updateVisibleColumns();
				console.log('Applied', data.column_configs.length, 'column configurations from preset');
			}

			// Apply filter-specific hidden alerts
			this.filterHiddenAlerts = data.hidden_alerts || [];
			this.filterHiddenRules = data.hidden_rules || [];
			console.log('Applied', this.filterHiddenAlerts.length, 'filter hidden alerts and', this.filterHiddenRules.length, 'filter hidden rules');

			// Reload dashboard data with new filters
			await this.loadDashboardData();

			// Close modal
			this.showFilterPresetsModal = false;
		},


		// Alias for applyFilterPreset (used by modal buttons)
		async loadPreset(preset) {
			await this.applyFilterPreset(preset);
		},

		// Load preset for editing
		editPreset(preset) {
			this.editingPreset = preset;
			this.newPreset.name = preset.name;
			this.newPreset.description = preset.description;
			this.newPreset.is_shared = preset.is_shared;

			// Load filter-specific hidden alerts from the preset's filter_data
			if (preset.filter_data) {
				this.filterHiddenAlerts = preset.filter_data.hidden_alerts || [];
				this.filterHiddenRules = preset.filter_data.hidden_rules || [];
				console.log('Loaded', this.filterHiddenAlerts.length, 'hidden alerts and', this.filterHiddenRules.length, 'hidden rules for editing');
			} else {
				this.filterHiddenAlerts = [];
				this.filterHiddenRules = [];
			}

			this.activeTab = 'save';
		},

		// Delete a filter preset
		async deletePreset(presetId) {
			if (!confirm('Are you sure you want to delete this filter preset?')) {
				return;
			}

			try {
				const response = await fetch(`/api/v1/dashboard/filter-presets/${presetId}`, {
					method: 'DELETE'
				});

				const data = await response.json();

				if (data.success) {
					alert('Filter preset deleted!');
					await this.loadFilterPresets();
				} else {
					alert('Failed to delete filter preset: ' + data.message);
				}
			} catch (error) {
				console.error('Error deleting filter preset:', error);
				alert('Error deleting filter preset');
			}
		},

		// Set a filter preset as default
		async setDefaultPreset(presetId) {
			try {
				const response = await fetch(`/api/v1/dashboard/filter-presets/${presetId}/default`, {
					method: 'POST'
				});

				const data = await response.json();

				if (data.success) {
					alert('Default filter preset updated!');
					await this.loadFilterPresets();
				} else {
					alert('Failed to set default filter preset: ' + data.message);
				}
			} catch (error) {
				console.error('Error setting default filter preset:', error);
				alert('Error setting default filter preset');
			}
		},

		// Capture current filter state
		captureCurrentFilterState() {
			return {
				search: this.searchQuery,
				alertmanagers: this.filters.alertmanagers,
				severities: this.filters.severities,
				statuses: this.filters.statuses,
				teams: this.filters.teams,
				alert_names: this.filters.alertNames,
				acknowledged: this.acknowledgmentFilter,
				comments: this.commentsFilter,
				display_mode: this.displayMode,
				view_mode: this.viewMode,
				group_by: this.groupByLabel,
				sort_by: this.sortField,
				sort_direction: this.sortDirection,
				items_per_page: this.itemsPerPage,
				column_configs: this.includeColumnConfig ? (this.columns || []) : [],
				// Filter-specific hidden alerts
				hidden_alerts: this.filterHiddenAlerts || [],
				hidden_rules: this.filterHiddenRules || []
			};
		},

		// ========== Filter Hidden Alerts Management ==========

		// Add an alert to filter-specific hidden alerts
		addFilterHiddenAlert(fingerprint, alertName, instance, reason = '') {
			if (!fingerprint) return;

			// Check if already hidden in this filter
			const exists = this.filterHiddenAlerts.some(a => a.fingerprint === fingerprint);
			if (exists) {
				console.log('Alert already hidden in filter:', fingerprint);
				return;
			}

			this.filterHiddenAlerts.push({
				fingerprint: fingerprint,
				alert_name: alertName || '',
				instance: instance || '',
				reason: reason
			});
			console.log('Added alert to filter hidden:', fingerprint);
		},

		// Remove an alert from filter-specific hidden alerts
		removeFilterHiddenAlert(fingerprint) {
			const index = this.filterHiddenAlerts.findIndex(a => a.fingerprint === fingerprint);
			if (index !== -1) {
				this.filterHiddenAlerts.splice(index, 1);
				console.log('Removed alert from filter hidden:', fingerprint);
			}
		},

		// Add a rule to filter-specific hidden rules
		addFilterHiddenRule(rule) {
			if (!rule || !rule.label_key) return;

			this.filterHiddenRules.push({
				name: rule.name || '',
				description: rule.description || '',
				label_key: rule.label_key,
				label_value: rule.label_value || '',
				is_regex: rule.is_regex || false,
				is_enabled: rule.is_enabled !== false // Default to true
			});
			console.log('Added rule to filter hidden:', rule.name);
		},

		// Remove a rule from filter-specific hidden rules
		removeFilterHiddenRule(index) {
			if (index >= 0 && index < this.filterHiddenRules.length) {
				this.filterHiddenRules.splice(index, 1);
				console.log('Removed rule from filter hidden at index:', index);
			}
		},

		// Toggle a filter hidden rule enabled state
		toggleFilterHiddenRule(index) {
			if (index >= 0 && index < this.filterHiddenRules.length) {
				this.filterHiddenRules[index].is_enabled = !this.filterHiddenRules[index].is_enabled;
			}
		},

		// Clear all filter-specific hidden alerts when no filter is active
		clearFilterHiddenState() {
			this.activeFilterPresetId = null;
			this.activePresetName = null;
			this.filterHiddenAlerts = [];
			this.filterHiddenRules = [];
		},

		// Update the active filter preset with current hidden alerts
		async updateActiveFilterPreset() {
			if (!this.activeFilterPresetId) {
				console.error('No active filter preset to update');
				return;
			}

			const preset = this.presets.find(p => p.id === this.activeFilterPresetId);
			if (!preset) {
				console.error('Active filter preset not found');
				return;
			}

			try {
				const filterData = this.captureCurrentFilterState();
				const payload = {
					name: preset.name,
					description: preset.description,
					is_shared: preset.is_shared,
					filter_data: filterData
				};

				const response = await fetch(`/api/v1/dashboard/filter-presets/${preset.id}`, {
					method: 'PUT',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(payload)
				});

				const data = await response.json();
				if (data.success) {
					console.log('Filter preset updated with hidden alerts');
					await this.loadFilterPresets();
				} else {
					console.error('Failed to update filter preset:', data.message);
				}
			} catch (error) {
				console.error('Error updating filter preset:', error);
			}
		},

		// Get filter summary for display
		getFilterSummary() {
			const parts = [];

			if (this.searchQuery) {
				parts.push(`<div><strong>Search:</strong> ${this.searchQuery}</div>`);
			}
			if (this.filters.alertmanagers.length > 0) {
				parts.push(`<div><strong>Alertmanagers:</strong> ${this.filters.alertmanagers.join(', ')}</div>`);
			}
			if (this.filters.severities.length > 0) {
				parts.push(`<div><strong>Severities:</strong> ${this.filters.severities.join(', ')}</div>`);
			}
			if (this.filters.statuses.length > 0) {
				parts.push(`<div><strong>Statuses:</strong> ${this.filters.statuses.join(', ')}</div>`);
			}
			if (this.filters.teams.length > 0) {
				parts.push(`<div><strong>Teams:</strong> ${this.filters.teams.join(', ')}</div>`);
			}
			if (this.filters.alertNames.length > 0) {
				parts.push(`<div><strong>Alert Names:</strong> ${this.filters.alertNames.join(', ')}</div>`);
			}

			parts.push(`<div><strong>Display Mode:</strong> ${this.displayMode}</div>`);
			parts.push(`<div><strong>View Mode:</strong> ${this.viewMode}</div>`);

			if (this.viewMode === 'group') {
				parts.push(`<div><strong>Group By:</strong> ${this.groupByLabel}</div>`);
			}

			parts.push(`<div><strong>Sort:</strong> ${this.sortField} (${this.sortDirection})</div>`);
			parts.push(`<div><strong>Items Per Page:</strong> ${this.itemsPerPage}</div>`);

			// Show filter-specific hidden alerts count
			if (this.filterHiddenAlerts && this.filterHiddenAlerts.length > 0) {
				parts.push(`<div><strong>Filter Hidden Alerts:</strong> ${this.filterHiddenAlerts.length}</div>`);
			}
			if (this.filterHiddenRules && this.filterHiddenRules.length > 0) {
				parts.push(`<div><strong>Filter Hidden Rules:</strong> ${this.filterHiddenRules.length}</div>`);
			}

			return parts.length > 0 ? parts.join('') : '<div>No filters applied</div>';
		},

		// Reset new preset form
		resetNewPresetForm() {
			this.newPreset = {
				name: '',
				description: '',
				is_shared: false
			};
			this.editingPreset = null;
			// Reset filter-specific hidden state when creating a new preset
			// Note: we don't clear filterHiddenAlerts/filterHiddenRules here
			// because the user may want to keep their current hidden state
			// for a new filter they're creating
		},

		// Cancel editing
		cancelEdit() {
			this.resetNewPresetForm();
			this.activeTab = 'list';
		},

		// Format date for display
		formatDate(dateString) {
			const date = new Date(dateString);
			const now = new Date();
			const diffMs = now - date;
			const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

			if (diffDays === 0) return 'today';
			if (diffDays === 1) return 'yesterday';
			if (diffDays < 7) return `${diffDays} days ago`;
			if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
			if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
			return `${Math.floor(diffDays / 365)} years ago`;
		}
	};

	// Filter presets modal data
	function filterPresetsModalData() {
		return {
			presets: [],
			newPreset: {
				name: '',
				description: '',
				is_shared: false
			},
			editingPreset: null,
			activeTab: 'list',

			async init() {
				// Load presets when modal opens
				await this.loadFilterPresets();
			},

			async loadFilterPresets() {
				try {
					const response = await fetch('/api/v1/dashboard/filter-presets?include_shared=true');
					const data = await response.json();

					if (data.success) {
						this.presets = data.presets || [];
					}
				} catch (error) {
					console.error('Error loading filter presets:', error);
				}
			},

			async loadPreset(preset) {
				// Get the dashboard component and apply the preset
				const dashboard = this.$root;
				if (dashboard && dashboard.applyFilterPreset) {
					await dashboard.applyFilterPreset(preset);
				}
			},

			async setDefaultPreset(presetId) {
				const dashboard = this.$root;
				if (dashboard && dashboard.setDefaultPreset) {
					await dashboard.setDefaultPreset(presetId);
				}
			},

			editPreset(preset) {
				const dashboard = this.$root;
				if (dashboard && dashboard.editPreset) {
					dashboard.editPreset(preset);
				}
			},

			async deletePreset(presetId) {
				const dashboard = this.$root;
				if (dashboard && dashboard.deletePreset) {
					await dashboard.deletePreset(presetId);
				}
			},

			async saveNewPreset() {
				const dashboard = this.$root;
				if (dashboard && dashboard.saveNewPreset) {
					await dashboard.saveNewPreset();
				}
			},

			cancelEdit() {
				const dashboard = this.$root;
				if (dashboard && dashboard.cancelEdit) {
					dashboard.cancelEdit();
				}
			},

			getFilterSummary() {
				const dashboard = this.$root;
				if (dashboard && dashboard.getFilterSummary) {
					return dashboard.getFilterSummary();
				}
				return '';
			},

			formatDate(dateString) {
				const date = new Date(dateString);
				const now = new Date();
				const diffMs = now - date;
				const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

				if (diffDays === 0) return 'today';
				if (diffDays === 1) return 'yesterday';
				if (diffDays < 7) return `${diffDays} days ago`;
				if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
				if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
				return `${Math.floor(diffDays / 365)} years ago`;
			}
		};
	}
	</script>
}
