// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

// Filter Presets Mixin
func DashboardFilterPresetsMixin() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script type=\"text/javascript\">\n\t// Filter presets management functions\n\twindow.dashboardFilterPresetsMixin = {\n\t\tpresets: [],\n\t\tnewPreset: {\n\t\t\tname: '',\n\t\t\tdescription: '',\n\t\t\tis_shared: false\n\t\t},\n\t\teditingPreset: null,\n\t\tactiveTab: 'list',\n\n\t\t// Filter-specific hidden alerts state\n\t\tactiveFilterPresetId: null,\n\t\tfilterHiddenAlerts: [],\n\t\tfilterHiddenRules: [],\n\t\tshowFilterHiddenManager: false,\n\t\tnewFilterRule: {\n\t\t\tname: '',\n\t\t\tlabel_key: '',\n\t\t\tlabel_value: '',\n\t\t\tis_regex: false,\n\t\t\tis_enabled: true\n\t\t},\n\n\t\t// Available labels for autocomplete\n\t\tfilterAvailableLabels: {},\n\t\tfilterAvailableLabelsLastLoaded: null,\n\n\t\t// Load available labels for autocomplete\n\t\tasync loadFilterAvailableLabels() {\n\t\t\t// Check if we already have cached labels and they're not too old (cache for 5 minutes)\n\t\t\tif (this.filterAvailableLabels && Object.keys(this.filterAvailableLabels).length > 0 &&\n\t\t\t\tthis.filterAvailableLabelsLastLoaded &&\n\t\t\t\t(Date.now() - this.filterAvailableLabelsLastLoaded) < 300000) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst response = await fetch('/api/v1/dashboard/available-labels', {\n\t\t\t\t\tcredentials: 'include'\n\t\t\t\t});\n\t\t\t\tif (response.ok) {\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.filterAvailableLabels = result.data.labels || {};\n\t\t\t\t\t\tthis.filterAvailableLabelsLastLoaded = Date.now();\n\t\t\t\t\t\tconsole.log('Loaded available labels for filter rules:', Object.keys(this.filterAvailableLabels).length, 'label types');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Error loading available labels:', error);\n\t\t\t}\n\t\t},\n\n\t\t// Ensure labels are loaded (call on focus)\n\t\tensureFilterAvailableLabels() {\n\t\t\tif (!this.filterAvailableLabels || Object.keys(this.filterAvailableLabels).length === 0) {\n\t\t\t\tthis.loadFilterAvailableLabels();\n\t\t\t}\n\t\t},\n\n\t\t// Get available values for a specific label key\n\t\tgetFilterAvailableValues(labelKey) {\n\t\t\tif (!labelKey || !this.filterAvailableLabels) return [];\n\t\t\treturn this.filterAvailableLabels[labelKey] || [];\n\t\t},\n\n\t\t// Load all filter presets\n\t\tasync loadFilterPresets() {\n\t\t\ttry {\n\t\t\t\tconst response = await fetch('/api/v1/dashboard/filter-presets?include_shared=true');\n\t\t\t\tconst data = await response.json();\n\n\t\t\t\tif (data.success) {\n\t\t\t\t\tthis.presets = data.presets || [];\n\t\t\t\t\tconsole.log('Loaded', this.presets.length, 'filter presets');\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('Failed to load filter presets:', data.message);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Error loading filter presets:', error);\n\t\t\t}\n\t\t},\n\n\t\t// Load default filter preset on init\n\t\t// Returns true if a default preset was loaded, false otherwise\n\t\tasync loadDefaultFilterPreset() {\n\t\t\ttry {\n\t\t\t\tconst response = await fetch('/api/v1/dashboard/filter-presets/default');\n\t\t\t\tconst data = await response.json();\n\n\t\t\t\tif (data.success && data.preset) {\n\t\t\t\t\tconsole.log('Loading default filter preset:', data.preset.name);\n\t\t\t\t\tawait this.applyFilterPreset(data.preset);\n\t\t\t\t\t// Track that this is the active default preset\n\t\t\t\t\tthis.activePresetName = data.preset.name;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Error loading default filter preset:', error);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\t// Save new filter preset\n\t\tasync saveNewPreset() {\n\t\t\tif (!this.newPreset.name.trim()) {\n\t\t\t\talert('Please enter a name for the filter preset');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst filterData = this.captureCurrentFilterState();\n\t\t\t\tconst payload = {\n\t\t\t\t\tname: this.newPreset.name.trim(),\n\t\t\t\t\tdescription: this.newPreset.description.trim(),\n\t\t\t\t\tis_shared: this.newPreset.is_shared,\n\t\t\t\t\tfilter_data: filterData\n\t\t\t\t};\n\n\t\t\t\tlet response;\n\t\t\t\tif (this.editingPreset) {\n\t\t\t\t\t// Update existing preset\n\t\t\t\t\tresponse = await fetch(`/api/v1/dashboard/filter-presets/${this.editingPreset.id}`, {\n\t\t\t\t\t\tmethod: 'PUT',\n\t\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\t\tbody: JSON.stringify(payload)\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Create new preset\n\t\t\t\t\tresponse = await fetch('/api/v1/dashboard/filter-presets', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\t\tbody: JSON.stringify(payload)\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst data = await response.json();\n\n\t\t\t\tif (data.success) {\n\t\t\t\t\talert(this.editingPreset ? 'Filter preset updated!' : 'Filter preset saved!');\n\t\t\t\t\tawait this.loadFilterPresets();\n\t\t\t\t\tthis.resetNewPresetForm();\n\t\t\t\t\tthis.activeTab = 'list';\n\t\t\t\t} else {\n\t\t\t\t\talert('Failed to save filter preset: ' + data.message);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Error saving filter preset:', error);\n\t\t\t\talert('Error saving filter preset');\n\t\t\t}\n\t\t},\n\n\t\t// Apply a filter preset to the dashboard\n\t\tasync applyFilterPreset(preset) {\n\t\t\tconsole.log('Applying filter preset:', preset.name);\n\t\t\tconst data = preset.filter_data;\n\n\t\t\t// Track active preset\n\t\t\tthis.activeFilterPresetId = preset.id;\n\t\t\tthis.activePresetName = preset.name;\n\n\t\t\t// Apply filters\n\t\t\tthis.searchQuery = data.search || '';\n\t\t\tthis.filters.alertmanagers = data.alertmanagers || [];\n\t\t\tthis.filters.severities = data.severities || [];\n\t\t\tthis.filters.statuses = data.statuses || [];\n\t\t\tthis.filters.teams = data.teams || [];\n\t\t\tthis.filters.alertNames = data.alert_names || [];\n\t\t\tthis.acknowledgmentFilter = data.acknowledged || 'all';\n\t\t\tthis.commentsFilter = data.comments || 'all';\n\n\t\t\t// Apply display settings\n\t\t\tif (data.display_mode) this.displayMode = data.display_mode;\n\t\t\tif (data.view_mode) this.viewMode = data.view_mode;\n\t\t\tif (data.group_by) this.groupByLabel = data.group_by;\n\n\t\t\t// Apply sorting\n\t\t\tif (data.sort_by) this.sortField = data.sort_by;\n\t\t\tif (data.sort_direction) this.sortDirection = data.sort_direction;\n\n\t\t\t// Apply pagination\n\t\t\tif (data.items_per_page) this.itemsPerPage = data.items_per_page;\n\n\t\t\t// Apply column configurations\n\t\t\tif (data.column_configs && Array.isArray(data.column_configs) && data.column_configs.length > 0) {\n\t\t\t\tthis.columns = data.column_configs;\n\t\t\t\tthis.updateVisibleColumns();\n\t\t\t\tconsole.log('Applied', data.column_configs.length, 'column configurations from preset');\n\t\t\t}\n\n\t\t\t// Apply filter-specific hidden alerts\n\t\t\tthis.filterHiddenAlerts = data.hidden_alerts || [];\n\t\t\tthis.filterHiddenRules = data.hidden_rules || [];\n\t\t\tconsole.log('Applied', this.filterHiddenAlerts.length, 'filter hidden alerts and', this.filterHiddenRules.length, 'filter hidden rules');\n\n\t\t\t// Reload dashboard data with new filters\n\t\t\tawait this.loadDashboardData();\n\n\t\t\t// Close modal\n\t\t\tthis.showFilterPresetsModal = false;\n\t\t},\n\n\n\t\t// Alias for applyFilterPreset (used by modal buttons)\n\t\tasync loadPreset(preset) {\n\t\t\tawait this.applyFilterPreset(preset);\n\t\t},\n\n\t\t// Load preset for editing\n\t\teditPreset(preset) {\n\t\t\tthis.editingPreset = preset;\n\t\t\tthis.newPreset.name = preset.name;\n\t\t\tthis.newPreset.description = preset.description;\n\t\t\tthis.newPreset.is_shared = preset.is_shared;\n\n\t\t\t// Load filter-specific hidden alerts from the preset's filter_data\n\t\t\tif (preset.filter_data) {\n\t\t\t\tthis.filterHiddenAlerts = preset.filter_data.hidden_alerts || [];\n\t\t\t\tthis.filterHiddenRules = preset.filter_data.hidden_rules || [];\n\t\t\t\tconsole.log('Loaded', this.filterHiddenAlerts.length, 'hidden alerts and', this.filterHiddenRules.length, 'hidden rules for editing');\n\t\t\t} else {\n\t\t\t\tthis.filterHiddenAlerts = [];\n\t\t\t\tthis.filterHiddenRules = [];\n\t\t\t}\n\n\t\t\tthis.activeTab = 'save';\n\t\t},\n\n\t\t// Delete a filter preset\n\t\tasync deletePreset(presetId) {\n\t\t\tif (!confirm('Are you sure you want to delete this filter preset?')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst response = await fetch(`/api/v1/dashboard/filter-presets/${presetId}`, {\n\t\t\t\t\tmethod: 'DELETE'\n\t\t\t\t});\n\n\t\t\t\tconst data = await response.json();\n\n\t\t\t\tif (data.success) {\n\t\t\t\t\talert('Filter preset deleted!');\n\t\t\t\t\tawait this.loadFilterPresets();\n\t\t\t\t} else {\n\t\t\t\t\talert('Failed to delete filter preset: ' + data.message);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Error deleting filter preset:', error);\n\t\t\t\talert('Error deleting filter preset');\n\t\t\t}\n\t\t},\n\n\t\t// Set a filter preset as default\n\t\tasync setDefaultPreset(presetId) {\n\t\t\ttry {\n\t\t\t\tconst response = await fetch(`/api/v1/dashboard/filter-presets/${presetId}/default`, {\n\t\t\t\t\tmethod: 'POST'\n\t\t\t\t});\n\n\t\t\t\tconst data = await response.json();\n\n\t\t\t\tif (data.success) {\n\t\t\t\t\talert('Default filter preset updated!');\n\t\t\t\t\tawait this.loadFilterPresets();\n\t\t\t\t} else {\n\t\t\t\t\talert('Failed to set default filter preset: ' + data.message);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Error setting default filter preset:', error);\n\t\t\t\talert('Error setting default filter preset');\n\t\t\t}\n\t\t},\n\n\t\t// Capture current filter state\n\t\tcaptureCurrentFilterState() {\n\t\t\treturn {\n\t\t\t\tsearch: this.searchQuery,\n\t\t\t\talertmanagers: this.filters.alertmanagers,\n\t\t\t\tseverities: this.filters.severities,\n\t\t\t\tstatuses: this.filters.statuses,\n\t\t\t\tteams: this.filters.teams,\n\t\t\t\talert_names: this.filters.alertNames,\n\t\t\t\tacknowledged: this.acknowledgmentFilter,\n\t\t\t\tcomments: this.commentsFilter,\n\t\t\t\tdisplay_mode: this.displayMode,\n\t\t\t\tview_mode: this.viewMode,\n\t\t\t\tgroup_by: this.groupByLabel,\n\t\t\t\tsort_by: this.sortField,\n\t\t\t\tsort_direction: this.sortDirection,\n\t\t\t\titems_per_page: this.itemsPerPage,\n\t\t\t\tcolumn_configs: this.includeColumnConfig ? (this.columns || []) : [],\n\t\t\t\t// Filter-specific hidden alerts\n\t\t\t\thidden_alerts: this.filterHiddenAlerts || [],\n\t\t\t\thidden_rules: this.filterHiddenRules || []\n\t\t\t};\n\t\t},\n\n\t\t// ========== Filter Hidden Alerts Management ==========\n\n\t\t// Add an alert to filter-specific hidden alerts\n\t\taddFilterHiddenAlert(fingerprint, alertName, instance, reason = '') {\n\t\t\tif (!fingerprint) return;\n\n\t\t\t// Check if already hidden in this filter\n\t\t\tconst exists = this.filterHiddenAlerts.some(a => a.fingerprint === fingerprint);\n\t\t\tif (exists) {\n\t\t\t\tconsole.log('Alert already hidden in filter:', fingerprint);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.filterHiddenAlerts.push({\n\t\t\t\tfingerprint: fingerprint,\n\t\t\t\talert_name: alertName || '',\n\t\t\t\tinstance: instance || '',\n\t\t\t\treason: reason\n\t\t\t});\n\t\t\tconsole.log('Added alert to filter hidden:', fingerprint);\n\t\t},\n\n\t\t// Remove an alert from filter-specific hidden alerts\n\t\tremoveFilterHiddenAlert(fingerprint) {\n\t\t\tconst index = this.filterHiddenAlerts.findIndex(a => a.fingerprint === fingerprint);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.filterHiddenAlerts.splice(index, 1);\n\t\t\t\tconsole.log('Removed alert from filter hidden:', fingerprint);\n\t\t\t}\n\t\t},\n\n\t\t// Add a rule to filter-specific hidden rules\n\t\taddFilterHiddenRule(rule) {\n\t\t\tif (!rule || !rule.label_key) return;\n\n\t\t\tthis.filterHiddenRules.push({\n\t\t\t\tname: rule.name || '',\n\t\t\t\tdescription: rule.description || '',\n\t\t\t\tlabel_key: rule.label_key,\n\t\t\t\tlabel_value: rule.label_value || '',\n\t\t\t\tis_regex: rule.is_regex || false,\n\t\t\t\tis_enabled: rule.is_enabled !== false // Default to true\n\t\t\t});\n\t\t\tconsole.log('Added rule to filter hidden:', rule.name);\n\t\t},\n\n\t\t// Remove a rule from filter-specific hidden rules\n\t\tremoveFilterHiddenRule(index) {\n\t\t\tif (index >= 0 && index < this.filterHiddenRules.length) {\n\t\t\t\tthis.filterHiddenRules.splice(index, 1);\n\t\t\t\tconsole.log('Removed rule from filter hidden at index:', index);\n\t\t\t}\n\t\t},\n\n\t\t// Toggle a filter hidden rule enabled state\n\t\ttoggleFilterHiddenRule(index) {\n\t\t\tif (index >= 0 && index < this.filterHiddenRules.length) {\n\t\t\t\tthis.filterHiddenRules[index].is_enabled = !this.filterHiddenRules[index].is_enabled;\n\t\t\t}\n\t\t},\n\n\t\t// Clear all filter-specific hidden alerts when no filter is active\n\t\tclearFilterHiddenState() {\n\t\t\tthis.activeFilterPresetId = null;\n\t\t\tthis.activePresetName = null;\n\t\t\tthis.filterHiddenAlerts = [];\n\t\t\tthis.filterHiddenRules = [];\n\t\t},\n\n\t\t// Update the active filter preset with current hidden alerts\n\t\tasync updateActiveFilterPreset() {\n\t\t\tif (!this.activeFilterPresetId) {\n\t\t\t\tconsole.error('No active filter preset to update');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst preset = this.presets.find(p => p.id === this.activeFilterPresetId);\n\t\t\tif (!preset) {\n\t\t\t\tconsole.error('Active filter preset not found');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst filterData = this.captureCurrentFilterState();\n\t\t\t\tconst payload = {\n\t\t\t\t\tname: preset.name,\n\t\t\t\t\tdescription: preset.description,\n\t\t\t\t\tis_shared: preset.is_shared,\n\t\t\t\t\tfilter_data: filterData\n\t\t\t\t};\n\n\t\t\t\tconst response = await fetch(`/api/v1/dashboard/filter-presets/${preset.id}`, {\n\t\t\t\t\tmethod: 'PUT',\n\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\tbody: JSON.stringify(payload)\n\t\t\t\t});\n\n\t\t\t\tconst data = await response.json();\n\t\t\t\tif (data.success) {\n\t\t\t\t\tconsole.log('Filter preset updated with hidden alerts');\n\t\t\t\t\tawait this.loadFilterPresets();\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('Failed to update filter preset:', data.message);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Error updating filter preset:', error);\n\t\t\t}\n\t\t},\n\n\t\t// Get filter summary for display\n\t\tgetFilterSummary() {\n\t\t\tconst parts = [];\n\n\t\t\tif (this.searchQuery) {\n\t\t\t\tparts.push(`<div><strong>Search:</strong> ${this.searchQuery}</div>`);\n\t\t\t}\n\t\t\tif (this.filters.alertmanagers.length > 0) {\n\t\t\t\tparts.push(`<div><strong>Alertmanagers:</strong> ${this.filters.alertmanagers.join(', ')}</div>`);\n\t\t\t}\n\t\t\tif (this.filters.severities.length > 0) {\n\t\t\t\tparts.push(`<div><strong>Severities:</strong> ${this.filters.severities.join(', ')}</div>`);\n\t\t\t}\n\t\t\tif (this.filters.statuses.length > 0) {\n\t\t\t\tparts.push(`<div><strong>Statuses:</strong> ${this.filters.statuses.join(', ')}</div>`);\n\t\t\t}\n\t\t\tif (this.filters.teams.length > 0) {\n\t\t\t\tparts.push(`<div><strong>Teams:</strong> ${this.filters.teams.join(', ')}</div>`);\n\t\t\t}\n\t\t\tif (this.filters.alertNames.length > 0) {\n\t\t\t\tparts.push(`<div><strong>Alert Names:</strong> ${this.filters.alertNames.join(', ')}</div>`);\n\t\t\t}\n\n\t\t\tparts.push(`<div><strong>Display Mode:</strong> ${this.displayMode}</div>`);\n\t\t\tparts.push(`<div><strong>View Mode:</strong> ${this.viewMode}</div>`);\n\n\t\t\tif (this.viewMode === 'group') {\n\t\t\t\tparts.push(`<div><strong>Group By:</strong> ${this.groupByLabel}</div>`);\n\t\t\t}\n\n\t\t\tparts.push(`<div><strong>Sort:</strong> ${this.sortField} (${this.sortDirection})</div>`);\n\t\t\tparts.push(`<div><strong>Items Per Page:</strong> ${this.itemsPerPage}</div>`);\n\n\t\t\t// Show filter-specific hidden alerts count\n\t\t\tif (this.filterHiddenAlerts && this.filterHiddenAlerts.length > 0) {\n\t\t\t\tparts.push(`<div><strong>Filter Hidden Alerts:</strong> ${this.filterHiddenAlerts.length}</div>`);\n\t\t\t}\n\t\t\tif (this.filterHiddenRules && this.filterHiddenRules.length > 0) {\n\t\t\t\tparts.push(`<div><strong>Filter Hidden Rules:</strong> ${this.filterHiddenRules.length}</div>`);\n\t\t\t}\n\n\t\t\treturn parts.length > 0 ? parts.join('') : '<div>No filters applied</div>';\n\t\t},\n\n\t\t// Reset new preset form\n\t\tresetNewPresetForm() {\n\t\t\tthis.newPreset = {\n\t\t\t\tname: '',\n\t\t\t\tdescription: '',\n\t\t\t\tis_shared: false\n\t\t\t};\n\t\t\tthis.editingPreset = null;\n\t\t\t// Reset filter-specific hidden state when creating a new preset\n\t\t\t// Note: we don't clear filterHiddenAlerts/filterHiddenRules here\n\t\t\t// because the user may want to keep their current hidden state\n\t\t\t// for a new filter they're creating\n\t\t},\n\n\t\t// Cancel editing\n\t\tcancelEdit() {\n\t\t\tthis.resetNewPresetForm();\n\t\t\tthis.activeTab = 'list';\n\t\t},\n\n\t\t// Format date for display\n\t\tformatDate(dateString) {\n\t\t\tconst date = new Date(dateString);\n\t\t\tconst now = new Date();\n\t\t\tconst diffMs = now - date;\n\t\t\tconst diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\n\n\t\t\tif (diffDays === 0) return 'today';\n\t\t\tif (diffDays === 1) return 'yesterday';\n\t\t\tif (diffDays < 7) return `${diffDays} days ago`;\n\t\t\tif (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;\n\t\t\tif (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;\n\t\t\treturn `${Math.floor(diffDays / 365)} years ago`;\n\t\t}\n\t};\n\n\t// Filter presets modal data\n\tfunction filterPresetsModalData() {\n\t\treturn {\n\t\t\tpresets: [],\n\t\t\tnewPreset: {\n\t\t\t\tname: '',\n\t\t\t\tdescription: '',\n\t\t\t\tis_shared: false\n\t\t\t},\n\t\t\teditingPreset: null,\n\t\t\tactiveTab: 'list',\n\n\t\t\tasync init() {\n\t\t\t\t// Load presets when modal opens\n\t\t\t\tawait this.loadFilterPresets();\n\t\t\t},\n\n\t\t\tasync loadFilterPresets() {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/filter-presets?include_shared=true');\n\t\t\t\t\tconst data = await response.json();\n\n\t\t\t\t\tif (data.success) {\n\t\t\t\t\t\tthis.presets = data.presets || [];\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error loading filter presets:', error);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync loadPreset(preset) {\n\t\t\t\t// Get the dashboard component and apply the preset\n\t\t\t\tconst dashboard = this.$root;\n\t\t\t\tif (dashboard && dashboard.applyFilterPreset) {\n\t\t\t\t\tawait dashboard.applyFilterPreset(preset);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync setDefaultPreset(presetId) {\n\t\t\t\tconst dashboard = this.$root;\n\t\t\t\tif (dashboard && dashboard.setDefaultPreset) {\n\t\t\t\t\tawait dashboard.setDefaultPreset(presetId);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\teditPreset(preset) {\n\t\t\t\tconst dashboard = this.$root;\n\t\t\t\tif (dashboard && dashboard.editPreset) {\n\t\t\t\t\tdashboard.editPreset(preset);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync deletePreset(presetId) {\n\t\t\t\tconst dashboard = this.$root;\n\t\t\t\tif (dashboard && dashboard.deletePreset) {\n\t\t\t\t\tawait dashboard.deletePreset(presetId);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync saveNewPreset() {\n\t\t\t\tconst dashboard = this.$root;\n\t\t\t\tif (dashboard && dashboard.saveNewPreset) {\n\t\t\t\t\tawait dashboard.saveNewPreset();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcancelEdit() {\n\t\t\t\tconst dashboard = this.$root;\n\t\t\t\tif (dashboard && dashboard.cancelEdit) {\n\t\t\t\t\tdashboard.cancelEdit();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tgetFilterSummary() {\n\t\t\t\tconst dashboard = this.$root;\n\t\t\t\tif (dashboard && dashboard.getFilterSummary) {\n\t\t\t\t\treturn dashboard.getFilterSummary();\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t},\n\n\t\t\tformatDate(dateString) {\n\t\t\t\tconst date = new Date(dateString);\n\t\t\t\tconst now = new Date();\n\t\t\t\tconst diffMs = now - date;\n\t\t\t\tconst diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\n\n\t\t\t\tif (diffDays === 0) return 'today';\n\t\t\t\tif (diffDays === 1) return 'yesterday';\n\t\t\t\tif (diffDays < 7) return `${diffDays} days ago`;\n\t\t\t\tif (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;\n\t\t\t\tif (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;\n\t\t\t\treturn `${Math.floor(diffDays / 365)} years ago`;\n\t\t\t}\n\t\t};\n\t}\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
