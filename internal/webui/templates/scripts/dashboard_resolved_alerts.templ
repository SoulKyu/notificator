package scripts

templ DashboardResolvedAlertsMixin() {
	<script>
		window.dashboardResolvedAlertsMixin = {
			// State (will be merged into dashboard)
			resolvedAlerts: [],
			resolvedTotalCount: 0,
			resolvedLoading: false,
			resolvedAutoLoadEnabled: true, // Enable auto-load on view switch

			// Time range for resolved alerts (separate from main filters)
			resolvedTimeRange: {
				start: '', // datetime-local format
				end: '',   // datetime-local format
				preset: null // Track which preset button is active (hours value or null for custom)
			},

			// Include silenced alerts in results (default: false - exclude silenced)
			resolvedIncludeSilenced: false,

			// Pagination for resolved alerts
			resolvedPagination: {
				limit: 100,
				offset: 0
			},

			// Sorting for resolved alerts
			resolvedSortField: 'last_resolved_at',  // Default sort by last resolved
			resolvedSortDirection: 'desc',          // Most recent first

			// State for resolved alert details modal (occurrence history)
			resolvedAlertOccurrences: [],
			resolvedAlertTotalOccurrences: 0,

			// Watch for display mode changes and auto-load
			initResolvedAutoLoad() {
				this.$watch('displayMode', (newMode, oldMode) => {
					if (newMode === 'resolved' && oldMode !== 'resolved' && this.resolvedAutoLoadEnabled) {
						// Auto-load when switching to resolved view
						if (this.resolvedAlerts.length === 0 || !this.resolvedTimeRange.start) {
							this.initResolvedTimeRange();
							this.loadResolvedAlerts();
						}
					}
				});
			},

			// Initialize time range on component init
			initResolvedTimeRange() {
				const now = new Date();
				const oneDayAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));

				// Format for datetime-local input (YYYY-MM-DDTHH:mm)
				this.resolvedTimeRange.end = this.formatDateTimeLocal(now);
				this.resolvedTimeRange.start = this.formatDateTimeLocal(oneDayAgo);
				this.resolvedTimeRange.preset = 24; // Mark 24h preset as active
			},

			// Format date for datetime-local input
			formatDateTimeLocal(date) {
				const year = date.getFullYear();
				const month = String(date.getMonth() + 1).padStart(2, '0');
				const day = String(date.getDate()).padStart(2, '0');
				const hours = String(date.getHours()).padStart(2, '0');
				const minutes = String(date.getMinutes()).padStart(2, '0');
				return `${year}-${month}-${day}T${hours}:${minutes}`;
			},

			// Set time range with preset (hours from now)
			async setResolvedTimeRange(hours) {
				const now = new Date();
				const startDate = new Date(now.getTime() - (hours * 60 * 60 * 1000));

				this.resolvedTimeRange.start = this.formatDateTimeLocal(startDate);
				this.resolvedTimeRange.end = this.formatDateTimeLocal(now);
				this.resolvedTimeRange.preset = hours; // Track which preset is active

				this.resolvedPagination.offset = 0; // Reset pagination
				await this.loadResolvedAlerts();
			},

			// Apply time range change and reload (called when manually changing dates)
			async applyResolvedTimeRange() {
				// Clear preset indicator when manually changing dates
				this.resolvedTimeRange.preset = null;
				this.resolvedPagination.offset = 0; // Reset pagination
				await this.loadResolvedAlerts();
			},

			// Count active filters relevant to resolved alerts view
			// Only counts filters that actually affect the resolved alerts query
			getActiveFiltersCount() {
				let count = 0;
				// These filters ARE used in resolved alerts query
				if (this.filters.severities && this.filters.severities.length > 0) count++;
				if (this.filters.teams && this.filters.teams.length > 0) count++;
				if (this.filters.alertNames && this.filters.alertNames.length > 0) count++;
				if (this.searchQuery && this.searchQuery.trim().length > 0) count++;
				// Note: alertmanagers, statuses, acknowledgmentFilter, commentsFilter
				// are NOT used in the resolved alerts query (statistics endpoint)
				return count;
			},

			// Load recently resolved alerts using main dashboard filters + time range
			async loadResolvedAlerts() {
				// Initialize time range if not set
				if (!this.resolvedTimeRange.start || !this.resolvedTimeRange.end) {
					this.initResolvedTimeRange();
				}

				this.resolvedLoading = true;

				try {
					// Parse datetime-local to ISO string
					const startDate = new Date(this.resolvedTimeRange.start);
					const endDate = new Date(this.resolvedTimeRange.end);


					// Build request using main dashboard filters
					const requestBody = {
						start_date: startDate.toISOString(),
						end_date: endDate.toISOString(),
						severity: this.filters.severities || [],
						teams: this.filters.teams || [],
						alert_names: this.filters.alertNames || [],
						search_query: this.searchQuery || '',
						include_silenced: true, // Always fetch all, we filter client-side with live status
						limit: this.resolvedPagination.limit,
						offset: this.resolvedPagination.offset
					};

					console.log('Loading resolved alerts with filters:', requestBody);

					const response = await fetch('/api/v1/statistics/recently-resolved', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(requestBody)
					});

					const data = await response.json();

					if (data.success && data.data) {
						let alerts = data.data.alerts || [];
						this.resolvedTotalCount = data.data.total_count || 0;
						console.log(`Loaded ${alerts.length} unique fingerprints (${this.resolvedTotalCount} total)`);

						// Fetch live status for all alerts to get accurate silenced state
						if (alerts.length > 0) {
							const fingerprints = alerts.map(a => a.fingerprint);
							const statusResponse = await fetch('/api/v1/dashboard/alerts/bulk-status', {
								method: 'POST',
								credentials: 'include',
								headers: { 'Content-Type': 'application/json' },
								body: JSON.stringify({ fingerprints })
							});

							const statusData = await statusResponse.json();

							if (statusData.success && statusData.data?.statuses) {
								// Enrich alerts with live status
								alerts = alerts.map(alert => {
									const liveStatus = statusData.data.statuses[alert.fingerprint];
									if (liveStatus) {
										alert.live_status = liveStatus;
									}
									return alert;
								});

								// Filter out currently silenced alerts if not including silenced
								if (!this.resolvedIncludeSilenced) {
									const beforeCount = alerts.length;
									alerts = alerts.filter(alert => {
										const liveStatus = alert.live_status;
										// Keep alert if:
										// - Not in cache (fully resolved, can't be silenced)
										// - In cache but not suppressed
										if (!liveStatus || !liveStatus.in_cache) {
											return true;
										}
										return liveStatus.state !== 'suppressed';
									});
									const filteredCount = beforeCount - alerts.length;
									if (filteredCount > 0) {
										console.log(`Filtered out ${filteredCount} currently silenced alerts`);
										this.resolvedTotalCount -= filteredCount;
									}
								}
							}
						}

						this.resolvedAlerts = alerts;
						console.log('Sample alert:', this.resolvedAlerts[0]);

						// Load colors for resolved alerts
						await this.loadResolvedAlertColors();
					} else {
						console.error('Failed to load resolved alerts:', data.message || 'Unknown error');
						this.resolvedAlerts = [];
						this.resolvedTotalCount = 0;
					}
				} catch (error) {
					console.error('Error loading resolved alerts:', error);
					this.resolvedAlerts = [];
					this.resolvedTotalCount = 0;
				} finally {
					this.resolvedLoading = false;
				}
			},

			// Pagination
			async loadResolvedPage(offset) {
				this.resolvedPagination.offset = offset;
				await this.loadResolvedAlerts();
			},

			// Format duration for display
			formatResolvedDuration(seconds) {
				if (!seconds || seconds === 0) return '0s';

				const hours = Math.floor(seconds / 3600);
				const minutes = Math.floor((seconds % 3600) / 60);
				const secs = seconds % 60;

				const parts = [];
				if (hours > 0) parts.push(`${hours}h`);
				if (minutes > 0) parts.push(`${minutes}m`);
				if (secs > 0 || parts.length === 0) parts.push(`${secs}s`);

				return parts.join(' ');
			},

			// Get severity badge class
			getResolvedSeverityClass(severity) {
				const classes = {
					'critical': 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-400',
					'warning': 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-400',
					'info': 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-400'
				};
				return classes[severity.toLowerCase()] || 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
			},

			// Show alert details from resolved tab
			// Uses dedicated statistics endpoint since resolved alerts are not in the live cache
			// Also checks live cache for current status (in case alert is still firing/silenced)
			async showResolvedAlertDetails(alert) {
				this.alertDetailsLoading = true;
				this.showAlertModal = true;
				this.currentAlertTab = 'overview';
				this.alertDetails = null;

				const fingerprint = alert.fingerprint;
				const currentPath = window.location.pathname;
				const newPath = `/dashboard/alert/${fingerprint}`;
				if (currentPath !== newPath) {
					window.history.pushState({ alertId: fingerprint }, '', newPath);
				}

				try {
					// Fetch both statistics data and live status in parallel
					const [statsResponse, statusResponse] = await Promise.all([
						fetch(`/api/v1/statistics/alert/${fingerprint}`, {
							credentials: 'include'
						}),
						fetch('/api/v1/dashboard/alerts/bulk-status', {
							method: 'POST',
							credentials: 'include',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({ fingerprints: [fingerprint] })
						})
					]);

					// Check for authentication errors
					if (window.dashboardInstance && window.dashboardInstance.handleAuthError(statsResponse)) {
						return;
					}

					const statsResult = await statsResponse.json();
					const statusResult = await statusResponse.json();

					if (statsResult.success && statsResult.data) {
						// Map the response to expected alertDetails structure
						this.alertDetails = statsResult.data.details;
						// Store occurrences for the history tab
						this.resolvedAlertOccurrences = statsResult.data.occurrences || [];
						this.resolvedAlertTotalOccurrences = statsResult.data.total_occurrences || 0;

						// Update status from live cache if available
						if (statusResult.success && statusResult.data?.statuses?.[fingerprint]) {
							const liveStatus = statusResult.data.statuses[fingerprint];
							if (liveStatus.in_cache) {
								// Alert is still in live cache - use live status
								this.alertDetails.alert.status = {
									state: liveStatus.state,
									silencedBy: liveStatus.silenced_by || [],
									inhibitedBy: liveStatus.inhibited_by || []
								};
								this.alertDetails.alert.isResolved = liveStatus.is_resolved;
							} else {
								// Alert not in live cache - mark as fully resolved
								this.alertDetails.alert.status = {
									state: 'resolved',
									silencedBy: [],
									inhibitedBy: []
								};
								this.alertDetails.alert.isResolved = true;
							}
						}
					} else {
						console.error('Failed to load resolved alert details:', statsResult.error || 'Unknown error');
						this.closeAlertModal();
					}
				} catch (error) {
					console.error('Error loading resolved alert details:', error);
					this.closeAlertModal();
				} finally {
					this.alertDetailsLoading = false;
				}
			},

			// Toggle sort for resolved alerts table
			sortResolvedAlerts(field) {
				if (this.resolvedSortField === field) {
					// Toggle direction if clicking same field
					this.resolvedSortDirection = this.resolvedSortDirection === 'asc' ? 'desc' : 'asc';
				} else {
					// New field - default to ascending
					this.resolvedSortField = field;
					this.resolvedSortDirection = 'asc';
				}
			},

			// Get sorted resolved alerts
			getSortedResolvedAlerts() {
				if (!this.resolvedAlerts || this.resolvedAlerts.length === 0) {
					return [];
				}

				const sorted = [...this.resolvedAlerts];
				const field = this.resolvedSortField;
				const direction = this.resolvedSortDirection;

				sorted.sort((a, b) => {
					let aVal = a[field];
					let bVal = b[field];

					// Handle null/undefined values
					if (aVal === null || aVal === undefined) aVal = '';
					if (bVal === null || bVal === undefined) bVal = '';

					// Special handling for different data types
					if (field === 'occurrence_count' || field === 'avg_duration' ||
					    field === 'avg_mttr' || field === 'total_duration' || field === 'total_mttr') {
						// Numeric comparison
						aVal = parseFloat(aVal) || 0;
						bVal = parseFloat(bVal) || 0;
					} else if (field === 'first_fired_at' || field === 'last_resolved_at') {
						// Date comparison
						aVal = new Date(aVal).getTime();
						bVal = new Date(bVal).getTime();
					} else {
						// String comparison (case-insensitive)
						aVal = String(aVal).toLowerCase();
						bVal = String(bVal).toLowerCase();
					}

					if (aVal < bVal) return direction === 'asc' ? -1 : 1;
					if (aVal > bVal) return direction === 'asc' ? 1 : -1;
					return 0;
				});

				return sorted;
			},

			// Calculate statistics from resolved alerts
			calculateResolvedStatistics() {
				if (!this.resolvedAlerts || this.resolvedAlerts.length === 0) {
					return {
						totalResolved: 0,
						totalOccurrences: 0,
						avgMTTR: 0,
						avgDuration: 0,
						mostFrequent: null,
						fastestResolution: null,
						severityBreakdown: { critical: 0, warning: 0, info: 0 }
					};
				}

				let totalOccurrences = 0;
				let totalDuration = 0;
				let totalMTTR = 0;
				const severityBreakdown = { critical: 0, warning: 0, info: 0 };
				let fastestResolution = null;
				let mostFrequent = null;

				this.resolvedAlerts.forEach(alert => {
					// Count occurrences
					const occurrences = alert.occurrence_count || 1;
					totalOccurrences += occurrences;

					// Sum durations
					if (alert.avg_duration) {
						totalDuration += alert.avg_duration;
					}

					// Sum MTTR
					if (alert.avg_mttr) {
						totalMTTR += alert.avg_mttr;
					}

					// Count by severity
					const severity = (alert.severity || 'info').toLowerCase();
					if (severity === 'critical' || severity === 'critical-daytime') {
						severityBreakdown.critical += occurrences;
					} else if (severity === 'warning') {
						severityBreakdown.warning += occurrences;
					} else {
						severityBreakdown.info += occurrences;
					}

					// Find most frequent
					if (!mostFrequent || occurrences > mostFrequent.occurrences) {
						mostFrequent = alert;
					}

					// Find fastest resolution
					if (alert.avg_mttr && (!fastestResolution || alert.avg_mttr < fastestResolution.avg_mttr)) {
						fastestResolution = alert;
					}
				});

				const alertCount = this.resolvedAlerts.length;

				return {
					totalResolved: alertCount,
					totalOccurrences: totalOccurrences,
					avgMTTR: alertCount > 0 ? totalMTTR / alertCount : 0,
					avgDuration: alertCount > 0 ? totalDuration / alertCount : 0,
					mostFrequent: mostFrequent,
					fastestResolution: fastestResolution,
					severityBreakdown: severityBreakdown
				};
			},

			// Format duration in seconds to human-readable string
			formatDurationHuman(seconds) {
				if (!seconds || seconds < 0) return '0s';

				const hours = Math.floor(seconds / 3600);
				const minutes = Math.floor((seconds % 3600) / 60);
				const secs = Math.floor(seconds % 60);

				if (hours > 0) {
					return `${hours}h ${minutes}m`;
				} else if (minutes > 0) {
					return `${minutes}m ${secs}s`;
				} else {
					return `${secs}s`;
				}
			},

			// Format large numbers with K/M suffix
			formatNumber(num) {
				if (!num || num < 0) return '0';
				if (num >= 1000000) {
					return (num / 1000000).toFixed(1) + 'M';
				} else if (num >= 1000) {
					return (num / 1000).toFixed(1) + 'K';
				}
				return num.toString();
			},

			// Export resolved alerts to CSV
			exportResolvedAlertsCSV() {
				if (!this.resolvedAlerts || this.resolvedAlerts.length === 0) {
					alert('No data to export');
					return;
				}

				// CSV Header
				let csv = 'Fingerprint,Alert Name,Severity,Occurrences,First Fired At,Last Resolved At,Avg Duration (s),Total Duration (s),Avg MTTR (s),Total MTTR (s),Team,Source\n';

				// CSV Data rows
				this.resolvedAlerts.forEach(alert => {
					const row = [
						`"${alert.fingerprint || ''}"`,
						`"${(alert.alert_name || '').replace(/"/g, '""')}"`, // Escape quotes
						`"${alert.severity || ''}"`,
						alert.occurrence_count || 0,
						`"${alert.first_fired_at || ''}"`,
						`"${alert.last_resolved_at || ''}"`,
						alert.avg_duration || 0,
						alert.total_duration || 0,
						alert.avg_mttr || 0,
						alert.total_mttr || 0,
						`"${(alert.team || '').replace(/"/g, '""')}"`,
						`"${(alert.source || '').replace(/"/g, '""')}"`
					];
					csv += row.join(',') + '\n';
				});

				// Download CSV
				const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
				const url = window.URL.createObjectURL(blob);
				const link = document.createElement('a');
				link.href = url;

				// Generate filename with date range
				const startDate = new Date(this.resolvedTimeRange.start).toISOString().split('T')[0];
				const endDate = new Date(this.resolvedTimeRange.end).toISOString().split('T')[0];
				link.download = `resolved-alerts-${startDate}-to-${endDate}.csv`;

				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				window.URL.revokeObjectURL(url);
			},

			// Export resolved alerts to JSON
			exportResolvedAlertsJSON() {
				if (!this.resolvedAlerts || this.resolvedAlerts.length === 0) {
					alert('No data to export');
					return;
				}

				// Create export object with metadata
				const exportData = {
					exported_at: new Date().toISOString(),
					time_range: {
						start: new Date(this.resolvedTimeRange.start).toISOString(),
						end: new Date(this.resolvedTimeRange.end).toISOString()
					},
					filters: {
						severities: this.filters.severities || [],
						teams: this.filters.teams || [],
						alert_names: this.filters.alertNames || [],
						search_query: this.searchQuery || '',
						include_silenced: this.resolvedIncludeSilenced
					},
					total_count: this.resolvedTotalCount,
					displayed_count: this.resolvedAlerts.length,
					alerts: this.resolvedAlerts
				};

				// Download JSON
				const jsonStr = JSON.stringify(exportData, null, 2);
				const blob = new Blob([jsonStr], { type: 'application/json' });
				const url = window.URL.createObjectURL(blob);
				const link = document.createElement('a');
				link.href = url;

				// Generate filename with date range
				const startDate = new Date(this.resolvedTimeRange.start).toISOString().split('T')[0];
				const endDate = new Date(this.resolvedTimeRange.end).toISOString().split('T')[0];
				link.download = `resolved-alerts-${startDate}-to-${endDate}.json`;

				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				window.URL.revokeObjectURL(url);
			},

			// Load colors for resolved alerts using bulk endpoint
			// This sends the alert labels directly since resolved alerts come from statistics DB
			async loadResolvedAlertColors() {
				if (!this.resolvedAlerts || this.resolvedAlerts.length === 0) {
					return;
				}

				try {
					console.log('Loading colors for resolved alerts...');

					// Build alerts array with fingerprints and labels
					const alertsData = this.resolvedAlerts.map(alert => ({
						fingerprint: alert.fingerprint,
						labels: alert.labels || {}
					}));

					const response = await fetch('/api/v1/dashboard/alerts/bulk-colors', {
						method: 'POST',
						credentials: 'include',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ alerts: alertsData })
					});

					if (response.ok) {
						const result = await response.json();
						if (result.success && result.data && result.data.colors) {
							// Merge colors into alertColors object
							Object.assign(this.alertColors, result.data.colors);
							console.log(`Loaded colors for ${Object.keys(result.data.colors).length} resolved alerts`);
						}
					}
				} catch (error) {
					console.error('Error loading resolved alert colors:', error);
				}
			}
		};
	</script>
}
