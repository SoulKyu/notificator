package scripts

templ DashboardResolvedAlertsMixin() {
	<script>
		window.dashboardResolvedAlertsMixin = {
			// State (will be merged into dashboard)
			resolvedAlerts: [],
			resolvedTotalCount: 0,
			resolvedLoading: false,
			resolvedAutoLoadEnabled: true, // Enable auto-load on view switch

			// Time range for resolved alerts (separate from main filters)
			resolvedTimeRange: {
				start: '', // datetime-local format
				end: '',   // datetime-local format
				preset: null // Track which preset button is active (hours value or null for custom)
			},

			// Include silenced alerts in results (default: false - exclude silenced)
			resolvedIncludeSilenced: false,

			// Pagination for resolved alerts
			resolvedPagination: {
				limit: 100,
				offset: 0
			},

			// Sorting for resolved alerts
			resolvedSortField: 'last_resolved_at',  // Default sort by last resolved
			resolvedSortDirection: 'desc',          // Most recent first

			// Watch for display mode changes and auto-load
			initResolvedAutoLoad() {
				this.$watch('displayMode', (newMode, oldMode) => {
					if (newMode === 'resolved' && oldMode !== 'resolved' && this.resolvedAutoLoadEnabled) {
						// Auto-load when switching to resolved view
						if (this.resolvedAlerts.length === 0 || !this.resolvedTimeRange.start) {
							this.initResolvedTimeRange();
							this.loadResolvedAlerts();
						}
					}
				});
			},

			// Initialize time range on component init
			initResolvedTimeRange() {
				const now = new Date();
				const oneDayAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));

				// Format for datetime-local input (YYYY-MM-DDTHH:mm)
				this.resolvedTimeRange.end = this.formatDateTimeLocal(now);
				this.resolvedTimeRange.start = this.formatDateTimeLocal(oneDayAgo);
			},

			// Format date for datetime-local input
			formatDateTimeLocal(date) {
				const year = date.getFullYear();
				const month = String(date.getMonth() + 1).padStart(2, '0');
				const day = String(date.getDate()).padStart(2, '0');
				const hours = String(date.getHours()).padStart(2, '0');
				const minutes = String(date.getMinutes()).padStart(2, '0');
				return `${year}-${month}-${day}T${hours}:${minutes}`;
			},

			// Set time range with preset (hours from now)
			async setResolvedTimeRange(hours) {
				const now = new Date();
				const startDate = new Date(now.getTime() - (hours * 60 * 60 * 1000));

				this.resolvedTimeRange.start = this.formatDateTimeLocal(startDate);
				this.resolvedTimeRange.end = this.formatDateTimeLocal(now);
				this.resolvedTimeRange.preset = hours; // Track which preset is active

				this.resolvedPagination.offset = 0; // Reset pagination
				await this.loadResolvedAlerts();
			},

			// Apply time range change and reload (called when manually changing dates)
			async applyResolvedTimeRange() {
				// Clear preset indicator when manually changing dates
				this.resolvedTimeRange.preset = null;
				this.resolvedPagination.offset = 0; // Reset pagination
				await this.loadResolvedAlerts();
			},

			// Count active filters from main dashboard
			getActiveFiltersCount() {
				let count = 0;
				if (this.filters.alertmanagers && this.filters.alertmanagers.length > 0) count++;
				if (this.filters.severities && this.filters.severities.length > 0) count++;
				if (this.filters.statuses && this.filters.statuses.length > 0) count++;
				if (this.filters.teams && this.filters.teams.length > 0) count++;
				if (this.filters.alertNames && this.filters.alertNames.length > 0) count++;
				if (this.searchQuery && this.searchQuery.trim().length > 0) count++;
				if (this.acknowledgmentFilter !== null) count++;
				if (this.commentsFilter !== null) count++;
				return count;
			},

			// Load recently resolved alerts using main dashboard filters + time range
			async loadResolvedAlerts() {
				// Initialize time range if not set
				if (!this.resolvedTimeRange.start || !this.resolvedTimeRange.end) {
					this.initResolvedTimeRange();
				}

				this.resolvedLoading = true;

				try {
					// Parse datetime-local to ISO string
					const startDate = new Date(this.resolvedTimeRange.start);
					const endDate = new Date(this.resolvedTimeRange.end);


					// Build request using main dashboard filters
					const requestBody = {
						start_date: startDate.toISOString(),
						end_date: endDate.toISOString(),
						severity: this.filters.severities || [],
						team: (this.filters.teams && this.filters.teams.length > 0) ? this.filters.teams.join(',') : '',
						alert_name: (this.filters.alertNames && this.filters.alertNames.length > 0) ? this.filters.alertNames.join(',') : '',
						search_query: this.searchQuery || '',
						include_silenced: this.resolvedIncludeSilenced,
						limit: this.resolvedPagination.limit,
						offset: this.resolvedPagination.offset
					};

					console.log('Loading resolved alerts with filters:', requestBody);

					const response = await fetch('/api/v1/statistics/recently-resolved', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(requestBody)
					});

					const data = await response.json();

					if (data.success && data.data) {
						this.resolvedAlerts = data.data.alerts || [];
						this.resolvedTotalCount = data.data.total_count || 0;
						console.log(`Loaded ${this.resolvedAlerts.length} unique fingerprints (${this.resolvedTotalCount} total)`);
						console.log('Sample alert:', this.resolvedAlerts[0]);

						// Load colors for resolved alerts
						await this.loadResolvedAlertColors();
					} else {
						console.error('Failed to load resolved alerts:', data.message || 'Unknown error');
						this.resolvedAlerts = [];
						this.resolvedTotalCount = 0;
					}
				} catch (error) {
					console.error('Error loading resolved alerts:', error);
					this.resolvedAlerts = [];
					this.resolvedTotalCount = 0;
				} finally {
					this.resolvedLoading = false;
				}
			},

			// Pagination
			async loadResolvedPage(offset) {
				this.resolvedPagination.offset = offset;
				await this.loadResolvedAlerts();
			},

			// Format duration for display
			formatResolvedDuration(seconds) {
				if (!seconds || seconds === 0) return '0s';

				const hours = Math.floor(seconds / 3600);
				const minutes = Math.floor((seconds % 3600) / 60);
				const secs = seconds % 60;

				const parts = [];
				if (hours > 0) parts.push(`${hours}h`);
				if (minutes > 0) parts.push(`${minutes}m`);
				if (secs > 0 || parts.length === 0) parts.push(`${secs}s`);

				return parts.join(' ');
			},

			// Get severity badge class
			getResolvedSeverityClass(severity) {
				const classes = {
					'critical': 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-400',
					'warning': 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-400',
					'info': 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-400'
				};
				return classes[severity.toLowerCase()] || 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
			},

			// Show alert details from resolved tab
			async showResolvedAlertDetails(alert) {
				// Use existing modal infrastructure - just pass fingerprint
				await this.showAlertDetails(alert.fingerprint);
			},

			// Toggle sort for resolved alerts table
			sortResolvedAlerts(field) {
				if (this.resolvedSortField === field) {
					// Toggle direction if clicking same field
					this.resolvedSortDirection = this.resolvedSortDirection === 'asc' ? 'desc' : 'asc';
				} else {
					// New field - default to ascending
					this.resolvedSortField = field;
					this.resolvedSortDirection = 'asc';
				}
			},

			// Get sorted resolved alerts
			getSortedResolvedAlerts() {
				if (!this.resolvedAlerts || this.resolvedAlerts.length === 0) {
					return [];
				}

				const sorted = [...this.resolvedAlerts];
				const field = this.resolvedSortField;
				const direction = this.resolvedSortDirection;

				sorted.sort((a, b) => {
					let aVal = a[field];
					let bVal = b[field];

					// Handle null/undefined values
					if (aVal === null || aVal === undefined) aVal = '';
					if (bVal === null || bVal === undefined) bVal = '';

					// Special handling for different data types
					if (field === 'occurrence_count' || field === 'avg_duration' ||
					    field === 'avg_mttr' || field === 'total_duration' || field === 'total_mttr') {
						// Numeric comparison
						aVal = parseFloat(aVal) || 0;
						bVal = parseFloat(bVal) || 0;
					} else if (field === 'first_fired_at' || field === 'last_resolved_at') {
						// Date comparison
						aVal = new Date(aVal).getTime();
						bVal = new Date(bVal).getTime();
					} else {
						// String comparison (case-insensitive)
						aVal = String(aVal).toLowerCase();
						bVal = String(bVal).toLowerCase();
					}

					if (aVal < bVal) return direction === 'asc' ? -1 : 1;
					if (aVal > bVal) return direction === 'asc' ? 1 : -1;
					return 0;
				});

				return sorted;
			},

			// Calculate statistics from resolved alerts
			calculateResolvedStatistics() {
				if (!this.resolvedAlerts || this.resolvedAlerts.length === 0) {
					return {
						totalResolved: 0,
						totalOccurrences: 0,
						avgMTTR: 0,
						avgDuration: 0,
						mostFrequent: null,
						fastestResolution: null,
						severityBreakdown: { critical: 0, warning: 0, info: 0 }
					};
				}

				let totalOccurrences = 0;
				let totalDuration = 0;
				let totalMTTR = 0;
				const severityBreakdown = { critical: 0, warning: 0, info: 0 };
				let fastestResolution = null;
				let mostFrequent = null;

				this.resolvedAlerts.forEach(alert => {
					// Count occurrences
					const occurrences = alert.occurrences || 1;
					totalOccurrences += occurrences;

					// Sum durations
					if (alert.avg_duration) {
						totalDuration += alert.avg_duration;
					}

					// Sum MTTR
					if (alert.avg_mttr) {
						totalMTTR += alert.avg_mttr;
					}

					// Count by severity
					const severity = (alert.severity || 'info').toLowerCase();
					if (severity === 'critical' || severity === 'critical-daytime') {
						severityBreakdown.critical += occurrences;
					} else if (severity === 'warning') {
						severityBreakdown.warning += occurrences;
					} else {
						severityBreakdown.info += occurrences;
					}

					// Find most frequent
					if (!mostFrequent || occurrences > mostFrequent.occurrences) {
						mostFrequent = alert;
					}

					// Find fastest resolution
					if (alert.avg_mttr && (!fastestResolution || alert.avg_mttr < fastestResolution.avg_mttr)) {
						fastestResolution = alert;
					}
				});

				const alertCount = this.resolvedAlerts.length;

				return {
					totalResolved: alertCount,
					totalOccurrences: totalOccurrences,
					avgMTTR: alertCount > 0 ? totalMTTR / alertCount : 0,
					avgDuration: alertCount > 0 ? totalDuration / alertCount : 0,
					mostFrequent: mostFrequent,
					fastestResolution: fastestResolution,
					severityBreakdown: severityBreakdown
				};
			},

			// Format duration in seconds to human-readable string
			formatDurationHuman(seconds) {
				if (!seconds || seconds < 0) return '0s';

				const hours = Math.floor(seconds / 3600);
				const minutes = Math.floor((seconds % 3600) / 60);
				const secs = Math.floor(seconds % 60);

				if (hours > 0) {
					return `${hours}h ${minutes}m`;
				} else if (minutes > 0) {
					return `${minutes}m ${secs}s`;
				} else {
					return `${secs}s`;
				}
			},

			// Format large numbers with K/M suffix
			formatNumber(num) {
				if (!num || num < 0) return '0';
				if (num >= 1000000) {
					return (num / 1000000).toFixed(1) + 'M';
				} else if (num >= 1000) {
					return (num / 1000).toFixed(1) + 'K';
				}
				return num.toString();
			},

			// Export resolved alerts to CSV
			exportResolvedAlertsCSV() {
				if (!this.resolvedAlerts || this.resolvedAlerts.length === 0) {
					alert('No data to export');
					return;
				}

				// CSV Header
				let csv = 'Fingerprint,Alert Name,Severity,Occurrences,First Fired At,Last Resolved At,Avg Duration (s),Total Duration (s),Avg MTTR (s),Total MTTR (s),Team,Source\n';

				// CSV Data rows
				this.resolvedAlerts.forEach(alert => {
					const row = [
						`"${alert.fingerprint || ''}"`,
						`"${(alert.alert_name || '').replace(/"/g, '""')}"`, // Escape quotes
						`"${alert.severity || ''}"`,
						alert.occurrence_count || 0,
						`"${alert.first_fired_at || ''}"`,
						`"${alert.last_resolved_at || ''}"`,
						alert.avg_duration || 0,
						alert.total_duration || 0,
						alert.avg_mttr || 0,
						alert.total_mttr || 0,
						`"${(alert.team || '').replace(/"/g, '""')}"`,
						`"${(alert.source || '').replace(/"/g, '""')}"`
					];
					csv += row.join(',') + '\n';
				});

				// Download CSV
				const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
				const url = window.URL.createObjectURL(blob);
				const link = document.createElement('a');
				link.href = url;

				// Generate filename with date range
				const startDate = new Date(this.resolvedTimeRange.start).toISOString().split('T')[0];
				const endDate = new Date(this.resolvedTimeRange.end).toISOString().split('T')[0];
				link.download = `resolved-alerts-${startDate}-to-${endDate}.csv`;

				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				window.URL.revokeObjectURL(url);
			},

			// Export resolved alerts to JSON
			exportResolvedAlertsJSON() {
				if (!this.resolvedAlerts || this.resolvedAlerts.length === 0) {
					alert('No data to export');
					return;
				}

				// Create export object with metadata
				const exportData = {
					exported_at: new Date().toISOString(),
					time_range: {
						start: new Date(this.resolvedTimeRange.start).toISOString(),
						end: new Date(this.resolvedTimeRange.end).toISOString()
					},
					filters: {
						severities: this.filters.severities || [],
						teams: this.filters.teams || [],
						alert_names: this.filters.alertNames || [],
						search_query: this.searchQuery || '',
						include_silenced: this.resolvedIncludeSilenced
					},
					total_count: this.resolvedTotalCount,
					displayed_count: this.resolvedAlerts.length,
					alerts: this.resolvedAlerts
				};

				// Download JSON
				const jsonStr = JSON.stringify(exportData, null, 2);
				const blob = new Blob([jsonStr], { type: 'application/json' });
				const url = window.URL.createObjectURL(blob);
				const link = document.createElement('a');
				link.href = url;

				// Generate filename with date range
				const startDate = new Date(this.resolvedTimeRange.start).toISOString().split('T')[0];
				const endDate = new Date(this.resolvedTimeRange.end).toISOString().split('T')[0];
				link.download = `resolved-alerts-${startDate}-to-${endDate}.json`;

				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				window.URL.revokeObjectURL(url);
			},

			// Load colors for resolved alerts
			async loadResolvedAlertColors() {
				if (!this.resolvedAlerts || this.resolvedAlerts.length === 0) {
					return;
				}

				try {
					console.log('Loading colors for resolved alerts...');

					// Build same URL parameters as dashboard data API
					const params = new URLSearchParams();

					// Use resolved view filters
					if (this.searchQuery) params.set('search', this.searchQuery);
					if (this.filters.severities.length > 0) params.set('severities', this.filters.severities.join(','));
					if (this.filters.teams.length > 0) params.set('teams', this.filters.teams.join(','));
					if (this.filters.alertNames && this.filters.alertNames.length > 0) params.set('alertNames', this.filters.alertNames.join(','));

					// Set display mode to get colors for resolved alerts
					params.set('displayMode', 'resolved');
					params.set('viewMode', this.viewMode);
					params.set('sortField', this.sortField);
					params.set('sortDirection', this.sortDirection);

					const response = await fetch(`/api/v1/dashboard/alert-colors?${params.toString()}`, {
						credentials: 'include'
					});

					if (response.ok) {
						const result = await response.json();
						if (result.success && result.data && result.data.colors) {
							// Merge colors into alertColors object
							Object.assign(this.alertColors, result.data.colors);
							console.log(`Loaded colors for ${Object.keys(result.data.colors).length} resolved alerts`);
						}
					}
				} catch (error) {
					console.error('Error loading resolved alert colors:', error);
				}
			}
		};
	</script>
}
