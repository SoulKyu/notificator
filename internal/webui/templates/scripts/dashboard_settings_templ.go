// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func DashboardSettings() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\tfunction settingsModalData() {\n\t\t\treturn {\n\t\t\t\tactiveTab: 'general',\n\t\t\t\tcolorPreferences: [],\n\t\t\t\tavailableLabels: {},\n\t\t\t\tavailableLabelsLastLoaded: null,\n\t\t\t\tlabelKeyTimeouts: {},\n\t\t\t\t\n\t\t\t\t// Hidden alerts data\n\t\t\t\thiddenAlerts: [],\n\t\t\t\thiddenRules: [],\n\t\t\t\thiddenAlertsLoading: false,\n\t\t\t\thiddenRulesLoading: false,\n\t\t\t\t\n\t\t\t\t// Hidden Rules Modal\n\t\t\t\tshowHiddenRuleModal: false,\n\t\t\t\thiddenRuleForm: {\n\t\t\t\t\tname: '',\n\t\t\t\t\tlabelKey: '',\n\t\t\t\t\tlabelValue: '',\n\t\t\t\t\tdescription: '',\n\t\t\t\t\tenabled: true\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tsettings: {\n\t\t\t\t\ttheme: 'light',\n\t\t\t\t\tresolvedAlertsRetention: 7,\n\t\t\t\t\tresolvedAlertsLimit: 100,\n\t\t\t\t\trefreshInterval: 30\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Sentry integration data\n\t\t\t\tsentryConfig: {\n\t\t\t\t\thasToken: false,\n\t\t\t\t\tbaseUrl: 'https://sentry.io',\n\t\t\t\t\tauthStatus: 'none',\n\t\t\t\t\tconnectionTesting: false\n\t\t\t\t},\n\t\t\t\tsentryForm: {\n\t\t\t\t\ttoken: '',\n\t\t\t\t\tbaseUrl: 'https://sentry.io'\n\t\t\t\t},\n\t\t\t\tsentrySaving: false,\n\t\t\t\t\n\t\t\t\tnotificationPreferences: {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tsoundEnabled: true,\n\t\t\t\t\tbrowserNotifications: true,\n\t\t\t\t\tcooldownSeconds: 300,\n\t\t\t\t\tmaxNotifications: 5,\n\t\t\t\t\trespectFilters: true,\n\t\t\t\t\tseverityRules: {\n\t\t\t\t\t\tcritical: true,\n\t\t\t\t\t\tmajor: true,\n\t\t\t\t\t\twarning: true,\n\t\t\t\t\t\tminor: false,\n\t\t\t\t\t\tinfo: false,\n\t\t\t\t\t\tunknown: false\n\t\t\t\t\t},\n\t\t\t\t\tsoundConfig: {}\n\t\t\t\t},\n\t\t\t\tnotificationPreferencesSaving: false,\n\t\t\t\tsettingsSaving: false,\n\t\t\t\t\n\t\t\t\tasync init() {\n\t\t\t\t\tconsole.log('Settings modal initializing...');\n\t\t\t\t\tawait this.loadSettings();\n\t\t\t\t\tawait this.loadColorPreferences();\n\t\t\t\t\tawait this.loadAvailableLabels();\n\t\t\t\t\tawait this.loadNotificationPreferences();\n\t\t\t\t\tawait this.loadHiddenAlerts();\n\t\t\t\t\tawait this.loadHiddenRules();\n\t\t\t\t\tawait this.loadSentryConfig();\n\t\t\t\t\twindow.currentSettingsModal = this;\n\t\t\t\t\tconsole.log('Settings modal initialized, window.currentSettingsModal set:', !!window.currentSettingsModal);\n\t\t\t\t},\n\n\t\t\t\tasync loadSettings() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Load settings from localStorage for now (can be extended to backend later)\n\t\t\t\t\t\tconst savedSettings = localStorage.getItem('dashboardSettings');\n\t\t\t\t\t\tif (savedSettings) {\n\t\t\t\t\t\t\tconst parsedSettings = JSON.parse(savedSettings);\n\t\t\t\t\t\t\tthis.settings = { ...this.settings, ...parsedSettings };\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Also check for theme preference from dashboard instance\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.currentTheme) {\n\t\t\t\t\t\t\tthis.settings.theme = window.dashboardInstance.currentTheme;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tconsole.log('Loaded general settings:', this.settings);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading general settings:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync loadColorPreferences() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/color-preferences', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.colorPreferences = (result.data.preferences || []).map(pref => ({\n\t\t\t\t\t\t\t\t\t...pref,\n\t\t\t\t\t\t\t\t\tlabelConditions: pref.labelConditions || {},\n\t\t\t\t\t\t\t\t\tbgLightnessFactor: pref.bgLightnessFactor !== undefined ? pref.bgLightnessFactor : 0.9,\n\t\t\t\t\t\t\t\t\ttextDarknessFactor: pref.textDarknessFactor !== undefined ? pref.textDarknessFactor : 0.3\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading color preferences:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync loadAvailableLabels() {\n\t\t\t\t\t// Check if we already have cached labels and they're not too old (cache for 5 minutes)\n\t\t\t\t\tif (this.availableLabels && Object.keys(this.availableLabels).length > 0 && \n\t\t\t\t\t\tthis.availableLabelsLastLoaded && \n\t\t\t\t\t\t(Date.now() - this.availableLabelsLastLoaded) < 300000) {\n\t\t\t\t\t\tconsole.log('Using cached available labels');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconsole.log('Fetching available labels from API...');\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/available-labels', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.availableLabels = result.data.labels || {};\n\t\t\t\t\t\t\t\tthis.availableLabelsLastLoaded = Date.now();\n\t\t\t\t\t\t\t\tconsole.log('Loaded available labels:', Object.keys(this.availableLabels).length, 'label types');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading available labels:', error);\n\t\t\t\t\t\t// Fallback to empty object if fetch fails\n\t\t\t\t\t\tthis.availableLabels = {};\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveColorPreferences() {\n\t\t\t\t\tconsole.log('saveColorPreferences called with preferences:', this.colorPreferences);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/color-preferences', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\tpreferences: this.colorPreferences\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\tconsole.log('Color preferences save response:', result);\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Reload color preferences to show saved state in modal\n\t\t\t\t\t\t\tawait this.loadColorPreferences();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to save color preferences:', result.error);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving color preferences:', error);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\taddColorPreference() {\n\t\t\t\t\tconst newPref = {\n\t\t\t\t\t\tid: String(Date.now() + Math.random()),\n\t\t\t\t\t\tlabelKey: '',\n\t\t\t\t\t\tlabelValue: '',\n\t\t\t\t\t\tcolor: '#ff9999',\n\t\t\t\t\t\tcolorType: 'custom',\n\t\t\t\t\t\tpriority: 0,\n\t\t\t\t\t\tbgLightnessFactor: 0.9,\n\t\t\t\t\t\ttextDarknessFactor: 0.3,\n\t\t\t\t\t\tisEditing: true\n\t\t\t\t\t};\n\t\t\t\t\tthis.colorPreferences.push(newPref);\n\t\t\t\t},\n\n\t\t\t\taddLabelCondition(preference) {\n\t\t\t\t\tif (!preference.labelConditions) {\n\t\t\t\t\t\tpreference.labelConditions = {};\n\t\t\t\t\t}\n\t\t\t\t\tconst key = 'label' + Object.keys(preference.labelConditions).length;\n\t\t\t\t\tpreference.labelConditions[key] = '';\n\t\t\t\t},\n\n\t\t\t\tensureAvailableLabels() {\n\t\t\t\t\tif (!this.availableLabels || Object.keys(this.availableLabels).length === 0) {\n\t\t\t\t\t\tthis.loadAvailableLabels();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\teditColorPreference(id) {\n\t\t\t\t\tconst pref = this.colorPreferences.find(p => p.id === id);\n\t\t\t\t\tif (pref) {\n\t\t\t\t\t\tpref.isEditing = true;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tcancelEditColorPreference(id) {\n\t\t\t\t\tconst index = this.colorPreferences.findIndex(p => p.id === id);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tconst pref = this.colorPreferences[index];\n\t\t\t\t\t\tif (!pref.labelKey && !pref.labelValue) {\n\t\t\t\t\t\t\t// Remove if it's a new preference being cancelled\n\t\t\t\t\t\t\tthis.colorPreferences.splice(index, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpref.isEditing = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tremoveColorPreference(index) {\n\t\t\t\t\tthis.colorPreferences.splice(index, 1);\n\t\t\t\t},\n\n\t\t\t\t// Get available values for a selected label key\n\t\t\t\tgetAvailableValuesForLabel(labelKey) {\n\t\t\t\t\treturn this.availableLabels[labelKey] || [];\n\t\t\t\t},\n\n\t\t\t\t// Get available severities from dashboard metadata\n\t\t\t\tgetAvailableSeverities() {\n\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.metadata && window.dashboardInstance.metadata.availableFilters) {\n\t\t\t\t\t\treturn window.dashboardInstance.metadata.availableFilters.severities || [];\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t},\n\n\t\t\t\t// Initialize dynamic severity rules based on available severities\n\t\t\t\tinitializeDynamicSeverityRules() {\n\t\t\t\t\tconst availableSeverities = this.getAvailableSeverities();\n\t\t\t\t\tconst currentRules = this.notificationPreferences.severityRules || {};\n\t\t\t\t\tconst newRules = {};\n\n\t\t\t\t\t// Keep existing preferences for known severities\n\t\t\t\t\tavailableSeverities.forEach(severity => {\n\t\t\t\t\t\tconst severityKey = severity.toLowerCase();\n\t\t\t\t\t\t// Use existing preference if available, otherwise default based on severity type\n\t\t\t\t\t\tif (currentRules.hasOwnProperty(severityKey)) {\n\t\t\t\t\t\t\tnewRules[severityKey] = currentRules[severityKey];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Default rules: enable critical, warning, major; disable others\n\t\t\t\t\t\t\tnewRules[severityKey] = ['critical', 'major', 'warning'].includes(severityKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// Update notification preferences with dynamic rules\n\t\t\t\t\tthis.notificationPreferences.severityRules = newRules;\n\t\t\t\t},\n\n\t\t\t\t// Debounced update for label condition keys to improve performance\n\t\t\t\tupdateLabelConditionKey(preference, oldKey, newKey) {\n\t\t\t\t\tif (oldKey !== newKey && newKey.trim() !== '') {\n\t\t\t\t\t\tconst value = preference.labelConditions[oldKey];\n\t\t\t\t\t\tdelete preference.labelConditions[oldKey];\n\t\t\t\t\t\tpreference.labelConditions[newKey] = value;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Debounced version for input events - only updates after user stops typing\n\t\t\t\tdebouncedUpdateLabelConditionKey(preference, oldKey, newKey) {\n\t\t\t\t\t// Clear existing timeout for this specific input\n\t\t\t\t\tconst timeoutKey = `${preference.id}-${oldKey}`;\n\t\t\t\t\tif (this.labelKeyTimeouts && this.labelKeyTimeouts[timeoutKey]) {\n\t\t\t\t\t\tclearTimeout(this.labelKeyTimeouts[timeoutKey]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Initialize timeouts object if it doesn't exist\n\t\t\t\t\tif (!this.labelKeyTimeouts) {\n\t\t\t\t\t\tthis.labelKeyTimeouts = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set new timeout to update after 300ms of no typing\n\t\t\t\t\tthis.labelKeyTimeouts[timeoutKey] = setTimeout(() => {\n\t\t\t\t\t\tthis.updateLabelConditionKey(preference, oldKey, newKey);\n\t\t\t\t\t\tdelete this.labelKeyTimeouts[timeoutKey];\n\t\t\t\t\t}, 300);\n\t\t\t\t},\n\n\t\t\t\t// Get severity color for UI display\n\t\t\t\tgetSeverityColor(severity) {\n\t\t\t\t\tconst severityLower = severity.toLowerCase();\n\t\t\t\t\tconst colorMap = {\n\t\t\t\t\t\t'critical': 'red',\n\t\t\t\t\t\t'major': 'orange', \n\t\t\t\t\t\t'warning': 'yellow',\n\t\t\t\t\t\t'minor': 'blue',\n\t\t\t\t\t\t'info': 'green',\n\t\t\t\t\t\t'information': 'green',\n\t\t\t\t\t\t'unknown': 'gray'\n\t\t\t\t\t};\n\t\t\t\t\treturn colorMap[severityLower] || 'gray';\n\t\t\t\t},\n\n\t\t\t\t// Get severity display name\n\t\t\t\tgetSeverityDisplayName(severity) {\n\t\t\t\t\tconst displayMap = {\n\t\t\t\t\t\t'info': 'Info',\n\t\t\t\t\t\t'information': 'Info',\n\t\t\t\t\t\t'critical': 'Critical',\n\t\t\t\t\t\t'major': 'Major',\n\t\t\t\t\t\t'warning': 'Warning',\n\t\t\t\t\t\t'minor': 'Minor',\n\t\t\t\t\t\t'unknown': 'Unknown'\n\t\t\t\t\t};\n\t\t\t\t\treturn displayMap[severity.toLowerCase()] || severity.charAt(0).toUpperCase() + severity.slice(1);\n\t\t\t\t},\n\n\t\t\t\t// Initialize dynamic sound configuration based on available severities\n\t\t\t\tinitializeDynamicSoundConfig() {\n\t\t\t\t\tconst availableSeverities = this.getAvailableSeverities();\n\t\t\t\t\tconst currentSoundConfig = this.notificationPreferences.soundConfig || {};\n\t\t\t\t\tconst newSoundConfig = {};\n\n\t\t\t\t\t// Process each available severity\n\t\t\t\t\tavailableSeverities.forEach(severity => {\n\t\t\t\t\t\tconst severityKey = severity.toLowerCase();\n\t\t\t\t\t\tconst freqKey = `${severityKey}_frequency`;\n\t\t\t\t\t\tconst durKey = `${severityKey}_duration`;\n\t\t\t\t\t\tconst typeKey = `${severityKey}_type`;\n\n\t\t\t\t\t\t// Use existing config if available, otherwise use defaults\n\t\t\t\t\t\tif (currentSoundConfig.hasOwnProperty(freqKey)) {\n\t\t\t\t\t\t\tnewSoundConfig[freqKey] = currentSoundConfig[freqKey];\n\t\t\t\t\t\t\tnewSoundConfig[durKey] = currentSoundConfig[durKey];\n\t\t\t\t\t\t\tnewSoundConfig[typeKey] = currentSoundConfig[typeKey];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Set intelligent defaults based on severity type\n\t\t\t\t\t\t\tconst defaults = this.getDefaultSoundConfigForSeverity(severityKey);\n\t\t\t\t\t\t\tnewSoundConfig[freqKey] = defaults.frequency;\n\t\t\t\t\t\t\tnewSoundConfig[durKey] = defaults.duration;\n\t\t\t\t\t\t\tnewSoundConfig[typeKey] = defaults.type;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// Update notification preferences with dynamic sound config\n\t\t\t\t\tthis.notificationPreferences.soundConfig = newSoundConfig;\n\t\t\t\t},\n\n\t\t\t\t// Get default sound configuration for a severity\n\t\t\t\tgetDefaultSoundConfigForSeverity(severity) {\n\t\t\t\t\tconst severityLower = severity.toLowerCase();\n\t\t\t\t\t\n\t\t\t\t\t// Default configurations based on severity urgency\n\t\t\t\t\tswitch (severityLower) {\n\t\t\t\t\t\tcase 'critical':\n\t\t\t\t\t\tcase 'major':\n\t\t\t\t\t\t\treturn { frequency: 800, duration: 200, type: 'square' };\n\t\t\t\t\t\tcase 'warning':\n\t\t\t\t\t\tcase 'minor':\n\t\t\t\t\t\t\treturn { frequency: 600, duration: 150, type: 'sine' };\n\t\t\t\t\t\tcase 'info':\n\t\t\t\t\t\tcase 'information':\n\t\t\t\t\t\t\treturn { frequency: 400, duration: 100, type: 'sine' };\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// Unknown severities get a neutral sound\n\t\t\t\t\t\t\treturn { frequency: 500, duration: 120, type: 'triangle' };\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Test sound with current form settings (preview functionality)\n\t\t\t\ttestSoundWithPreview(severity) {\n\t\t\t\t\tif (!window.dashboardInstance || !window.dashboardInstance.audioContext) {\n\t\t\t\t\t\tconsole.warn('Audio context not available for sound preview');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst severityKey = severity.toLowerCase();\n\t\t\t\t\t\n\t\t\t\t\t// Read current values directly from DOM elements to get the most up-to-date user input\n\t\t\t\t\tconst frequencyInput = document.querySelector(`input[type=\"number\"][x-model*=\"${severityKey}_frequency\"]`);\n\t\t\t\t\tconst durationInput = document.querySelector(`input[type=\"number\"][x-model*=\"${severityKey}_duration\"]`);\n\t\t\t\t\tconst typeSelect = document.querySelector(`select[x-model*=\"${severityKey}_type\"]`);\n\t\t\t\t\t\n\t\t\t\t\tconst soundConfig = {\n\t\t\t\t\t\tfrequency: frequencyInput ? parseInt(frequencyInput.value) || 500 : 500,\n\t\t\t\t\t\tduration: durationInput ? parseInt(durationInput.value) || 150 : 150,\n\t\t\t\t\t\ttype: typeSelect ? typeSelect.value || 'sine' : 'sine'\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tconsole.log(`Testing sound for ${severity} with current form values:`, soundConfig);\n\t\t\t\t\tthis.playPreviewSound(soundConfig);\n\t\t\t\t},\n\n\t\t\t\t// Play sound with specific configuration (for testing)\n\t\t\t\tplayPreviewSound(soundConfig) {\n\t\t\t\t\tif (!window.dashboardInstance || !window.dashboardInstance.audioContext) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst audioContext = window.dashboardInstance.audioContext;\n\t\t\t\t\t\tconst oscillator = audioContext.createOscillator();\n\t\t\t\t\t\tconst gainNode = audioContext.createGain();\n\t\t\t\t\t\t\n\t\t\t\t\t\toscillator.connect(gainNode);\n\t\t\t\t\t\tgainNode.connect(audioContext.destination);\n\t\t\t\t\t\t\n\t\t\t\t\t\toscillator.frequency.setValueAtTime(soundConfig.frequency, audioContext.currentTime);\n\t\t\t\t\t\toscillator.type = soundConfig.type;\n\t\t\t\t\t\t\n\t\t\t\t\t\tgainNode.gain.setValueAtTime(0.1, audioContext.currentTime);\n\t\t\t\t\t\tgainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + soundConfig.duration / 1000);\n\t\t\t\t\t\t\n\t\t\t\t\t\toscillator.start(audioContext.currentTime);\n\t\t\t\t\t\toscillator.stop(audioContext.currentTime + soundConfig.duration / 1000);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.warn('Failed to play preview sound:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Get current sound config from DOM form values (for saving real-time user input)\n\t\t\t\tgetCurrentSoundConfigFromDOM() {\n\t\t\t\t\tconst availableSeverities = this.getAvailableSeverities();\n\t\t\t\t\tconst currentSoundConfig = {};\n\t\t\t\t\t\n\t\t\t\t\t// Read current form values for each available severity\n\t\t\t\t\tavailableSeverities.forEach(severity => {\n\t\t\t\t\t\tconst severityKey = severity.toLowerCase();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Query DOM for frequency, duration, and type inputs\n\t\t\t\t\t\tconst frequencyInput = document.querySelector(`input[type=\"number\"][x-model*=\"${severityKey}_frequency\"]`);\n\t\t\t\t\t\tconst durationInput = document.querySelector(`input[type=\"number\"][x-model*=\"${severityKey}_duration\"]`);\n\t\t\t\t\t\tconst typeSelect = document.querySelector(`select[x-model*=\"${severityKey}_type\"]`);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Extract values with defaults and ensure clean data types\n\t\t\t\t\t\tconst freqKey = `${severityKey}_frequency`;\n\t\t\t\t\t\tconst durKey = `${severityKey}_duration`;\n\t\t\t\t\t\tconst typeKey = `${severityKey}_type`;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Ensure integers are clean and valid\n\t\t\t\t\t\tlet frequency = 500;\n\t\t\t\t\t\tlet duration = 150;\n\t\t\t\t\t\tlet soundType = 'sine';\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (frequencyInput && frequencyInput.value) {\n\t\t\t\t\t\t\tconst parsedFreq = parseInt(frequencyInput.value, 10);\n\t\t\t\t\t\t\tfrequency = (isNaN(parsedFreq) || parsedFreq < 100 || parsedFreq > 2000) ? 500 : parsedFreq;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (durationInput && durationInput.value) {\n\t\t\t\t\t\t\tconst parsedDur = parseInt(durationInput.value, 10);\n\t\t\t\t\t\t\tduration = (isNaN(parsedDur) || parsedDur < 50 || parsedDur > 5000) ? 150 : parsedDur;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (typeSelect && typeSelect.value) {\n\t\t\t\t\t\t\tconst validTypes = ['sine', 'square', 'triangle', 'sawtooth'];\n\t\t\t\t\t\t\tsoundType = validTypes.includes(typeSelect.value) ? typeSelect.value : 'sine';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tcurrentSoundConfig[freqKey] = frequency;\n\t\t\t\t\t\tcurrentSoundConfig[durKey] = duration;\n\t\t\t\t\t\tcurrentSoundConfig[typeKey] = soundType;\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tconsole.log('Reading current sound config from DOM:', currentSoundConfig);\n\t\t\t\t\treturn currentSoundConfig;\n\t\t\t\t},\n\n\t\t\t\t// Preview the color combination with lightness factors\n\t\t\t\tgetPreviewStyle(pref) {\n\t\t\t\t\tif (!pref.color) return '';\n\t\t\t\t\t\n\t\t\t\t\t// Use the base color and apply lightness factors\n\t\t\t\t\tconst baseColor = pref.color;\n\t\t\t\t\tconst bgLightness = pref.bgLightnessFactor || 0.9;\n\t\t\t\t\tconst textDarkness = pref.textDarknessFactor || 0.3;\n\t\t\t\t\t\n\t\t\t\t\t// For custom colors, simulate the lightening/darkening effects\n\t\t\t\t\tif (pref.colorType === 'custom' && baseColor.startsWith('#')) {\n\t\t\t\t\t\tconst bgColor = this.lightenColorSimulation(baseColor, bgLightness);\n\t\t\t\t\t\tconst textColor = this.darkenColorSimulation(baseColor, textDarkness);\n\t\t\t\t\t\treturn `background-color: ${bgColor}; color: ${textColor}; padding: 2px 8px; border-radius: 4px; display: inline-block; min-width: 60px; text-align: center; border: 1px solid ${baseColor};`;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// For other color types, just use the base color\n\t\t\t\t\treturn `background-color: ${baseColor}; color: white; padding: 2px 8px; border-radius: 4px; display: inline-block; min-width: 60px; text-align: center;`;\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Simple color lightening simulation for preview\n\t\t\t\tlightenColorSimulation(hexColor, factor) {\n\t\t\t\t\t// Remove # if present\n\t\t\t\t\tconst hex = hexColor.replace('#', '');\n\t\t\t\t\tconst r = parseInt(hex.substr(0, 2), 16);\n\t\t\t\t\tconst g = parseInt(hex.substr(2, 2), 16);\n\t\t\t\t\tconst b = parseInt(hex.substr(4, 2), 16);\n\t\t\t\t\t\n\t\t\t\t\t// Lighten by interpolating towards white\n\t\t\t\t\tconst newR = Math.round(r + (255 - r) * factor);\n\t\t\t\t\tconst newG = Math.round(g + (255 - g) * factor);\n\t\t\t\t\tconst newB = Math.round(b + (255 - b) * factor);\n\t\t\t\t\t\n\t\t\t\t\treturn `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Simple color darkening simulation for preview\n\t\t\t\tdarkenColorSimulation(hexColor, factor) {\n\t\t\t\t\t// Remove # if present\n\t\t\t\t\tconst hex = hexColor.replace('#', '');\n\t\t\t\t\tconst r = parseInt(hex.substr(0, 2), 16);\n\t\t\t\t\tconst g = parseInt(hex.substr(2, 2), 16);\n\t\t\t\t\tconst b = parseInt(hex.substr(4, 2), 16);\n\t\t\t\t\t\n\t\t\t\t\t// Darken by interpolating towards black\n\t\t\t\t\tconst newR = Math.round(r * (1 - factor));\n\t\t\t\t\tconst newG = Math.round(g * (1 - factor));\n\t\t\t\t\tconst newB = Math.round(b * (1 - factor));\n\t\t\t\t\t\n\t\t\t\t\treturn `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;\n\t\t\t\t},\n\n\t\t\t\t// Tab management\n\t\t\t\tsetActiveTab(tab) {\n\t\t\t\t\tthis.activeTab = tab;\n\t\t\t\t\tif (tab === 'colors') {\n\t\t\t\t\t\t// Refresh available labels when opening colors tab\n\t\t\t\t\t\tthis.loadAvailableLabels();\n\t\t\t\t\t} else if (tab === 'notifications') {\n\t\t\t\t\t\t// Reload notification preferences to ensure fresh backend data (like color preferences)\n\t\t\t\t\t\tthis.loadNotificationPreferences();\n\t\t\t\t\t} else if (tab === 'hidden-alerts') {\n\t\t\t\t\t\t// Refresh hidden alerts data when opening hidden alerts tab\n\t\t\t\t\t\tthis.loadHiddenAlerts();\n\t\t\t\t\t\tthis.loadHiddenRules();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Form validation\n\t\t\t\tisValidColorPreference(pref) {\n\t\t\t\t\treturn pref.labelKey.trim() && pref.labelValue.trim() && pref.color;\n\t\t\t\t},\n\n\t\t\t\t// Check if a color preference has unsaved changes\n\t\t\t\thasUnsavedChanges(pref) {\n\t\t\t\t\treturn pref.isEditing;\n\t\t\t\t},\n\n\t\t\t\t// Color utility functions\n\t\t\t\tgenerateRandomColor() {\n\t\t\t\t\tconst colors = [\n\t\t\t\t\t\t'#ff9999', '#99ff99', '#9999ff', '#ffff99', '#ff99ff', '#99ffff',\n\t\t\t\t\t\t'#ffcc99', '#cc99ff', '#99ffcc', '#ccff99', '#ff99cc', '#99ccff'\n\t\t\t\t\t];\n\t\t\t\t\treturn colors[Math.floor(Math.random() * colors.length)];\n\t\t\t\t},\n\n\t\t\t\t// Get contrasting text color for background\n\t\t\t\tgetContrastingTextColor(bgColor) {\n\t\t\t\t\t// Simple contrast calculation - convert hex to RGB and check luminance\n\t\t\t\t\tconst hex = bgColor.replace('#', '');\n\t\t\t\t\tconst r = parseInt(hex.substr(0, 2), 16);\n\t\t\t\t\tconst g = parseInt(hex.substr(2, 2), 16);\n\t\t\t\t\tconst b = parseInt(hex.substr(4, 2), 16);\n\t\t\t\t\t\n\t\t\t\t\t// Calculate luminance\n\t\t\t\t\tconst luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n\t\t\t\t\t\n\t\t\t\t\treturn luminance > 0.5 ? '#000000' : '#ffffff';\n\t\t\t\t},\n\n\t\t\t\t// Auto-set contrasting text color when background changes\n\t\t\t\tonBgColorChange(pref) {\n\t\t\t\t\tpref.textColor = this.getContrastingTextColor(pref.bgColor);\n\t\t\t\t},\n\n\t\t\t\t// Notification Preference Methods\n\t\t\t\tasync loadNotificationPreferences() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/notification-preferences', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success && result.data.preference) {\n\t\t\t\t\t\t\t\tconst backendPrefs = result.data.preference;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Convert backend format (snake_case) to frontend format (camelCase)\n\t\t\t\t\t\t\t\tconst frontendPrefs = {\n\t\t\t\t\t\t\t\t\tenabled: backendPrefs.enabled,\n\t\t\t\t\t\t\t\t\tsoundEnabled: backendPrefs.sound_enabled,\n\t\t\t\t\t\t\t\t\tbrowserNotifications: backendPrefs.browser_notifications,\n\t\t\t\t\t\t\t\t\tcooldownSeconds: backendPrefs.cooldown_seconds,\n\t\t\t\t\t\t\t\t\tmaxNotifications: backendPrefs.max_notifications,\n\t\t\t\t\t\t\t\t\trespectFilters: backendPrefs.respect_filters,\n\t\t\t\t\t\t\t\t\tseverityRules: backendPrefs.severity_rules || {},\n\t\t\t\t\t\t\t\t\tsoundConfig: backendPrefs.sound_config || {}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Merge with defaults, preferring loaded values\n\t\t\t\t\t\t\t\tthis.notificationPreferences = { \n\t\t\t\t\t\t\t\t\t...this.notificationPreferences, \n\t\t\t\t\t\t\t\t\t...frontendPrefs \n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tconsole.log('Loaded notification preferences:', this.notificationPreferences);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Initialize dynamic severity rules after loading preferences\n\t\t\t\t\t\t\t\tthis.initializeDynamicSeverityRules();\n\t\t\t\t\t\t\t\t// Initialize dynamic sound configuration\n\t\t\t\t\t\t\t\tthis.initializeDynamicSoundConfig();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading notification preferences:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveNotificationPreferences() {\n\t\t\t\t\tconsole.log('Starting saveNotificationPreferences() from settings modal');\n\t\t\t\t\tthis.notificationPreferencesSaving = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Get current sound config from DOM to capture real-time user input\n\t\t\t\t\t\tconst currentSoundConfig = this.getCurrentSoundConfigFromDOM();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Pre-validate JSON serialization to catch issues early\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tJSON.stringify(currentSoundConfig);\n\t\t\t\t\t\t} catch (jsonError) {\n\t\t\t\t\t\t\tconsole.error('Invalid sound config data - cannot serialize to JSON:', jsonError);\n\t\t\t\t\t\t\tconsole.error('Problematic data:', currentSoundConfig);\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Invalid sound configuration data. Please check your settings.');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Clean up the payload and convert frontend format to backend format\n\t\t\t\t\t\tconst cleanPreferences = {\n\t\t\t\t\t\t\tenabled: this.notificationPreferences.enabled,\n\t\t\t\t\t\t\tsound_enabled: this.notificationPreferences.soundEnabled,\n\t\t\t\t\t\t\tbrowser_notifications: this.notificationPreferences.browserNotifications,\n\t\t\t\t\t\t\tcooldown_seconds: this.notificationPreferences.cooldownSeconds,\n\t\t\t\t\t\t\tmax_notifications: this.notificationPreferences.maxNotifications,\n\t\t\t\t\t\t\trespect_filters: this.notificationPreferences.respectFilters,\n\t\t\t\t\t\t\tseverity_rules: this.notificationPreferences.severityRules,\n\t\t\t\t\t\t\tsound_config: currentSoundConfig  // Use real DOM values instead of cached data\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconsole.log('Sending notification preferences to server:', cleanPreferences);\n\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/notification-preferences', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\tbody: JSON.stringify({ preference: cleanPreferences })\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tconsole.log('Notification preferences saved successfully');\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.error('Failed to save notification preferences:', result.error);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving notification preferences:', error);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.notificationPreferencesSaving = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\ttestNotification() {\n\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showInAppNotification) {\n\t\t\t\t\t\twindow.dashboardInstance.showInAppNotification('info', 'Test notification - your notification settings are working!');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Also test sound if enabled\n\t\t\t\t\tif (this.notificationPreferences.sound_enabled && window.dashboardInstance && window.dashboardInstance.playNotificationSound) {\n\t\t\t\t\t\twindow.dashboardInstance.playNotificationSound('info');\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveHiddenRules() {\n\t\t\t\t\tconsole.log('saveHiddenRules called - hidden rules are saved individually when created');\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Hidden rules are automatically saved to backend when created via createHiddenRule()\n\t\t\t\t\t\t// This function provides consistency in the unified save process\n\t\t\t\t\t\t// and ensures all rules in the current session are validated\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Validate that all rules have been properly saved\n\t\t\t\t\t\tif (this.hiddenRules && this.hiddenRules.length > 0) {\n\t\t\t\t\t\t\tconsole.log(`Validated ${this.hiddenRules.length} hidden rules in current session`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// All hidden rules are already persisted to backend\n\t\t\t\t\t\t// Return true to indicate successful save operation\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error validating hidden rules:', error);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveSettings() {\n\t\t\t\t\tconsole.log('Starting unified settings save...');\n\t\t\t\t\tthis.settingsSaving = true;\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Save general settings to localStorage\n\t\t\t\t\t\tlocalStorage.setItem('dashboardSettings', JSON.stringify(this.settings));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Apply theme change immediately if changed\n\t\t\t\t\t\tif (window.dashboardInstance && typeof window.dashboardInstance.setTheme === 'function') {\n\t\t\t\t\t\t\twindow.dashboardInstance.setTheme(this.settings.theme);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tconsole.log('General settings saved:', this.settings);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Save notification preferences\n\t\t\t\t\t\tconst notificationResult = await this.saveNotificationPreferences();\n\t\t\t\t\t\tif (!notificationResult) {\n\t\t\t\t\t\t\tthrow new Error('Failed to save notification preferences');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Save color preferences (save all existing preferences)\n\t\t\t\t\t\tconst colorResult = await this.saveColorPreferences();\n\t\t\t\t\t\tif (!colorResult) {\n\t\t\t\t\t\t\tthrow new Error('Failed to save color preferences');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Save hidden rules (ensure all rules are persisted)\n\t\t\t\t\t\tconst hiddenRulesResult = await this.saveHiddenRules();\n\t\t\t\t\t\tif (!hiddenRulesResult) {\n\t\t\t\t\t\t\tthrow new Error('Failed to save hidden rules');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Show unified success message\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('success', 'All settings saved successfully');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tconsole.log('All settings saved successfully');\n\t\t\t\t\t\t\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving settings:', error);\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to save some settings: ' + error.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.settingsSaving = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\ttestSound(severity) {\n\t\t\t\t\t// Use the new preview functionality that uses current form settings\n\t\t\t\t\tthis.testSoundWithPreview(severity);\n\t\t\t\t},\n\n\t\t\t\t// Hidden Alerts Management Functions\n\t\t\t\tasync loadHiddenAlerts() {\n\t\t\t\t\tthis.hiddenAlertsLoading = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/hidden-alerts', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.hiddenAlerts = result.data.hiddenAlerts || [];\n\t\t\t\t\t\t\t\tconsole.log('Loaded hidden alerts:', this.hiddenAlerts.length);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading hidden alerts:', error);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.hiddenAlertsLoading = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync loadHiddenRules() {\n\t\t\t\t\tthis.hiddenRulesLoading = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/hidden-rules', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.hiddenRules = result.data.rules || [];\n\t\t\t\t\t\t\t\tconsole.log('Loaded hidden rules:', this.hiddenRules.length);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading hidden rules:', error);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.hiddenRulesLoading = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync unhideAlert(fingerprint) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/hidden-alerts/${encodeURIComponent(fingerprint)}`, {\n\t\t\t\t\t\t\tmethod: 'DELETE',\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Remove from local array\n\t\t\t\t\t\t\tthis.hiddenAlerts = this.hiddenAlerts.filter(alert => alert.fingerprint !== fingerprint);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Show success message\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('success', 'Alert unhidden successfully');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Refresh dashboard data if visible\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.loadDashboardData();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to unhide alert:', result.error);\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to unhide alert: ' + (result.error || 'Unknown error'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error unhiding alert:', error);\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to unhide alert');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync toggleHiddenRule(ruleId) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst rule = this.hiddenRules.find(r => r.id === ruleId);\n\t\t\t\t\t\tif (!rule) return;\n\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/hidden-rules/${ruleId}`, {\n\t\t\t\t\t\t\tmethod: 'PUT',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\t...rule,\n\t\t\t\t\t\t\t\tenabled: !rule.enabled\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Update local rule\n\t\t\t\t\t\t\trule.enabled = !rule.enabled;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Show success message\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('success', \n\t\t\t\t\t\t\t\t\t`Rule ${rule.enabled ? 'enabled' : 'disabled'} successfully`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Refresh dashboard data if visible\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.loadDashboardData();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to toggle hidden rule:', result.error);\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to update rule: ' + (result.error || 'Unknown error'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error toggling hidden rule:', error);\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to update rule');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync removeHiddenRule(ruleId) {\n\t\t\t\t\tif (!confirm('Are you sure you want to delete this hidden rule?')) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/hidden-rules/${ruleId}`, {\n\t\t\t\t\t\t\tmethod: 'DELETE',\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Remove from local array\n\t\t\t\t\t\t\tthis.hiddenRules = this.hiddenRules.filter(rule => rule.id !== ruleId);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Show success message\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('success', 'Hidden rule deleted successfully');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Refresh dashboard data if visible\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.loadDashboardData();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to delete hidden rule:', result.error);\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to delete rule: ' + (result.error || 'Unknown error'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error deleting hidden rule:', error);\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to delete rule');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Utility function to format timestamps\n\t\t\t\tformatTimestamp(timestamp) {\n\t\t\t\t\tif (!timestamp) return 'Unknown';\n\t\t\t\t\tconst date = new Date(timestamp);\n\t\t\t\t\treturn date.toLocaleString();\n\t\t\t\t},\n\n\t\t\t\t// Utility function to truncate long text\n\t\t\t\ttruncateText(text, maxLength = 50) {\n\t\t\t\t\tif (!text) return '';\n\t\t\t\t\treturn text.length > maxLength ? text.substring(0, maxLength) + '...' : text;\n\t\t\t\t},\n\n\t\t\t\t// Add new hidden rule function\n\t\t\t\taddHiddenRule() {\n\t\t\t\t\t// Reset the form\n\t\t\t\t\tthis.hiddenRuleForm = {\n\t\t\t\t\t\tname: '',\n\t\t\t\t\t\tlabelKey: '',\n\t\t\t\t\t\tlabelValue: '',\n\t\t\t\t\t\tdescription: '',\n\t\t\t\t\t\tenabled: true\n\t\t\t\t\t};\n\t\t\t\t\t// Ensure available labels are loaded\n\t\t\t\t\tthis.ensureAvailableLabels();\n\t\t\t\t\t// Show the modal\n\t\t\t\t\tthis.showHiddenRuleModal = true;\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Cancel hidden rule modal\n\t\t\t\tcancelHiddenRule() {\n\t\t\t\t\tthis.showHiddenRuleModal = false;\n\t\t\t\t\tthis.hiddenRuleForm = {\n\t\t\t\t\t\tname: '',\n\t\t\t\t\t\tlabelKey: '',\n\t\t\t\t\t\tlabelValue: '',\n\t\t\t\t\t\tdescription: '',\n\t\t\t\t\t\tenabled: true\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Save hidden rule from modal\n\t\t\t\tasync saveHiddenRule() {\n\t\t\t\t\t// Validate required fields\n\t\t\t\t\tif (!this.hiddenRuleForm.name.trim() || !this.hiddenRuleForm.labelKey.trim() || !this.hiddenRuleForm.labelValue.trim()) {\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Please fill in all required fields (Name, Label Key, Label Value)');\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tawait this.createHiddenRule({\n\t\t\t\t\t\tname: this.hiddenRuleForm.name.trim(),\n\t\t\t\t\t\tlabelKey: this.hiddenRuleForm.labelKey.trim(),\n\t\t\t\t\t\tlabelValue: this.hiddenRuleForm.labelValue.trim(),\n\t\t\t\t\t\tdescription: this.hiddenRuleForm.description.trim(),\n\t\t\t\t\t\tenabled: this.hiddenRuleForm.enabled\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t// Close modal on success\n\t\t\t\t\tthis.showHiddenRuleModal = false;\n\t\t\t\t},\n\n\t\t\t\tasync createHiddenRule(ruleData) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/hidden-rules', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\tname: ruleData.name,\n\t\t\t\t\t\t\t\tlabelKey: ruleData.labelKey,\n\t\t\t\t\t\t\t\tlabelValue: ruleData.labelValue,\n\t\t\t\t\t\t\t\tdescription: ruleData.description,\n\t\t\t\t\t\t\t\tenabled: ruleData.enabled\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Add to local array\n\t\t\t\t\t\t\tthis.hiddenRules.push({\n\t\t\t\t\t\t\t\tid: result.data.id,\n\t\t\t\t\t\t\t\t...ruleData,\n\t\t\t\t\t\t\t\tcreatedAt: new Date().toISOString()\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Show success message\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('success', 'Hidden rule created successfully');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Refresh dashboard data\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.loadDashboardData();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to create hidden rule:', result.error);\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to create rule: ' + (result.error || 'Unknown error'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error creating hidden rule:', error);\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to create hidden rule');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Sentry Integration Functions\n\t\t\t\tasync loadSentryConfig() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/sentry-config', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tthis.sentryConfig = {\n\t\t\t\t\t\t\t\thasToken: result.has_token || false,\n\t\t\t\t\t\t\t\tbaseUrl: result.base_url || 'https://sentry.io',\n\t\t\t\t\t\t\t\tauthStatus: result.auth_status || 'none',\n\t\t\t\t\t\t\t\tconnectionTesting: false\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis.sentryForm.baseUrl = this.sentryConfig.baseUrl;\n\t\t\t\t\t\t\tconsole.log('Loaded Sentry config:', this.sentryConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading Sentry config:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveSentryToken() {\n\t\t\t\t\tif (!this.sentryForm.token.trim()) {\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Please enter a Sentry token');\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.sentrySaving = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/sentry-token', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\ttoken: this.sentryForm.token,\n\t\t\t\t\t\t\t\tbase_url: this.sentryForm.baseUrl\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Update config to reflect saved state\n\t\t\t\t\t\t\tthis.sentryConfig.hasToken = true;\n\t\t\t\t\t\t\tthis.sentryConfig.authStatus = 'personal_token';\n\t\t\t\t\t\t\tthis.sentryForm.token = '';  // Clear form after saving\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('success', 'Sentry token saved successfully');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', result.message || 'Failed to save Sentry token');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving Sentry token:', error);\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to save Sentry token');\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.sentrySaving = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync testSentryConnection() {\n\t\t\t\t\t// Get token and base URL from the form\n\t\t\t\t\tconst token = this.sentryForm.token;\n\t\t\t\t\tconst baseUrl = this.sentryForm.baseUrl || 'https://sentry.io';\n\n\t\t\t\t\tif (!token.trim()) {\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Please enter a token to test');\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.sentryConfig.connectionTesting = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/sentry/test-connection', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\ttoken: token,\n\t\t\t\t\t\t\t\tbase_url: baseUrl\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.valid) {\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('success', \n\t\t\t\t\t\t\t\t\tresult.message || 'Connection successful!');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', \n\t\t\t\t\t\t\t\t\tresult.message || 'Connection failed');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error testing Sentry connection:', error);\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to test connection');\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.sentryConfig.connectionTesting = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync removeSentryToken() {\n\t\t\t\t\tif (!confirm('Are you sure you want to remove your Sentry token?')) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/sentry-token', {\n\t\t\t\t\t\t\tmethod: 'DELETE',\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Update config to reflect removed state\n\t\t\t\t\t\t\tthis.sentryConfig.hasToken = false;\n\t\t\t\t\t\t\tthis.sentryConfig.authStatus = 'none';\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('success', 'Sentry token removed successfully');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', result.message || 'Failed to remove Sentry token');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error removing Sentry token:', error);\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to remove Sentry token');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Global settings modal reference for dashboard integration\n\t\twindow.settingsModalData = settingsModalData;\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
