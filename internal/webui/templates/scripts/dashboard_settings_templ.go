// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func DashboardSettings() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\t// Settings Modal Data Handler\n\t\tfunction settingsModalData() {\n\t\t\treturn {\n\t\t\t\tactiveTab: 'general',\n\t\t\t\tcolorPreferences: [],\n\t\t\t\tavailableLabels: {}, // labelKey -> [values]\n\t\t\t\tavailableLabelsLastLoaded: null, // timestamp for cache expiry\n\t\t\t\tlabelKeyTimeouts: {}, // for debouncing label key updates\n\t\t\t\t\n\t\t\t\t// Notification preferences (frontend format - camelCase)\n\t\t\t\tnotificationPreferences: {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tsoundEnabled: true,\n\t\t\t\t\tbrowserNotifications: true,\n\t\t\t\t\tcooldownSeconds: 300,\n\t\t\t\t\tmaxNotifications: 5,\n\t\t\t\t\trespectFilters: true,\n\t\t\t\t\tseverityRules: {\n\t\t\t\t\t\tcritical: true,\n\t\t\t\t\t\tmajor: true,\n\t\t\t\t\t\twarning: true,\n\t\t\t\t\t\tminor: false,\n\t\t\t\t\t\tinfo: false,\n\t\t\t\t\t\tunknown: false\n\t\t\t\t\t},\n\t\t\t\t\tsoundConfig: {}\n\t\t\t\t},\n\t\t\t\tnotificationPreferencesSaving: false,\n\t\t\t\t\n\t\t\t\tasync init() {\n\t\t\t\t\tconsole.log('Settings modal initializing...');\n\t\t\t\t\tawait this.loadColorPreferences();\n\t\t\t\t\tawait this.loadAvailableLabels();\n\t\t\t\t\tawait this.loadNotificationPreferences();\n\t\t\t\t\t// Ensure the global reference is set\n\t\t\t\t\twindow.currentSettingsModal = this;\n\t\t\t\t\tconsole.log('Settings modal initialized, window.currentSettingsModal set:', !!window.currentSettingsModal);\n\t\t\t\t},\n\n\t\t\t\tasync loadColorPreferences() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/color-preferences', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.colorPreferences = (result.data.preferences || []).map(pref => ({\n\t\t\t\t\t\t\t\t\t...pref,\n\t\t\t\t\t\t\t\t\tlabelConditions: pref.labelConditions || {},\n\t\t\t\t\t\t\t\t\tbgLightnessFactor: pref.bgLightnessFactor !== undefined ? pref.bgLightnessFactor : 0.9,\n\t\t\t\t\t\t\t\t\ttextDarknessFactor: pref.textDarknessFactor !== undefined ? pref.textDarknessFactor : 0.3\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading color preferences:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync loadAvailableLabels() {\n\t\t\t\t\t// Check if we already have cached labels and they're not too old (cache for 5 minutes)\n\t\t\t\t\tif (this.availableLabels && Object.keys(this.availableLabels).length > 0 && \n\t\t\t\t\t\tthis.availableLabelsLastLoaded && \n\t\t\t\t\t\t(Date.now() - this.availableLabelsLastLoaded) < 300000) {\n\t\t\t\t\t\tconsole.log('Using cached available labels');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconsole.log('Fetching available labels from API...');\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/available-labels', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.availableLabels = result.data.labels || {};\n\t\t\t\t\t\t\t\tthis.availableLabelsLastLoaded = Date.now();\n\t\t\t\t\t\t\t\tconsole.log('Loaded available labels:', Object.keys(this.availableLabels).length, 'label types');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading available labels:', error);\n\t\t\t\t\t\t// Fallback to empty object if fetch fails\n\t\t\t\t\t\tthis.availableLabels = {};\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveColorPreferences() {\n\t\t\t\t\tconsole.log('saveColorPreferences called with preferences:', this.colorPreferences);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/color-preferences', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\tpreferences: this.colorPreferences\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\tconsole.log('Color preferences save response:', result);\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Reload color preferences to show saved state in modal\n\t\t\t\t\t\t\tawait this.loadColorPreferences();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to save color preferences:', result.error);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving color preferences:', error);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Color preference management\n\t\t\t\taddColorPreference() {\n\t\t\t\t\tconst newPref = {\n\t\t\t\t\t\tid: String(Date.now() + Math.random()),\n\t\t\t\t\t\tlabelKey: '',\n\t\t\t\t\t\tlabelValue: '',\n\t\t\t\t\t\tcolor: '#ff9999',\n\t\t\t\t\t\tcolorType: 'custom',\n\t\t\t\t\t\tpriority: 0,\n\t\t\t\t\t\tbgLightnessFactor: 0.9,\n\t\t\t\t\t\ttextDarknessFactor: 0.3,\n\t\t\t\t\t\tisEditing: true\n\t\t\t\t\t};\n\t\t\t\t\tthis.colorPreferences.push(newPref);\n\t\t\t\t},\n\n\t\t\t\taddLabelCondition(preference) {\n\t\t\t\t\t// Add a new empty condition\n\t\t\t\t\tif (!preference.labelConditions) {\n\t\t\t\t\t\tpreference.labelConditions = {};\n\t\t\t\t\t}\n\t\t\t\t\tconst key = 'label' + Object.keys(preference.labelConditions).length;\n\t\t\t\t\tpreference.labelConditions[key] = '';\n\t\t\t\t},\n\n\t\t\t\tensureAvailableLabels() {\n\t\t\t\t\tif (!this.availableLabels || Object.keys(this.availableLabels).length === 0) {\n\t\t\t\t\t\tthis.loadAvailableLabels();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\teditColorPreference(id) {\n\t\t\t\t\tconst pref = this.colorPreferences.find(p => p.id === id);\n\t\t\t\t\tif (pref) {\n\t\t\t\t\t\tpref.isEditing = true;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tcancelEditColorPreference(id) {\n\t\t\t\t\tconst index = this.colorPreferences.findIndex(p => p.id === id);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tconst pref = this.colorPreferences[index];\n\t\t\t\t\t\tif (!pref.labelKey && !pref.labelValue) {\n\t\t\t\t\t\t\t// Remove if it's a new preference being cancelled\n\t\t\t\t\t\t\tthis.colorPreferences.splice(index, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpref.isEditing = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tremoveColorPreference(index) {\n\t\t\t\t\tthis.colorPreferences.splice(index, 1);\n\t\t\t\t},\n\n\t\t\t\tasync saveColorPreference(id) {\n\t\t\t\t\tconst pref = this.colorPreferences.find(p => p.id === id);\n\t\t\t\t\tif (!pref || !pref.labelKey.trim() || !pref.labelValue.trim()) {\n\t\t\t\t\t\tconsole.warn('Cannot save color preference: missing required fields');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst method = pref.serverId ? 'PUT' : 'POST';\n\t\t\t\t\t\tconst url = pref.serverId \n\t\t\t\t\t\t\t? `/api/v1/dashboard/color-preferences/${pref.serverId}`\n\t\t\t\t\t\t\t: '/api/v1/dashboard/color-preferences';\n\n\t\t\t\t\t\tconst response = await fetch(url, {\n\t\t\t\t\t\t\tmethod: method,\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\tlabelKey: pref.labelKey.trim(),\n\t\t\t\t\t\t\t\tlabelValue: pref.labelValue.trim(),\n\t\t\t\t\t\t\t\tcolor: pref.color,\n\t\t\t\t\t\t\t\tcolorType: pref.colorType || 'custom',\n\t\t\t\t\t\t\t\tpriority: pref.priority || 0,\n\t\t\t\t\t\t\t\tbgLightnessFactor: pref.bgLightnessFactor || 0.9,\n\t\t\t\t\t\t\t\ttextDarknessFactor: pref.textDarknessFactor || 0.3\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Update the preference with server data\n\t\t\t\t\t\t\tif (result.data && result.data.id) {\n\t\t\t\t\t\t\t\tpref.serverId = result.data.id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpref.isEditing = false;\n\t\t\t\t\t\t\tconsole.log('Color preference saved successfully');\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Trigger alert color refresh in dashboard\n\t\t\t\t\t\t\tif (window.dashboardInstance && typeof window.dashboardInstance.refreshAlertColors === 'function') {\n\t\t\t\t\t\t\t\tconsole.log('Triggering dashboard alert color refresh...');\n\t\t\t\t\t\t\t\tawait window.dashboardInstance.refreshAlertColors();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to save color preference:', result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving color preference:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync deleteColorPreference(id) {\n\t\t\t\t\tif (!confirm('Are you sure you want to delete this color preference?')) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst index = this.colorPreferences.findIndex(p => p.id === id);\n\t\t\t\t\tif (index === -1) return;\n\n\t\t\t\t\tconst pref = this.colorPreferences[index];\n\t\t\t\t\t\n\t\t\t\t\t// If it has a server ID, delete from server\n\t\t\t\t\tif (pref.serverId) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/color-preferences/${pref.serverId}`, {\n\t\t\t\t\t\t\t\tmethod: 'DELETE',\n\t\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (!result.success) {\n\t\t\t\t\t\t\t\tconsole.error('Failed to delete color preference from server:', result.error);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tconsole.error('Error deleting color preference:', error);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove from local array\n\t\t\t\t\tthis.colorPreferences.splice(index, 1);\n\t\t\t\t\tconsole.log('Color preference deleted successfully');\n\t\t\t\t\t\n\t\t\t\t\t// Trigger alert color refresh in dashboard\n\t\t\t\t\tif (window.dashboardInstance && typeof window.dashboardInstance.refreshAlertColors === 'function') {\n\t\t\t\t\t\tconsole.log('Triggering dashboard alert color refresh after deletion...');\n\t\t\t\t\t\tawait window.dashboardInstance.refreshAlertColors();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Get available values for a selected label key\n\t\t\t\tgetAvailableValuesForLabel(labelKey) {\n\t\t\t\t\treturn this.availableLabels[labelKey] || [];\n\t\t\t\t},\n\n\t\t\t\t// Get available severities from dashboard metadata\n\t\t\t\tgetAvailableSeverities() {\n\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.metadata && window.dashboardInstance.metadata.availableFilters) {\n\t\t\t\t\t\treturn window.dashboardInstance.metadata.availableFilters.severities || [];\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t},\n\n\t\t\t\t// Initialize dynamic severity rules based on available severities\n\t\t\t\tinitializeDynamicSeverityRules() {\n\t\t\t\t\tconst availableSeverities = this.getAvailableSeverities();\n\t\t\t\t\tconst currentRules = this.notificationPreferences.severityRules || {};\n\t\t\t\t\tconst newRules = {};\n\n\t\t\t\t\t// Keep existing preferences for known severities\n\t\t\t\t\tavailableSeverities.forEach(severity => {\n\t\t\t\t\t\tconst severityKey = severity.toLowerCase();\n\t\t\t\t\t\t// Use existing preference if available, otherwise default based on severity type\n\t\t\t\t\t\tif (currentRules.hasOwnProperty(severityKey)) {\n\t\t\t\t\t\t\tnewRules[severityKey] = currentRules[severityKey];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Default rules: enable critical, warning, major; disable others\n\t\t\t\t\t\t\tnewRules[severityKey] = ['critical', 'major', 'warning'].includes(severityKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// Update notification preferences with dynamic rules\n\t\t\t\t\tthis.notificationPreferences.severityRules = newRules;\n\t\t\t\t},\n\n\t\t\t\t// Debounced update for label condition keys to improve performance\n\t\t\t\tupdateLabelConditionKey(preference, oldKey, newKey) {\n\t\t\t\t\tif (oldKey !== newKey && newKey.trim() !== '') {\n\t\t\t\t\t\tconst value = preference.labelConditions[oldKey];\n\t\t\t\t\t\tdelete preference.labelConditions[oldKey];\n\t\t\t\t\t\tpreference.labelConditions[newKey] = value;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Debounced version for input events - only updates after user stops typing\n\t\t\t\tdebouncedUpdateLabelConditionKey(preference, oldKey, newKey) {\n\t\t\t\t\t// Clear existing timeout for this specific input\n\t\t\t\t\tconst timeoutKey = `${preference.id}-${oldKey}`;\n\t\t\t\t\tif (this.labelKeyTimeouts && this.labelKeyTimeouts[timeoutKey]) {\n\t\t\t\t\t\tclearTimeout(this.labelKeyTimeouts[timeoutKey]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Initialize timeouts object if it doesn't exist\n\t\t\t\t\tif (!this.labelKeyTimeouts) {\n\t\t\t\t\t\tthis.labelKeyTimeouts = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set new timeout to update after 300ms of no typing\n\t\t\t\t\tthis.labelKeyTimeouts[timeoutKey] = setTimeout(() => {\n\t\t\t\t\t\tthis.updateLabelConditionKey(preference, oldKey, newKey);\n\t\t\t\t\t\tdelete this.labelKeyTimeouts[timeoutKey];\n\t\t\t\t\t}, 300);\n\t\t\t\t},\n\n\t\t\t\t// Get severity color for UI display\n\t\t\t\tgetSeverityColor(severity) {\n\t\t\t\t\tconst severityLower = severity.toLowerCase();\n\t\t\t\t\tconst colorMap = {\n\t\t\t\t\t\t'critical': 'red',\n\t\t\t\t\t\t'major': 'orange', \n\t\t\t\t\t\t'warning': 'yellow',\n\t\t\t\t\t\t'minor': 'blue',\n\t\t\t\t\t\t'info': 'green',\n\t\t\t\t\t\t'information': 'green',\n\t\t\t\t\t\t'unknown': 'gray'\n\t\t\t\t\t};\n\t\t\t\t\treturn colorMap[severityLower] || 'gray';\n\t\t\t\t},\n\n\t\t\t\t// Get severity display name\n\t\t\t\tgetSeverityDisplayName(severity) {\n\t\t\t\t\tconst displayMap = {\n\t\t\t\t\t\t'info': 'Info',\n\t\t\t\t\t\t'information': 'Info',\n\t\t\t\t\t\t'critical': 'Critical',\n\t\t\t\t\t\t'major': 'Major',\n\t\t\t\t\t\t'warning': 'Warning',\n\t\t\t\t\t\t'minor': 'Minor',\n\t\t\t\t\t\t'unknown': 'Unknown'\n\t\t\t\t\t};\n\t\t\t\t\treturn displayMap[severity.toLowerCase()] || severity.charAt(0).toUpperCase() + severity.slice(1);\n\t\t\t\t},\n\n\t\t\t\t// Initialize dynamic sound configuration based on available severities\n\t\t\t\tinitializeDynamicSoundConfig() {\n\t\t\t\t\tconst availableSeverities = this.getAvailableSeverities();\n\t\t\t\t\tconst currentSoundConfig = this.notificationPreferences.soundConfig || {};\n\t\t\t\t\tconst newSoundConfig = {};\n\n\t\t\t\t\t// Process each available severity\n\t\t\t\t\tavailableSeverities.forEach(severity => {\n\t\t\t\t\t\tconst severityKey = severity.toLowerCase();\n\t\t\t\t\t\tconst freqKey = `${severityKey}_frequency`;\n\t\t\t\t\t\tconst durKey = `${severityKey}_duration`;\n\t\t\t\t\t\tconst typeKey = `${severityKey}_type`;\n\n\t\t\t\t\t\t// Use existing config if available, otherwise use defaults\n\t\t\t\t\t\tif (currentSoundConfig.hasOwnProperty(freqKey)) {\n\t\t\t\t\t\t\tnewSoundConfig[freqKey] = currentSoundConfig[freqKey];\n\t\t\t\t\t\t\tnewSoundConfig[durKey] = currentSoundConfig[durKey];\n\t\t\t\t\t\t\tnewSoundConfig[typeKey] = currentSoundConfig[typeKey];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Set intelligent defaults based on severity type\n\t\t\t\t\t\t\tconst defaults = this.getDefaultSoundConfigForSeverity(severityKey);\n\t\t\t\t\t\t\tnewSoundConfig[freqKey] = defaults.frequency;\n\t\t\t\t\t\t\tnewSoundConfig[durKey] = defaults.duration;\n\t\t\t\t\t\t\tnewSoundConfig[typeKey] = defaults.type;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// Update notification preferences with dynamic sound config\n\t\t\t\t\tthis.notificationPreferences.soundConfig = newSoundConfig;\n\t\t\t\t},\n\n\t\t\t\t// Get default sound configuration for a severity\n\t\t\t\tgetDefaultSoundConfigForSeverity(severity) {\n\t\t\t\t\tconst severityLower = severity.toLowerCase();\n\t\t\t\t\t\n\t\t\t\t\t// Default configurations based on severity urgency\n\t\t\t\t\tswitch (severityLower) {\n\t\t\t\t\t\tcase 'critical':\n\t\t\t\t\t\tcase 'major':\n\t\t\t\t\t\t\treturn { frequency: 800, duration: 200, type: 'square' };\n\t\t\t\t\t\tcase 'warning':\n\t\t\t\t\t\tcase 'minor':\n\t\t\t\t\t\t\treturn { frequency: 600, duration: 150, type: 'sine' };\n\t\t\t\t\t\tcase 'info':\n\t\t\t\t\t\tcase 'information':\n\t\t\t\t\t\t\treturn { frequency: 400, duration: 100, type: 'sine' };\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// Unknown severities get a neutral sound\n\t\t\t\t\t\t\treturn { frequency: 500, duration: 120, type: 'triangle' };\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Test sound with current form settings (preview functionality)\n\t\t\t\ttestSoundWithPreview(severity) {\n\t\t\t\t\tif (!window.dashboardInstance || !window.dashboardInstance.audioContext) {\n\t\t\t\t\t\tconsole.warn('Audio context not available for sound preview');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst severityKey = severity.toLowerCase();\n\t\t\t\t\t\n\t\t\t\t\t// Read current values directly from DOM elements to get the most up-to-date user input\n\t\t\t\t\tconst frequencyInput = document.querySelector(`input[type=\"number\"][x-model*=\"${severityKey}_frequency\"]`);\n\t\t\t\t\tconst durationInput = document.querySelector(`input[type=\"number\"][x-model*=\"${severityKey}_duration\"]`);\n\t\t\t\t\tconst typeSelect = document.querySelector(`select[x-model*=\"${severityKey}_type\"]`);\n\t\t\t\t\t\n\t\t\t\t\tconst soundConfig = {\n\t\t\t\t\t\tfrequency: frequencyInput ? parseInt(frequencyInput.value) || 500 : 500,\n\t\t\t\t\t\tduration: durationInput ? parseInt(durationInput.value) || 150 : 150,\n\t\t\t\t\t\ttype: typeSelect ? typeSelect.value || 'sine' : 'sine'\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tconsole.log(`Testing sound for ${severity} with current form values:`, soundConfig);\n\t\t\t\t\tthis.playPreviewSound(soundConfig);\n\t\t\t\t},\n\n\t\t\t\t// Play sound with specific configuration (for testing)\n\t\t\t\tplayPreviewSound(soundConfig) {\n\t\t\t\t\tif (!window.dashboardInstance || !window.dashboardInstance.audioContext) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst audioContext = window.dashboardInstance.audioContext;\n\t\t\t\t\t\tconst oscillator = audioContext.createOscillator();\n\t\t\t\t\t\tconst gainNode = audioContext.createGain();\n\t\t\t\t\t\t\n\t\t\t\t\t\toscillator.connect(gainNode);\n\t\t\t\t\t\tgainNode.connect(audioContext.destination);\n\t\t\t\t\t\t\n\t\t\t\t\t\toscillator.frequency.setValueAtTime(soundConfig.frequency, audioContext.currentTime);\n\t\t\t\t\t\toscillator.type = soundConfig.type;\n\t\t\t\t\t\t\n\t\t\t\t\t\tgainNode.gain.setValueAtTime(0.1, audioContext.currentTime);\n\t\t\t\t\t\tgainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + soundConfig.duration / 1000);\n\t\t\t\t\t\t\n\t\t\t\t\t\toscillator.start(audioContext.currentTime);\n\t\t\t\t\t\toscillator.stop(audioContext.currentTime + soundConfig.duration / 1000);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.warn('Failed to play preview sound:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Get current sound config from DOM form values (for saving real-time user input)\n\t\t\t\tgetCurrentSoundConfigFromDOM() {\n\t\t\t\t\tconst availableSeverities = this.getAvailableSeverities();\n\t\t\t\t\tconst currentSoundConfig = {};\n\t\t\t\t\t\n\t\t\t\t\t// Read current form values for each available severity\n\t\t\t\t\tavailableSeverities.forEach(severity => {\n\t\t\t\t\t\tconst severityKey = severity.toLowerCase();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Query DOM for frequency, duration, and type inputs\n\t\t\t\t\t\tconst frequencyInput = document.querySelector(`input[type=\"number\"][x-model*=\"${severityKey}_frequency\"]`);\n\t\t\t\t\t\tconst durationInput = document.querySelector(`input[type=\"number\"][x-model*=\"${severityKey}_duration\"]`);\n\t\t\t\t\t\tconst typeSelect = document.querySelector(`select[x-model*=\"${severityKey}_type\"]`);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Extract values with defaults and ensure clean data types\n\t\t\t\t\t\tconst freqKey = `${severityKey}_frequency`;\n\t\t\t\t\t\tconst durKey = `${severityKey}_duration`;\n\t\t\t\t\t\tconst typeKey = `${severityKey}_type`;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Ensure integers are clean and valid\n\t\t\t\t\t\tlet frequency = 500;\n\t\t\t\t\t\tlet duration = 150;\n\t\t\t\t\t\tlet soundType = 'sine';\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (frequencyInput && frequencyInput.value) {\n\t\t\t\t\t\t\tconst parsedFreq = parseInt(frequencyInput.value, 10);\n\t\t\t\t\t\t\tfrequency = (isNaN(parsedFreq) || parsedFreq < 100 || parsedFreq > 2000) ? 500 : parsedFreq;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (durationInput && durationInput.value) {\n\t\t\t\t\t\t\tconst parsedDur = parseInt(durationInput.value, 10);\n\t\t\t\t\t\t\tduration = (isNaN(parsedDur) || parsedDur < 50 || parsedDur > 5000) ? 150 : parsedDur;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (typeSelect && typeSelect.value) {\n\t\t\t\t\t\t\tconst validTypes = ['sine', 'square', 'triangle', 'sawtooth'];\n\t\t\t\t\t\t\tsoundType = validTypes.includes(typeSelect.value) ? typeSelect.value : 'sine';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tcurrentSoundConfig[freqKey] = frequency;\n\t\t\t\t\t\tcurrentSoundConfig[durKey] = duration;\n\t\t\t\t\t\tcurrentSoundConfig[typeKey] = soundType;\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tconsole.log('Reading current sound config from DOM:', currentSoundConfig);\n\t\t\t\t\treturn currentSoundConfig;\n\t\t\t\t},\n\n\t\t\t\t// Preview the color combination with lightness factors\n\t\t\t\tgetPreviewStyle(pref) {\n\t\t\t\t\tif (!pref.color) return '';\n\t\t\t\t\t\n\t\t\t\t\t// Use the base color and apply lightness factors\n\t\t\t\t\tconst baseColor = pref.color;\n\t\t\t\t\tconst bgLightness = pref.bgLightnessFactor || 0.9;\n\t\t\t\t\tconst textDarkness = pref.textDarknessFactor || 0.3;\n\t\t\t\t\t\n\t\t\t\t\t// For custom colors, simulate the lightening/darkening effects\n\t\t\t\t\tif (pref.colorType === 'custom' && baseColor.startsWith('#')) {\n\t\t\t\t\t\tconst bgColor = this.lightenColorSimulation(baseColor, bgLightness);\n\t\t\t\t\t\tconst textColor = this.darkenColorSimulation(baseColor, textDarkness);\n\t\t\t\t\t\treturn `background-color: ${bgColor}; color: ${textColor}; padding: 2px 8px; border-radius: 4px; display: inline-block; min-width: 60px; text-align: center; border: 1px solid ${baseColor};`;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// For other color types, just use the base color\n\t\t\t\t\treturn `background-color: ${baseColor}; color: white; padding: 2px 8px; border-radius: 4px; display: inline-block; min-width: 60px; text-align: center;`;\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Simple color lightening simulation for preview\n\t\t\t\tlightenColorSimulation(hexColor, factor) {\n\t\t\t\t\t// Remove # if present\n\t\t\t\t\tconst hex = hexColor.replace('#', '');\n\t\t\t\t\tconst r = parseInt(hex.substr(0, 2), 16);\n\t\t\t\t\tconst g = parseInt(hex.substr(2, 2), 16);\n\t\t\t\t\tconst b = parseInt(hex.substr(4, 2), 16);\n\t\t\t\t\t\n\t\t\t\t\t// Lighten by interpolating towards white\n\t\t\t\t\tconst newR = Math.round(r + (255 - r) * factor);\n\t\t\t\t\tconst newG = Math.round(g + (255 - g) * factor);\n\t\t\t\t\tconst newB = Math.round(b + (255 - b) * factor);\n\t\t\t\t\t\n\t\t\t\t\treturn `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Simple color darkening simulation for preview\n\t\t\t\tdarkenColorSimulation(hexColor, factor) {\n\t\t\t\t\t// Remove # if present\n\t\t\t\t\tconst hex = hexColor.replace('#', '');\n\t\t\t\t\tconst r = parseInt(hex.substr(0, 2), 16);\n\t\t\t\t\tconst g = parseInt(hex.substr(2, 2), 16);\n\t\t\t\t\tconst b = parseInt(hex.substr(4, 2), 16);\n\t\t\t\t\t\n\t\t\t\t\t// Darken by interpolating towards black\n\t\t\t\t\tconst newR = Math.round(r * (1 - factor));\n\t\t\t\t\tconst newG = Math.round(g * (1 - factor));\n\t\t\t\t\tconst newB = Math.round(b * (1 - factor));\n\t\t\t\t\t\n\t\t\t\t\treturn `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;\n\t\t\t\t},\n\n\t\t\t\t// Tab management\n\t\t\t\tsetActiveTab(tab) {\n\t\t\t\t\tthis.activeTab = tab;\n\t\t\t\t\tif (tab === 'colors') {\n\t\t\t\t\t\t// Refresh available labels when opening colors tab\n\t\t\t\t\t\tthis.loadAvailableLabels();\n\t\t\t\t\t} else if (tab === 'notifications') {\n\t\t\t\t\t\t// Reload notification preferences to ensure fresh backend data (like color preferences)\n\t\t\t\t\t\tthis.loadNotificationPreferences();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Form validation\n\t\t\t\tisValidColorPreference(pref) {\n\t\t\t\t\treturn pref.labelKey.trim() && pref.labelValue.trim() && pref.color;\n\t\t\t\t},\n\n\t\t\t\t// Check if a color preference has unsaved changes\n\t\t\t\thasUnsavedChanges(pref) {\n\t\t\t\t\treturn pref.isEditing;\n\t\t\t\t},\n\n\t\t\t\t// Color utility functions\n\t\t\t\tgenerateRandomColor() {\n\t\t\t\t\tconst colors = [\n\t\t\t\t\t\t'#ff9999', '#99ff99', '#9999ff', '#ffff99', '#ff99ff', '#99ffff',\n\t\t\t\t\t\t'#ffcc99', '#cc99ff', '#99ffcc', '#ccff99', '#ff99cc', '#99ccff'\n\t\t\t\t\t];\n\t\t\t\t\treturn colors[Math.floor(Math.random() * colors.length)];\n\t\t\t\t},\n\n\t\t\t\t// Get contrasting text color for background\n\t\t\t\tgetContrastingTextColor(bgColor) {\n\t\t\t\t\t// Simple contrast calculation - convert hex to RGB and check luminance\n\t\t\t\t\tconst hex = bgColor.replace('#', '');\n\t\t\t\t\tconst r = parseInt(hex.substr(0, 2), 16);\n\t\t\t\t\tconst g = parseInt(hex.substr(2, 2), 16);\n\t\t\t\t\tconst b = parseInt(hex.substr(4, 2), 16);\n\t\t\t\t\t\n\t\t\t\t\t// Calculate luminance\n\t\t\t\t\tconst luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n\t\t\t\t\t\n\t\t\t\t\treturn luminance > 0.5 ? '#000000' : '#ffffff';\n\t\t\t\t},\n\n\t\t\t\t// Auto-set contrasting text color when background changes\n\t\t\t\tonBgColorChange(pref) {\n\t\t\t\t\tpref.textColor = this.getContrastingTextColor(pref.bgColor);\n\t\t\t\t},\n\n\t\t\t\t// Notification Preference Methods\n\t\t\t\tasync loadNotificationPreferences() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/notification-preferences', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success && result.data.preference) {\n\t\t\t\t\t\t\t\tconst backendPrefs = result.data.preference;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Convert backend format (snake_case) to frontend format (camelCase)\n\t\t\t\t\t\t\t\tconst frontendPrefs = {\n\t\t\t\t\t\t\t\t\tenabled: backendPrefs.enabled,\n\t\t\t\t\t\t\t\t\tsoundEnabled: backendPrefs.sound_enabled,\n\t\t\t\t\t\t\t\t\tbrowserNotifications: backendPrefs.browser_notifications,\n\t\t\t\t\t\t\t\t\tcooldownSeconds: backendPrefs.cooldown_seconds,\n\t\t\t\t\t\t\t\t\tmaxNotifications: backendPrefs.max_notifications,\n\t\t\t\t\t\t\t\t\trespectFilters: backendPrefs.respect_filters,\n\t\t\t\t\t\t\t\t\tseverityRules: backendPrefs.severity_rules || {},\n\t\t\t\t\t\t\t\t\tsoundConfig: backendPrefs.sound_config || {}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Merge with defaults, preferring loaded values\n\t\t\t\t\t\t\t\tthis.notificationPreferences = { \n\t\t\t\t\t\t\t\t\t...this.notificationPreferences, \n\t\t\t\t\t\t\t\t\t...frontendPrefs \n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tconsole.log('Loaded notification preferences:', this.notificationPreferences);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Initialize dynamic severity rules after loading preferences\n\t\t\t\t\t\t\t\tthis.initializeDynamicSeverityRules();\n\t\t\t\t\t\t\t\t// Initialize dynamic sound configuration\n\t\t\t\t\t\t\t\tthis.initializeDynamicSoundConfig();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading notification preferences:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveNotificationPreferences() {\n\t\t\t\t\tconsole.log('Starting saveNotificationPreferences() from settings modal');\n\t\t\t\t\tthis.notificationPreferencesSaving = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Get current sound config from DOM to capture real-time user input\n\t\t\t\t\t\tconst currentSoundConfig = this.getCurrentSoundConfigFromDOM();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Pre-validate JSON serialization to catch issues early\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tJSON.stringify(currentSoundConfig);\n\t\t\t\t\t\t} catch (jsonError) {\n\t\t\t\t\t\t\tconsole.error('Invalid sound config data - cannot serialize to JSON:', jsonError);\n\t\t\t\t\t\t\tconsole.error('Problematic data:', currentSoundConfig);\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Invalid sound configuration data. Please check your settings.');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Clean up the payload and convert frontend format to backend format\n\t\t\t\t\t\tconst cleanPreferences = {\n\t\t\t\t\t\t\tenabled: this.notificationPreferences.enabled,\n\t\t\t\t\t\t\tsound_enabled: this.notificationPreferences.soundEnabled,\n\t\t\t\t\t\t\tbrowser_notifications: this.notificationPreferences.browserNotifications,\n\t\t\t\t\t\t\tcooldown_seconds: this.notificationPreferences.cooldownSeconds,\n\t\t\t\t\t\t\tmax_notifications: this.notificationPreferences.maxNotifications,\n\t\t\t\t\t\t\trespect_filters: this.notificationPreferences.respectFilters,\n\t\t\t\t\t\t\tseverity_rules: this.notificationPreferences.severityRules,\n\t\t\t\t\t\t\tsound_config: currentSoundConfig  // Use real DOM values instead of cached data\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconsole.log('Sending notification preferences to server:', cleanPreferences);\n\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/notification-preferences', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\tbody: JSON.stringify({ preference: cleanPreferences })\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tconsole.log('Notification preferences saved successfully');\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Show success message\n\t\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('success', 'Notification preferences saved successfully');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.error('Failed to save notification preferences:', result.error);\n\t\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Failed to save notification preferences: ' + result.error);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving notification preferences:', error);\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showNotification) {\n\t\t\t\t\t\t\twindow.dashboardInstance.showNotification('error', 'Error saving notification preferences');\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.notificationPreferencesSaving = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\ttestNotification() {\n\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.showInAppNotification) {\n\t\t\t\t\t\twindow.dashboardInstance.showInAppNotification('info', 'Test notification - your notification settings are working!');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Also test sound if enabled\n\t\t\t\t\tif (this.notificationPreferences.sound_enabled && window.dashboardInstance && window.dashboardInstance.playNotificationSound) {\n\t\t\t\t\t\twindow.dashboardInstance.playNotificationSound('info');\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\ttestSound(severity) {\n\t\t\t\t\t// Use the new preview functionality that uses current form settings\n\t\t\t\t\tthis.testSoundWithPreview(severity);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Global settings modal reference for dashboard integration\n\t\twindow.settingsModalData = settingsModalData;\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
