// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func DashboardSettings() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\tfunction settingsModalData() {\n\t\t\treturn {\n\t\t\t\tactiveTab: 'general',\n\t\t\t\tcolorPreferences: [],\n\t\t\t\tavailableLabels: {},\n\t\t\t\tavailableLabelsLastLoaded: null,\n\t\t\t\tlabelKeyTimeouts: {},\n\t\t\t\t\n\t\t\t\t// Hidden alerts data\n\t\t\t\thiddenAlerts: [],\n\t\t\t\thiddenRules: [],\n\t\t\t\thiddenAlertsLoading: false,\n\t\t\t\thiddenRulesLoading: false,\n\t\t\t\t\n\t\t\t\t// Hidden Rules Modal\n\t\t\t\tshowHiddenRuleModal: false,\n\t\t\t\thiddenRuleForm: {\n\t\t\t\t\tname: '',\n\t\t\t\t\tlabelKey: '',\n\t\t\t\t\tlabelValue: '',\n\t\t\t\t\tdescription: '',\n\t\t\t\t\tenabled: true\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tsettings: {\n\t\t\t\t\ttheme: 'light',\n\t\t\t\t\tresolvedAlertsLimit: 100,\n\t\t\t\t\trefreshInterval: 30\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Sentry integration data\n\t\t\t\tsentryConfig: {\n\t\t\t\t\thasToken: false,\n\t\t\t\t\tbaseUrl: 'https://sentry.io',\n\t\t\t\t\tauthStatus: 'none',\n\t\t\t\t\tconnectionTesting: false\n\t\t\t\t},\n\t\t\t\tsentryForm: {\n\t\t\t\t\ttoken: '',\n\t\t\t\t\tbaseUrl: 'https://sentry.io'\n\t\t\t\t},\n\t\t\t\tsentrySaving: false,\n\t\t\t\tsettingsSaving: false,\n\n\t\t\t\t// Notification preferences\n\t\t\t\tnotificationPreferences: {\n\t\t\t\t\tbrowserNotificationsEnabled: false,\n\t\t\t\t\tenabledSeverities: ['critical', 'warning'],\n\t\t\t\t\tsoundNotificationsEnabled: true\n\t\t\t\t},\n\t\t\t\t// Browser notification permission (reactive state for UI)\n\t\t\t\tbrowserNotificationPermission: 'default', // 'default', 'granted', 'denied'\n\n\t\t\t\tasync init() {\n\t\t\t\t\tconsole.log('Settings modal initializing...');\n\t\t\t\t\tawait this.loadSettings();\n\t\t\t\t\tawait this.loadColorPreferences();\n\t\t\t\t\tawait this.loadAvailableLabels();\n\t\t\t\t\tawait this.loadHiddenAlerts();\n\t\t\t\t\tawait this.loadHiddenRules();\n\t\t\t\t\tawait this.loadSentryConfig();\n\t\t\t\t\tawait this.loadNotificationPreferences();\n\t\t\t\t\tawait this.loadAnnotationButtonConfigs();\n\t\t\t\t\tthis.checkBrowserPermission(); // Check current browser permission status\n\t\t\t\t\twindow.currentSettingsModal = this;\n\t\t\t\t\tconsole.log('Settings modal initialized, window.currentSettingsModal set:', !!window.currentSettingsModal);\n\t\t\t\t},\n\n\t\t\t\tasync loadSettings() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Load settings from localStorage for now (can be extended to backend later)\n\t\t\t\t\t\tconst savedSettings = localStorage.getItem('dashboardSettings');\n\t\t\t\t\t\tif (savedSettings) {\n\t\t\t\t\t\t\tconst parsedSettings = JSON.parse(savedSettings);\n\t\t\t\t\t\t\tthis.settings = { ...this.settings, ...parsedSettings };\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Also check for theme preference from dashboard instance\n\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.currentTheme) {\n\t\t\t\t\t\t\tthis.settings.theme = window.dashboardInstance.currentTheme;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tconsole.log('Loaded general settings:', this.settings);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading general settings:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync loadColorPreferences() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/color-preferences', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.colorPreferences = (result.data.preferences || []).map(pref => ({\n\t\t\t\t\t\t\t\t\t...pref,\n\t\t\t\t\t\t\t\t\tlabelConditions: pref.labelConditions || {},\n\t\t\t\t\t\t\t\t\tbgLightnessFactor: pref.bgLightnessFactor !== undefined ? pref.bgLightnessFactor : 0.9,\n\t\t\t\t\t\t\t\t\ttextDarknessFactor: pref.textDarknessFactor !== undefined ? pref.textDarknessFactor : 0.3\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading color preferences:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync loadAvailableLabels() {\n\t\t\t\t\t// Check if we already have cached labels and they're not too old (cache for 5 minutes)\n\t\t\t\t\tif (this.availableLabels && Object.keys(this.availableLabels).length > 0 && \n\t\t\t\t\t\tthis.availableLabelsLastLoaded && \n\t\t\t\t\t\t(Date.now() - this.availableLabelsLastLoaded) < 300000) {\n\t\t\t\t\t\tconsole.log('Using cached available labels');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconsole.log('Fetching available labels from API...');\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/available-labels', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.availableLabels = result.data.labels || {};\n\t\t\t\t\t\t\t\tthis.availableLabelsLastLoaded = Date.now();\n\t\t\t\t\t\t\t\tconsole.log('Loaded available labels:', Object.keys(this.availableLabels).length, 'label types');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading available labels:', error);\n\t\t\t\t\t\t// Fallback to empty object if fetch fails\n\t\t\t\t\t\tthis.availableLabels = {};\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveColorPreferences() {\n\t\t\t\t\tconsole.log('saveColorPreferences called with preferences:', this.colorPreferences);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/color-preferences', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\tpreferences: this.colorPreferences\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\tconsole.log('Color preferences save response:', result);\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Reload color preferences to show saved state in modal\n\t\t\t\t\t\t\tawait this.loadColorPreferences();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to save color preferences:', result.error);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving color preferences:', error);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\taddColorPreference() {\n\t\t\t\t\tconst newPref = {\n\t\t\t\t\t\tid: String(Date.now() + Math.random()),\n\t\t\t\t\t\tlabelKey: '',\n\t\t\t\t\t\tlabelValue: '',\n\t\t\t\t\t\tcolor: '#ff9999',\n\t\t\t\t\t\tcolorType: 'custom',\n\t\t\t\t\t\tpriority: 0,\n\t\t\t\t\t\tbgLightnessFactor: 0.9,\n\t\t\t\t\t\ttextDarknessFactor: 0.3,\n\t\t\t\t\t\tisEditing: true\n\t\t\t\t\t};\n\t\t\t\t\tthis.colorPreferences.push(newPref);\n\t\t\t\t},\n\n\t\t\t\taddLabelCondition(preference) {\n\t\t\t\t\tif (!preference.labelConditions) {\n\t\t\t\t\t\tpreference.labelConditions = {};\n\t\t\t\t\t}\n\t\t\t\t\tconst key = 'label' + Object.keys(preference.labelConditions).length;\n\t\t\t\t\tpreference.labelConditions[key] = '';\n\t\t\t\t},\n\n\t\t\t\tensureAvailableLabels() {\n\t\t\t\t\tif (!this.availableLabels || Object.keys(this.availableLabels).length === 0) {\n\t\t\t\t\t\tthis.loadAvailableLabels();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\teditColorPreference(id) {\n\t\t\t\t\tconst pref = this.colorPreferences.find(p => p.id === id);\n\t\t\t\t\tif (pref) {\n\t\t\t\t\t\tpref.isEditing = true;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tcancelEditColorPreference(id) {\n\t\t\t\t\tconst index = this.colorPreferences.findIndex(p => p.id === id);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tconst pref = this.colorPreferences[index];\n\t\t\t\t\t\tif (!pref.labelKey && !pref.labelValue) {\n\t\t\t\t\t\t\t// Remove if it's a new preference being cancelled\n\t\t\t\t\t\t\tthis.colorPreferences.splice(index, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpref.isEditing = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tremoveColorPreference(index) {\n\t\t\t\t\tthis.colorPreferences.splice(index, 1);\n\t\t\t\t},\n\n\t\t\t\t// Get available values for a selected label key\n\t\t\t\tgetAvailableValuesForLabel(labelKey) {\n\t\t\t\t\treturn this.availableLabels[labelKey] || [];\n\t\t\t\t},\n\n\t\t\t\t// Get available severities from dashboard metadata\n\t\t\t\tgetAvailableSeverities() {\n\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.metadata && window.dashboardInstance.metadata.availableFilters) {\n\t\t\t\t\t\treturn window.dashboardInstance.metadata.availableFilters.severities || [];\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t},\n\n\n\t\t\t\t// Debounced update for label condition keys to improve performance\n\t\t\t\tupdateLabelConditionKey(preference, oldKey, newKey) {\n\t\t\t\t\tif (oldKey !== newKey && newKey.trim() !== '') {\n\t\t\t\t\t\tconst value = preference.labelConditions[oldKey];\n\t\t\t\t\t\tdelete preference.labelConditions[oldKey];\n\t\t\t\t\t\tpreference.labelConditions[newKey] = value;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Debounced version for input events - only updates after user stops typing\n\t\t\t\tdebouncedUpdateLabelConditionKey(preference, oldKey, newKey) {\n\t\t\t\t\t// Clear existing timeout for this specific input\n\t\t\t\t\tconst timeoutKey = `${preference.id}-${oldKey}`;\n\t\t\t\t\tif (this.labelKeyTimeouts && this.labelKeyTimeouts[timeoutKey]) {\n\t\t\t\t\t\tclearTimeout(this.labelKeyTimeouts[timeoutKey]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Initialize timeouts object if it doesn't exist\n\t\t\t\t\tif (!this.labelKeyTimeouts) {\n\t\t\t\t\t\tthis.labelKeyTimeouts = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set new timeout to update after 300ms of no typing\n\t\t\t\t\tthis.labelKeyTimeouts[timeoutKey] = setTimeout(() => {\n\t\t\t\t\t\tthis.updateLabelConditionKey(preference, oldKey, newKey);\n\t\t\t\t\t\tdelete this.labelKeyTimeouts[timeoutKey];\n\t\t\t\t\t}, 300);\n\t\t\t\t},\n\n\t\t\t\t// Get severity color for UI display\n\t\t\t\tgetSeverityColor(severity) {\n\t\t\t\t\tconst severityLower = severity.toLowerCase();\n\t\t\t\t\tconst colorMap = {\n\t\t\t\t\t\t'critical': 'red',\n\t\t\t\t\t\t'major': 'orange', \n\t\t\t\t\t\t'warning': 'yellow',\n\t\t\t\t\t\t'minor': 'blue',\n\t\t\t\t\t\t'info': 'green',\n\t\t\t\t\t\t'information': 'green',\n\t\t\t\t\t\t'unknown': 'gray'\n\t\t\t\t\t};\n\t\t\t\t\treturn colorMap[severityLower] || 'gray';\n\t\t\t\t},\n\n\t\t\t\t// Get severity display name\n\t\t\t\tgetSeverityDisplayName(severity) {\n\t\t\t\t\tconst displayMap = {\n\t\t\t\t\t\t'info': 'Info',\n\t\t\t\t\t\t'information': 'Info',\n\t\t\t\t\t\t'critical': 'Critical',\n\t\t\t\t\t\t'major': 'Major',\n\t\t\t\t\t\t'warning': 'Warning',\n\t\t\t\t\t\t'minor': 'Minor',\n\t\t\t\t\t\t'unknown': 'Unknown'\n\t\t\t\t\t};\n\t\t\t\t\treturn displayMap[severity.toLowerCase()] || severity.charAt(0).toUpperCase() + severity.slice(1);\n\t\t\t\t},\n\n\n\t\t\t\t// Preview the color combination with lightness factors\n\t\t\t\tgetPreviewStyle(pref) {\n\t\t\t\t\tif (!pref.color) return '';\n\t\t\t\t\t\n\t\t\t\t\t// Use the base color and apply lightness factors\n\t\t\t\t\tconst baseColor = pref.color;\n\t\t\t\t\tconst bgLightness = pref.bgLightnessFactor || 0.9;\n\t\t\t\t\tconst textDarkness = pref.textDarknessFactor || 0.3;\n\t\t\t\t\t\n\t\t\t\t\t// For custom colors, simulate the lightening/darkening effects\n\t\t\t\t\tif (pref.colorType === 'custom' && baseColor.startsWith('#')) {\n\t\t\t\t\t\tconst bgColor = this.lightenColorSimulation(baseColor, bgLightness);\n\t\t\t\t\t\tconst textColor = this.darkenColorSimulation(baseColor, textDarkness);\n\t\t\t\t\t\treturn `background-color: ${bgColor}; color: ${textColor}; padding: 2px 8px; border-radius: 4px; display: inline-block; min-width: 60px; text-align: center; border: 1px solid ${baseColor};`;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// For other color types, just use the base color\n\t\t\t\t\treturn `background-color: ${baseColor}; color: white; padding: 2px 8px; border-radius: 4px; display: inline-block; min-width: 60px; text-align: center;`;\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Simple color lightening simulation for preview\n\t\t\t\tlightenColorSimulation(hexColor, factor) {\n\t\t\t\t\t// Remove # if present\n\t\t\t\t\tconst hex = hexColor.replace('#', '');\n\t\t\t\t\tconst r = parseInt(hex.substr(0, 2), 16);\n\t\t\t\t\tconst g = parseInt(hex.substr(2, 2), 16);\n\t\t\t\t\tconst b = parseInt(hex.substr(4, 2), 16);\n\t\t\t\t\t\n\t\t\t\t\t// Lighten by interpolating towards white\n\t\t\t\t\tconst newR = Math.round(r + (255 - r) * factor);\n\t\t\t\t\tconst newG = Math.round(g + (255 - g) * factor);\n\t\t\t\t\tconst newB = Math.round(b + (255 - b) * factor);\n\t\t\t\t\t\n\t\t\t\t\treturn `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Simple color darkening simulation for preview\n\t\t\t\tdarkenColorSimulation(hexColor, factor) {\n\t\t\t\t\t// Remove # if present\n\t\t\t\t\tconst hex = hexColor.replace('#', '');\n\t\t\t\t\tconst r = parseInt(hex.substr(0, 2), 16);\n\t\t\t\t\tconst g = parseInt(hex.substr(2, 2), 16);\n\t\t\t\t\tconst b = parseInt(hex.substr(4, 2), 16);\n\t\t\t\t\t\n\t\t\t\t\t// Darken by interpolating towards black\n\t\t\t\t\tconst newR = Math.round(r * (1 - factor));\n\t\t\t\t\tconst newG = Math.round(g * (1 - factor));\n\t\t\t\t\tconst newB = Math.round(b * (1 - factor));\n\t\t\t\t\t\n\t\t\t\t\treturn `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;\n\t\t\t\t},\n\n\t\t\t\t// Tab management\n\t\t\t\tsetActiveTab(tab) {\n\t\t\t\t\tthis.activeTab = tab;\n\t\t\t\t\tif (tab === 'colors') {\n\t\t\t\t\t\t// Refresh available labels when opening colors tab\n\t\t\t\t\t\tthis.loadAvailableLabels();\n\t\t\t\t\t} else if (tab === 'hidden-alerts') {\n\t\t\t\t\t\t// Refresh hidden alerts data when opening hidden alerts tab\n\t\t\t\t\t\tthis.loadHiddenAlerts();\n\t\t\t\t\t\tthis.loadHiddenRules();\n\t\t\t\t\t} else if (tab === 'annotation-buttons') {\n\t\t\t\t\t\t// Refresh annotation button configs when opening annotation buttons tab\n\t\t\t\t\t\tthis.loadAnnotationButtonConfigs();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Form validation\n\t\t\t\tisValidColorPreference(pref) {\n\t\t\t\t\treturn pref.labelKey.trim() && pref.labelValue.trim() && pref.color;\n\t\t\t\t},\n\n\t\t\t\t// Check if a color preference has unsaved changes\n\t\t\t\thasUnsavedChanges(pref) {\n\t\t\t\t\treturn pref.isEditing;\n\t\t\t\t},\n\n\t\t\t\t// Color utility functions\n\t\t\t\tgenerateRandomColor() {\n\t\t\t\t\tconst colors = [\n\t\t\t\t\t\t'#ff9999', '#99ff99', '#9999ff', '#ffff99', '#ff99ff', '#99ffff',\n\t\t\t\t\t\t'#ffcc99', '#cc99ff', '#99ffcc', '#ccff99', '#ff99cc', '#99ccff'\n\t\t\t\t\t];\n\t\t\t\t\treturn colors[Math.floor(Math.random() * colors.length)];\n\t\t\t\t},\n\n\t\t\t\t// Get contrasting text color for background\n\t\t\t\tgetContrastingTextColor(bgColor) {\n\t\t\t\t\t// Simple contrast calculation - convert hex to RGB and check luminance\n\t\t\t\t\tconst hex = bgColor.replace('#', '');\n\t\t\t\t\tconst r = parseInt(hex.substr(0, 2), 16);\n\t\t\t\t\tconst g = parseInt(hex.substr(2, 2), 16);\n\t\t\t\t\tconst b = parseInt(hex.substr(4, 2), 16);\n\t\t\t\t\t\n\t\t\t\t\t// Calculate luminance\n\t\t\t\t\tconst luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n\t\t\t\t\t\n\t\t\t\t\treturn luminance > 0.5 ? '#000000' : '#ffffff';\n\t\t\t\t},\n\n\t\t\t\t// Auto-set contrasting text color when background changes\n\t\t\t\tonBgColorChange(pref) {\n\t\t\t\t\tpref.textColor = this.getContrastingTextColor(pref.bgColor);\n\t\t\t\t},\n\n\t\t\t\tasync saveHiddenRules() {\n\t\t\t\t\tconsole.log('saveHiddenRules called - hidden rules are saved individually when created');\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Hidden rules are automatically saved to backend when created via createHiddenRule()\n\t\t\t\t\t\t// This function provides consistency in the unified save process\n\t\t\t\t\t\t// and ensures all rules in the current session are validated\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Validate that all rules have been properly saved\n\t\t\t\t\t\tif (this.hiddenRules && this.hiddenRules.length > 0) {\n\t\t\t\t\t\t\tconsole.log(`Validated ${this.hiddenRules.length} hidden rules in current session`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// All hidden rules are already persisted to backend\n\t\t\t\t\t\t// Return true to indicate successful save operation\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error validating hidden rules:', error);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveSettings() {\n\t\t\t\t\tconsole.log('Starting unified settings save...');\n\t\t\t\t\tthis.settingsSaving = true;\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Save general settings to localStorage\n\t\t\t\t\t\tlocalStorage.setItem('dashboardSettings', JSON.stringify(this.settings));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Apply theme change immediately if changed\n\t\t\t\t\t\tif (window.dashboardInstance && typeof window.dashboardInstance.setTheme === 'function') {\n\t\t\t\t\t\t\twindow.dashboardInstance.setTheme(this.settings.theme);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tconsole.log('General settings saved:', this.settings);\n\n\t\t\t\t\t\t// Save color preferences (save all existing preferences)\n\t\t\t\t\t\tconst colorResult = await this.saveColorPreferences();\n\t\t\t\t\t\tif (!colorResult) {\n\t\t\t\t\t\t\tthrow new Error('Failed to save color preferences');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Save hidden rules (ensure all rules are persisted)\n\t\t\t\t\t\tconst hiddenRulesResult = await this.saveHiddenRules();\n\t\t\t\t\t\tif (!hiddenRulesResult) {\n\t\t\t\t\t\t\tthrow new Error('Failed to save hidden rules');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Save notification preferences\n\t\t\t\t\t\tconst notificationResult = await this.saveNotificationPreferences();\n\t\t\t\t\t\tif (!notificationResult) {\n\t\t\t\t\t\t\tthrow new Error('Failed to save notification preferences');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Save annotation button configs\n\t\t\t\t\t\tconst annotationButtonsResult = await this.saveAnnotationButtonConfigs();\n\t\t\t\t\t\tif (!annotationButtonsResult) {\n\t\t\t\t\t\t\tthrow new Error('Failed to save annotation button configs');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconsole.log('All settings saved successfully');\n\t\t\t\t\t\t\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving settings:', error);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.settingsSaving = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Hidden Alerts Management Functions\n\t\t\t\tasync loadHiddenAlerts() {\n\t\t\t\t\tthis.hiddenAlertsLoading = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/hidden-alerts', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.hiddenAlerts = result.data.hiddenAlerts || [];\n\t\t\t\t\t\t\t\tconsole.log('Loaded hidden alerts:', this.hiddenAlerts.length);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading hidden alerts:', error);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.hiddenAlertsLoading = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync loadHiddenRules() {\n\t\t\t\t\tthis.hiddenRulesLoading = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/hidden-rules', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.hiddenRules = result.data.rules || [];\n\t\t\t\t\t\t\t\tconsole.log('Loaded hidden rules:', this.hiddenRules.length);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading hidden rules:', error);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.hiddenRulesLoading = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync unhideAlert(fingerprint) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/hidden-alerts/${encodeURIComponent(fingerprint)}`, {\n\t\t\t\t\t\t\tmethod: 'DELETE',\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Remove from local array\n\t\t\t\t\t\t\tthis.hiddenAlerts = this.hiddenAlerts.filter(alert => alert.fingerprint !== fingerprint);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Show success message\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Refresh dashboard data if visible\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.loadDashboardData();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to unhide alert:', result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error unhiding alert:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync toggleHiddenRule(ruleId) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst rule = this.hiddenRules.find(r => r.id === ruleId);\n\t\t\t\t\t\tif (!rule) return;\n\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/hidden-rules/${ruleId}`, {\n\t\t\t\t\t\t\tmethod: 'PUT',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\t...rule,\n\t\t\t\t\t\t\t\tenabled: !rule.enabled\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Update local rule\n\t\t\t\t\t\t\trule.enabled = !rule.enabled;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Show success message\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Refresh dashboard data if visible\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.loadDashboardData();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to toggle hidden rule:', result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error toggling hidden rule:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync removeHiddenRule(ruleId) {\n\t\t\t\t\tif (!confirm('Are you sure you want to delete this hidden rule?')) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/hidden-rules/${ruleId}`, {\n\t\t\t\t\t\t\tmethod: 'DELETE',\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Remove from local array\n\t\t\t\t\t\t\tthis.hiddenRules = this.hiddenRules.filter(rule => rule.id !== ruleId);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Show success message\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Refresh dashboard data if visible\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.loadDashboardData();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to delete hidden rule:', result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error deleting hidden rule:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Utility function to format timestamps\n\t\t\t\tformatTimestamp(timestamp) {\n\t\t\t\t\tif (!timestamp) return 'Unknown';\n\t\t\t\t\tconst date = new Date(timestamp);\n\t\t\t\t\treturn date.toLocaleString();\n\t\t\t\t},\n\n\t\t\t\t// Utility function to truncate long text\n\t\t\t\ttruncateText(text, maxLength = 50) {\n\t\t\t\t\tif (!text) return '';\n\t\t\t\t\treturn text.length > maxLength ? text.substring(0, maxLength) + '...' : text;\n\t\t\t\t},\n\n\t\t\t\t// Add new hidden rule function\n\t\t\t\taddHiddenRule() {\n\t\t\t\t\t// Reset the form\n\t\t\t\t\tthis.hiddenRuleForm = {\n\t\t\t\t\t\tname: '',\n\t\t\t\t\t\tlabelKey: '',\n\t\t\t\t\t\tlabelValue: '',\n\t\t\t\t\t\tdescription: '',\n\t\t\t\t\t\tenabled: true\n\t\t\t\t\t};\n\t\t\t\t\t// Ensure available labels are loaded\n\t\t\t\t\tthis.ensureAvailableLabels();\n\t\t\t\t\t// Show the modal\n\t\t\t\t\tthis.showHiddenRuleModal = true;\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Cancel hidden rule modal\n\t\t\t\tcancelHiddenRule() {\n\t\t\t\t\tthis.showHiddenRuleModal = false;\n\t\t\t\t\tthis.hiddenRuleForm = {\n\t\t\t\t\t\tname: '',\n\t\t\t\t\t\tlabelKey: '',\n\t\t\t\t\t\tlabelValue: '',\n\t\t\t\t\t\tdescription: '',\n\t\t\t\t\t\tenabled: true\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Save hidden rule from modal\n\t\t\t\tasync saveHiddenRule() {\n\t\t\t\t\t// Validate required fields\n\t\t\t\t\tif (!this.hiddenRuleForm.name.trim() || !this.hiddenRuleForm.labelKey.trim() || !this.hiddenRuleForm.labelValue.trim()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tawait this.createHiddenRule({\n\t\t\t\t\t\tname: this.hiddenRuleForm.name.trim(),\n\t\t\t\t\t\tlabelKey: this.hiddenRuleForm.labelKey.trim(),\n\t\t\t\t\t\tlabelValue: this.hiddenRuleForm.labelValue.trim(),\n\t\t\t\t\t\tdescription: this.hiddenRuleForm.description.trim(),\n\t\t\t\t\t\tenabled: this.hiddenRuleForm.enabled\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t// Close modal on success\n\t\t\t\t\tthis.showHiddenRuleModal = false;\n\t\t\t\t},\n\n\t\t\t\tasync createHiddenRule(ruleData) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/hidden-rules', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\tname: ruleData.name,\n\t\t\t\t\t\t\t\tlabelKey: ruleData.labelKey,\n\t\t\t\t\t\t\t\tlabelValue: ruleData.labelValue,\n\t\t\t\t\t\t\t\tdescription: ruleData.description,\n\t\t\t\t\t\t\t\tenabled: ruleData.enabled\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Add to local array\n\t\t\t\t\t\t\tthis.hiddenRules.push({\n\t\t\t\t\t\t\t\tid: result.data.id,\n\t\t\t\t\t\t\t\t...ruleData,\n\t\t\t\t\t\t\t\tcreatedAt: new Date().toISOString()\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Show success message\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Refresh dashboard data\n\t\t\t\t\t\t\tif (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {\n\t\t\t\t\t\t\t\twindow.dashboardInstance.loadDashboardData();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to create hidden rule:', result.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error creating hidden rule:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Sentry Integration Functions\n\t\t\t\tasync loadSentryConfig() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/sentry-config', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tthis.sentryConfig = {\n\t\t\t\t\t\t\t\thasToken: result.has_token || false,\n\t\t\t\t\t\t\t\tbaseUrl: result.base_url || 'https://sentry.io',\n\t\t\t\t\t\t\t\tauthStatus: result.auth_status || 'none',\n\t\t\t\t\t\t\t\tconnectionTesting: false\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis.sentryForm.baseUrl = this.sentryConfig.baseUrl;\n\t\t\t\t\t\t\tconsole.log('Loaded Sentry config:', this.sentryConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading Sentry config:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveSentryToken() {\n\t\t\t\t\tif (!this.sentryForm.token.trim()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.sentrySaving = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/sentry-token', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\ttoken: this.sentryForm.token,\n\t\t\t\t\t\t\t\tbase_url: this.sentryForm.baseUrl\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Update config to reflect saved state\n\t\t\t\t\t\t\tthis.sentryConfig.hasToken = true;\n\t\t\t\t\t\t\tthis.sentryConfig.authStatus = 'personal_token';\n\t\t\t\t\t\t\tthis.sentryForm.token = '';  // Clear form after saving\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving Sentry token:', error);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.sentrySaving = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync testSentryConnection() {\n\t\t\t\t\t// Get token and base URL from the form\n\t\t\t\t\tconst token = this.sentryForm.token;\n\t\t\t\t\tconst baseUrl = this.sentryForm.baseUrl || 'https://sentry.io';\n\n\t\t\t\t\tif (!token.trim()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.sentryConfig.connectionTesting = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/sentry/test-connection', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\ttoken: token,\n\t\t\t\t\t\t\t\tbase_url: baseUrl\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.valid) {\n\t\t\t\t\t\t\tconsole.log('Connection Successful')\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Connection Failed')\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error testing Sentry connection:', error);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.sentryConfig.connectionTesting = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync removeSentryToken() {\n\t\t\t\t\tif (!confirm('Are you sure you want to remove your Sentry token?')) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/sentry-token', {\n\t\t\t\t\t\t\tmethod: 'DELETE',\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t// Update config to reflect removed state\n\t\t\t\t\t\t\tthis.sentryConfig.hasToken = false;\n\t\t\t\t\t\t\tthis.sentryConfig.authStatus = 'none';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Failed to remove Sentry token')\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error removing Sentry token:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Notification preference methods\n\t\t\t\tasync loadNotificationPreferences() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/notifications/preferences', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success && result.data) {\n\t\t\t\t\t\t\t\tthis.notificationPreferences = {\n\t\t\t\t\t\t\t\t\tbrowserNotificationsEnabled: result.data.browser_notifications_enabled || false,\n\t\t\t\t\t\t\t\t\tenabledSeverities: result.data.enabled_severities || ['critical', 'warning'],\n\t\t\t\t\t\t\t\t\tsoundNotificationsEnabled: result.data.sound_notifications_enabled !== undefined ? result.data.sound_notifications_enabled : true\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t// Sync with notification service\n\t\t\t\t\t\t\t\tif (window.notificationService) {\n\t\t\t\t\t\t\t\t\twindow.notificationService.preferences = this.notificationPreferences;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading notification preferences:', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveNotificationPreferences() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconsole.log('Saving notification preferences:', this.notificationPreferences);\n\n\t\t\t\t\t\tconst response = await fetch('/api/v1/notifications/preferences', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\tbrowser_notifications_enabled: this.notificationPreferences.browserNotificationsEnabled,\n\t\t\t\t\t\t\t\tenabled_severities: this.notificationPreferences.enabledSeverities,\n\t\t\t\t\t\t\t\tsound_notifications_enabled: this.notificationPreferences.soundNotificationsEnabled\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tconsole.log('Notification preferences save response:', result);\n\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\t// Update the notification service preferences\n\t\t\t\t\t\t\t\tif (window.notificationService) {\n\t\t\t\t\t\t\t\t\twindow.notificationService.preferences = this.notificationPreferences;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconsole.log('Notification preferences saved successfully');\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconsole.error('Failed to save notification preferences');\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving notification preferences:', error);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tcheckBrowserPermission() {\n\t\t\t\t\t// Check current browser permission status and sync with local state\n\t\t\t\t\tif ('Notification' in window) {\n\t\t\t\t\t\tthis.browserNotificationPermission = Notification.permission;\n\t\t\t\t\t\tconsole.log('Browser notification permission:', Notification.permission);\n\n\t\t\t\t\t\t// Sync with notification service if available\n\t\t\t\t\t\tif (window.notificationService) {\n\t\t\t\t\t\t\twindow.notificationService.permissionGranted = Notification.permission === 'granted';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('Browser does not support notifications');\n\t\t\t\t\t\tthis.browserNotificationPermission = 'denied';\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync requestNotificationPermission() {\n\t\t\t\t\tif (!('Notification' in window)) {\n\t\t\t\t\t\tconsole.warn('Browser does not support notifications');\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconsole.log('Requesting notification permission...');\n\t\t\t\t\t\tconst permission = await Notification.requestPermission();\n\n\t\t\t\t\t\t// Update local reactive state\n\t\t\t\t\t\tthis.browserNotificationPermission = permission;\n\t\t\t\t\t\tconsole.log('Notification permission result:', permission);\n\n\t\t\t\t\t\t// Sync with notification service\n\t\t\t\t\t\tif (window.notificationService) {\n\t\t\t\t\t\t\twindow.notificationService.permissionGranted = permission === 'granted';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn permission === 'granted';\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Failed to request notification permission:', error);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync testNotification() {\n\t\t\t\t\tif (!window.notificationService) {\n\t\t\t\t\t\tconsole.error('Notification service not available');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if permission is granted\n\t\t\t\t\tif (!window.notificationService.permissionGranted) {\n\t\t\t\t\t\talert('Please grant notification permission first');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a test alert object\n\t\t\t\t\tconst testAlert = {\n\t\t\t\t\t\tfingerprint: 'test-' + Date.now(),\n\t\t\t\t\t\talertName: 'Test Notification',\n\t\t\t\t\t\tsummary: 'This is a test notification from Notificator',\n\t\t\t\t\t\tseverity: 'info',\n\t\t\t\t\t\tsource: 'Dashboard Settings',\n\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\tseverity: 'info',\n\t\t\t\t\t\t\talertname: 'Test Notification'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tannotations: {\n\t\t\t\t\t\t\tsummary: 'This is a test notification from Notificator'\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Temporarily enable notifications and force the test alert to show\n\t\t\t\t\tconst originalEnabled = window.notificationService.preferences.browserNotificationsEnabled;\n\t\t\t\t\tconst originalSeverities = window.notificationService.preferences.enabledSeverities;\n\n\t\t\t\t\twindow.notificationService.preferences.browserNotificationsEnabled = true;\n\t\t\t\t\twindow.notificationService.preferences.enabledSeverities = ['critical', 'warning', 'info'];\n\n\t\t\t\t\twindow.notificationService.showNotification(testAlert);\n\n\t\t\t\t\t// Restore original settings\n\t\t\t\t\twindow.notificationService.preferences.browserNotificationsEnabled = originalEnabled;\n\t\t\t\t\twindow.notificationService.preferences.enabledSeverities = originalSeverities;\n\t\t\t\t},\n\n\t\t\t\t// Annotation Button Config Management Functions\n\t\t\t\tannotationButtonConfigs: [],\n\t\t\t\tannotationButtonsLoading: false,\n\t\t\t\tannotationButtonsError: '',\n\n\t\t\t\t// Color validation/sanitization\n\t\t\t\tsanitizeColor(color) {\n\t\t\t\t\t// Validate hex color format (#RGB or #RRGGBB)\n\t\t\t\t\tconst hexColorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;\n\t\t\t\t\tif (hexColorRegex.test(color)) {\n\t\t\t\t\t\treturn color;\n\t\t\t\t\t}\n\t\t\t\t\treturn '#6366f1'; // Default indigo-600\n\t\t\t\t},\n\n\t\t\t\tasync loadAnnotationButtonConfigs() {\n\t\t\t\t\tthis.annotationButtonsLoading = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/annotation-buttons', {\n\t\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\t\tthis.annotationButtonConfigs = result.data.configs || [];\n\t\t\t\t\t\t\t\tconsole.log('Loaded annotation button configs:', this.annotationButtonConfigs.length);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error loading annotation button configs:', error);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.annotationButtonsLoading = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tasync saveAnnotationButtonConfigs() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.annotationButtonsError = '';\n\n\t\t\t\t\t\t// Sanitize colors before saving\n\t\t\t\t\t\tconst sanitizedConfigs = this.annotationButtonConfigs.map(config => ({\n\t\t\t\t\t\t\t...config,\n\t\t\t\t\t\t\tcolor: this.sanitizeColor(config.color),\n\t\t\t\t\t\t\t// Filter out empty annotation keys\n\t\t\t\t\t\t\tannotation_keys: (config.annotation_keys || []).filter(key => key && key.trim())\n\t\t\t\t\t\t}));\n\n\t\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/annotation-buttons', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\tconfigs: sanitizedConfigs\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t\tconsole.log('Annotation button configs saved successfully');\n\t\t\t\t\t\t\tawait this.loadAnnotationButtonConfigs();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst errorMsg = result.error || 'Failed to save annotation button configs';\n\t\t\t\t\t\t\tconsole.error('Failed to save:', errorMsg);\n\t\t\t\t\t\t\tthis.annotationButtonsError = errorMsg;\n\t\t\t\t\t\t\talert('Error: ' + errorMsg); // User-facing error\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error saving annotation button configs:', error);\n\t\t\t\t\t\tthis.annotationButtonsError = 'Network error: ' + error.message;\n\t\t\t\t\t\talert('Failed to save annotation button configs. Please try again.');\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\taddAnnotationButton() {\n\t\t\t\t\tconst newButton = {\n\t\t\t\t\t\tid: String(Date.now() + Math.random()),\n\t\t\t\t\t\tlabel: 'New Button',\n\t\t\t\t\t\tannotation_keys: [''],\n\t\t\t\t\t\tcolor: '#6366f1',\n\t\t\t\t\t\ticon: 'link',\n\t\t\t\t\t\tdisplay_order: this.annotationButtonConfigs.length,\n\t\t\t\t\t\tenabled: true,\n\t\t\t\t\t\tbutton_type: 'custom',\n\t\t\t\t\t\tisEditing: true\n\t\t\t\t\t};\n\t\t\t\t\tthis.annotationButtonConfigs.push(newButton);\n\t\t\t\t},\n\n\t\t\t\tremoveAnnotationButton(index) {\n\t\t\t\t\tif (confirm('Are you sure you want to remove this button?')) {\n\t\t\t\t\t\tthis.annotationButtonConfigs.splice(index, 1);\n\t\t\t\t\t\t// Update display orders\n\t\t\t\t\t\tthis.annotationButtonConfigs.forEach((btn, idx) => {\n\t\t\t\t\t\t\tbtn.display_order = idx;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tmoveButtonUp(index) {\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\tconst temp = this.annotationButtonConfigs[index];\n\t\t\t\t\t\tthis.annotationButtonConfigs[index] = this.annotationButtonConfigs[index - 1];\n\t\t\t\t\t\tthis.annotationButtonConfigs[index - 1] = temp;\n\t\t\t\t\t\t// Update display orders\n\t\t\t\t\t\tthis.annotationButtonConfigs.forEach((btn, idx) => {\n\t\t\t\t\t\t\tbtn.display_order = idx;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tmoveButtonDown(index) {\n\t\t\t\t\tif (index < this.annotationButtonConfigs.length - 1) {\n\t\t\t\t\t\tconst temp = this.annotationButtonConfigs[index];\n\t\t\t\t\t\tthis.annotationButtonConfigs[index] = this.annotationButtonConfigs[index + 1];\n\t\t\t\t\t\tthis.annotationButtonConfigs[index + 1] = temp;\n\t\t\t\t\t\t// Update display orders\n\t\t\t\t\t\tthis.annotationButtonConfigs.forEach((btn, idx) => {\n\t\t\t\t\t\t\tbtn.display_order = idx;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\taddAnnotationKey(button) {\n\t\t\t\t\tif (!button.annotation_keys) {\n\t\t\t\t\t\tbutton.annotation_keys = [];\n\t\t\t\t\t}\n\t\t\t\t\tbutton.annotation_keys.push('');\n\t\t\t\t},\n\n\t\t\t\tremoveAnnotationKey(button, index) {\n\t\t\t\t\tbutton.annotation_keys.splice(index, 1);\n\t\t\t\t},\n\n\t\t\t\ttoggleButtonEdit(button) {\n\t\t\t\t\tbutton.isEditing = !button.isEditing;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Global settings modal reference for dashboard integration\n\t\twindow.settingsModalData = settingsModalData;\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
