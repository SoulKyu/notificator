package scripts

templ DashboardCore() {
	<script>
		function newDashboard() {
			return {
				loading: true,
				alerts: [],
				groups: [],
				metadata: {
					totalAlerts: 0,
					filteredCount: 0,
					lastUpdate: null,
					counters: {
						critical: 0,
						warning: 0,
						info: 0,
						firing: 0,
						resolved: 0,
						acknowledged: 0,
						withComments: 0
					},
					availableFilters: {
						alertmanagers: [],
						severities: [],
						statuses: [],
						teams: [],
						alertNames: []
					}
				},
				settings: {
					theme: 'light',
					resolvedAlertsRetention: 1,
					refreshInterval: 5,
					resolvedAlertsLimit: 100
				},
				
				isRemovingResolvedAlerts: false,
				
				hasInitiallyLoaded: false,
				sessionStorageKey: 'dashboard_session_state',

				displayMode: 'classic',
				viewMode: 'list',
				sortField: 'duration',
				sortDirection: 'asc',
				groupByLabel: 'alertname', // Default group by alert name
				showSettings: false,
				
				showAckModal: false,
				ackAction: 'single',
				ackReason: '',
				ackError: '',
				ackSubmitting: false,
				currentAckAlert: null,
				currentGroupName: '',
				
				showSilenceModal: false,
				silenceAction: 'single',
				silenceReason: '',
				silenceError: '',
				silenceSubmitting: false,
				currentSilenceAlert: null,
				silenceDuration: '1h',
				silenceDurationType: 'preset',
				customSilenceDuration: '',
				customDurationError: '',
				
				showAlertModal: false,
				alertDetails: null,
				currentAlertTab: 'overview',
				alertDetailsLoading: false,
				
				// Filter presets modal state
				showFilterPresetsModal: false,

				newCommentContent: '',
				commentSubmitting: false,
				commentDeleting: {},
				currentUser: null,
				
				searchQuery: '',
				filters: {
					alertmanagers: [],
					severities: [],
					statuses: [],
					teams: [],
					alertNames: []
				},
				acknowledgmentFilter: null,
				commentsFilter: null,
				
				selectedAlerts: [],
				selectedGroups: [],
				expandedGroups: [],
				
				// Pagination
				currentPage: 1,
				itemsPerPage: 50,
				totalItems: 0,
				
				refreshInterval: null,
				lastUpdateTime: null,
				
				alertColors: {},
				alertColorsTimestamp: 0,
				
				columnWidths: {
					alertName: 300,
					action: 100,
					instance: 350,
					severity: 150,
					status: 150,
					comments: 130,
					team: 200,
					summary: 400,
					duration: 150,
					source: 180
				},
				isResizing: false,
				startX: 0,
				startWidth: 0,
				currentColumn: null,

				getDisplayStatus(status) {
					if (!status?.state) return 'unknown';
					return status.state === 'suppressed' ? 'silenced' : status.state;
				},

				statusMatches(status, value) {
					const displayStatus = this.getDisplayStatus(status);
					return displayStatus === value;
				},

				init() {
					Object.assign(this, window.dashboardDataMixin || {});
					Object.assign(this, window.dashboardActionsMixin || {});
					Object.assign(this, window.dashboardUtilitiesMixin || {});
					Object.assign(this, window.dashboardModalMixin || {});
					Object.assign(this, window.dashboardFilterPresetsMixin || {});

					window.dashboardInstance = this;

					this.initializeSessionTracking();

					this.loadSettings();
					this.loadFiltersFromURL();
					this.loadColumnWidths();
					this.loadCurrentUser();

					this.startAutoRefresh();
					this.loadDashboardData();
					
					this.checkAlertFromURL();
					
					document.addEventListener('visibilitychange', () => {
						if (document.hidden) {
							this.stopAutoRefresh();
						} else {
							this.startAutoRefresh();
							this.loadDashboardIncremental();
						}
					});
					
					document.addEventListener('mousemove', this.handleMouseMove.bind(this));
					document.addEventListener('mouseup', this.handleMouseUp.bind(this));
				},

				openSettings() {
					this.showSettings = true;
				},
				
				getStatusText() {
					if (this.loading) return 'Loading...';
					if (this.metadata && this.metadata.lastUpdate) {
						return `Last updated: ${new Date(this.metadata.lastUpdate).toLocaleTimeString()}`;
					}
					return 'Ready';
				},

				initializeSessionTracking() {
					const sessionData = sessionStorage.getItem(this.sessionStorageKey);
					
					if (sessionData) {
						try {
							const data = JSON.parse(sessionData);
							this.hasInitiallyLoaded = data.hasInitiallyLoaded || false;
							console.log('Session tracking restored - hasInitiallyLoaded:', this.hasInitiallyLoaded);
						} catch (e) {
							console.warn('Failed to parse session data, treating as fresh session');
							this.hasInitiallyLoaded = false;
						}
					} else {
						console.log('Fresh session detected');
						this.hasInitiallyLoaded = false;
					}
					
					this.saveSessionState();
				},

				saveSessionState() {
					try {
						const sessionData = {
							hasInitiallyLoaded: this.hasInitiallyLoaded,
							timestamp: Date.now()
						};
						sessionStorage.setItem(this.sessionStorageKey, JSON.stringify(sessionData));
					} catch (e) {
						console.warn('Failed to save session state:', e);
					}
				},

				setDisplayMode(mode) {
					if (this.displayMode !== mode) {
						this.displayMode = mode;
						this.clearSelection();
						this.loadDashboardData();
					}
				},

				setViewMode(mode) {
					if (this.viewMode !== mode) {
						this.viewMode = mode;
						this.clearSelection();
						if (mode === 'group') {
							this.expandedGroups = this.groups.map(g => g.groupName);
						}
						this.loadDashboardData();
					}
				},

				startAutoRefresh() {
					this.stopAutoRefresh();
					this.refreshInterval = setInterval(() => {
						this.loadDashboardIncremental();
					}, this.settings.refreshInterval * 1000);
				},

				stopAutoRefresh() {
					if (this.refreshInterval) {
						clearInterval(this.refreshInterval);
						this.refreshInterval = null;
					}
				},
				// Notification banner functions
				shouldShowNotificationBanner() {
					// Don't show if dismissed
					if (this.notificationBannerDismissed) return false;

					// Don't show if notification service not loaded
					if (!window.notificationService) return false;

					// Show if either permission not granted OR preference not enabled
					const permissionGranted = 'Notification' in window && Notification.permission === 'granted';
					const preferenceEnabled = window.notificationService.preferences.browserNotificationsEnabled;

					return !permissionGranted || !preferenceEnabled;
				},

				async enableNotifications() {
					if (!window.notificationService) return;

					// Request permission if needed
					if (!('Notification' in window)) {
						console.warn('Browser does not support notifications');
						return;
					}

					if (Notification.permission !== 'granted') {
						const granted = await window.notificationService.requestPermission();
						if (!granted) {
							console.log('Notification permission denied');
							return;
						}
					}

					// Enable and save preference
					window.notificationService.preferences.browserNotificationsEnabled = true;
					await window.notificationService.savePreferences(window.notificationService.preferences);

					console.log('Notifications enabled successfully');
				},

				dismissNotificationBanner() {
					this.notificationBannerDismissed = true;
					// Save to localStorage
					localStorage.setItem('notificator_banner_dismissed', 'true');
				}
			}
		}
	</script>
}