package scripts

templ DashboardCore() {
	<script>
		function newDashboard() {
			return {
				loading: true,
				alerts: [],
				groups: [],
				metadata: {
					totalAlerts: 0,
					filteredCount: 0,
					lastUpdate: null,
					counters: {
						critical: 0,
						warning: 0,
						info: 0,
						firing: 0,
						resolved: 0,
						acknowledged: 0,
						withComments: 0
					},
					availableFilters: {
						alertmanagers: [],
						severities: [],
						statuses: [],
						teams: [],
						alertNames: []
					}
				},
				settings: {
					theme: 'light',
					refreshInterval: 5,
					resolvedAlertsLimit: 100
				},
				
				isRemovingResolvedAlerts: false,
				
				hasInitiallyLoaded: false,
				sessionStorageKey: 'dashboard_session_state',

				displayMode: 'classic',
				viewMode: 'list',
				sortField: 'duration',
				sortDirection: 'asc',
				groupByLabel: 'alertname', // Default group by alert name
				showSettings: false,
				
				showAckModal: false,
				ackAction: 'single',
				ackReason: '',
				ackError: '',
				ackSubmitting: false,
				currentAckAlert: null,
				currentGroupName: '',
				
				showSilenceModal: false,
				silenceAction: 'single',
				silenceReason: '',
				silenceError: '',
				silenceSubmitting: false,
				currentSilenceAlert: null,
				silenceDuration: '1h',
				silenceDurationType: 'preset',
				customSilenceDuration: '',
				customDurationError: '',
				
				showAlertModal: false,
				alertDetails: null,
				currentAlertTab: 'overview',
				alertDetailsLoading: false,
				alertHistory: null,
				historyLoading: false,
				
				// Filter presets modal state
				showFilterPresetsModal: false,
				activePresetName: null, // Track active default preset name
				includeColumnConfig: true, // Whether to include column config when saving filter preset

				// Column config modal state
				showColumnConfigModal: false,

				newCommentContent: '',
				commentSubmitting: false,
				commentDeleting: {},
				currentUser: null,
				
				searchQuery: '',
				filters: {
					alertmanagers: [],
					severities: [],
					statuses: [],
					teams: [],
					alertNames: []
				},
				acknowledgmentFilter: null,
				commentsFilter: null,
				
				selectedAlerts: [],
				selectedGroups: [],
				expandedGroups: [],
				
				// Pagination
				currentPage: 1,
				itemsPerPage: 50,
				totalItems: 0,

				// Resolved alerts state (mixin will add more properties)
				resolvedAlerts: [],
				resolvedTotalCount: 0,
				resolvedLoading: false,

				refreshInterval: null,
				lastUpdateTime: null,
				
				alertColors: {},
				alertColorsTimestamp: 0,

				// Annotation button configs
				annotationButtonConfigs: [],

				columnWidths: {
					alertName: 300,
					action: 100,
					instance: 350,
					severity: 150,
					status: 150,
					comments: 130,
					team: 200,
					summary: 400,
					duration: 150,
					source: 180
				},
				isResizing: false,
				startX: 0,
				startWidth: 0,
				currentColumn: null,

				// Dynamic columns configuration
				columns: [],
				visibleColumns: [],
				resizingColumn: null,
				resizeStartX: 0,
				resizeStartWidth: 0,
				sorting: { field: null, direction: 'asc' },

				getDisplayStatus(status) {
					if (!status?.state) return 'unknown';
					return status.state === 'suppressed' ? 'silenced' : status.state;
				},

				statusMatches(status, value) {
					const displayStatus = this.getDisplayStatus(status);
					return displayStatus === value;
				},

				// Check if response indicates authentication failure
				handleAuthError(response) {
					// Redirect to login if unauthorized or service unavailable
					if (response.status === 401 || response.status === 503) {
						window.location.href = '/login';
						return true;
					}
					return false;
				},

				// Validate session with backend
				async validateSession() {
					try {
						const response = await fetch('/api/v1/auth/me', {
							credentials: 'include'
						});

						// Check for authentication errors and redirect if needed
						if (this.handleAuthError(response)) {
							return false;
						}

						return response.ok;
					} catch (error) {
						console.error('Session validation failed:', error);
						// Redirect to login on network error (backend might be down)
						window.location.href = '/login';
						return false;
					}
				},

				async init() {
					Object.assign(this, window.dashboardDataMixin || {});
					Object.assign(this, window.dashboardActionsMixin || {});
					Object.assign(this, window.dashboardUtilitiesMixin || {});
					Object.assign(this, window.dashboardModalMixin || {});
					Object.assign(this, window.dashboardFilterPresetsMixin || {});
					Object.assign(this, window.dashboardResolvedAlertsMixin || {});

					window.dashboardInstance = this;

					this.initializeSessionTracking();

					// Load notification banner dismissed state from localStorage
					this.notificationBannerDismissed = localStorage.getItem('notificator_banner_dismissed') === 'true';

					this.loadSettings();
					this.loadColumnWidths();
					this.initializeColumns();
					await this.loadUserColumnPreferences(); // Load user column preferences
					this.loadCurrentUser();
					this.loadAnnotationButtonConfigs();

					// Check if URL has filter parameters
					const params = new URLSearchParams(window.location.search);
					const hasURLFilters = params.has('search') || params.has('alertmanagers') ||
										  params.has('severities') || params.has('statuses') ||
										  params.has('teams') || params.has('alertNames') ||
										  params.has('acknowledged') || params.has('hasComments');

					let defaultPresetLoaded = false;

					if (!hasURLFilters) {
						// No URL filters - try to load default preset (if exists, it will also load data)
						defaultPresetLoaded = await this.loadDefaultFilterPreset();
					}

					// Load filters from URL (will override default preset if URL has filters)
					this.loadFiltersFromURL();

					this.startAutoRefresh();

					// Load data if default preset wasn't loaded or URL has filters
					if (!defaultPresetLoaded) {
						this.loadDashboardData();
					}
					
					this.checkAlertFromURL();

					document.addEventListener('visibilitychange', async () => {
						if (!document.hidden) {
							// Validate session when page becomes visible
							const sessionValid = await this.validateSession();
							if (!sessionValid) {
								// If session invalid, stop refresh and redirect
								this.stopAutoRefresh();
								// validateSession() will handle redirect to login
							} else {
								// Do one incremental fetch to catch any missed updates
								this.loadDashboardIncremental();
							}
						}
						// Don't stop auto-refresh when hidden - let it continue fetching in background
					});
					
					document.addEventListener('mousemove', this.handleMouseMove.bind(this));
					document.addEventListener('mouseup', this.handleMouseUp.bind(this));
				},

				openSettings() {
					this.showSettings = true;
				},
				
				getStatusText() {
					if (this.loading) return 'Loading...';
					if (this.metadata && this.metadata.lastUpdate) {
						return `Last updated: ${new Date(this.metadata.lastUpdate).toLocaleTimeString()}`;
					}
					return 'Ready';
				},

				initializeSessionTracking() {
					const sessionData = sessionStorage.getItem(this.sessionStorageKey);
					
					if (sessionData) {
						try {
							const data = JSON.parse(sessionData);
							this.hasInitiallyLoaded = data.hasInitiallyLoaded || false;
							console.log('Session tracking restored - hasInitiallyLoaded:', this.hasInitiallyLoaded);
						} catch (e) {
							console.warn('Failed to parse session data, treating as fresh session');
							this.hasInitiallyLoaded = false;
						}
					} else {
						console.log('Fresh session detected');
						this.hasInitiallyLoaded = false;
					}
					
					this.saveSessionState();
				},

				saveSessionState() {
					try {
						const sessionData = {
							hasInitiallyLoaded: this.hasInitiallyLoaded,
							timestamp: Date.now()
						};
						sessionStorage.setItem(this.sessionStorageKey, JSON.stringify(sessionData));
					} catch (e) {
						console.warn('Failed to save session state:', e);
					}
				},

				setDisplayMode(mode) {
					if (this.displayMode !== mode) {
						this.displayMode = mode;
						this.clearSelection();
						this.loadDashboardData();
					}
				},

				setViewMode(mode) {
					if (this.viewMode !== mode) {
						this.viewMode = mode;
						this.clearSelection();
						if (mode === 'group') {
							this.expandedGroups = this.groups.map(g => g.groupName);
						}
						this.loadDashboardData();
					}
				},

				startAutoRefresh() {
					this.stopAutoRefresh();
					this.refreshInterval = setInterval(() => {
						this.loadDashboardIncremental();
					}, this.settings.refreshInterval * 1000);
				},

				stopAutoRefresh() {
					if (this.refreshInterval) {
						clearInterval(this.refreshInterval);
						this.refreshInterval = null;
					}
				},
				// Notification banner functions
				shouldShowNotificationBanner() {
					// Don't show if dismissed
					if (this.notificationBannerDismissed) return false;

					// Don't show if notification service not loaded
					if (!window.notificationService) return false;

					// Show if either permission not granted OR preference not enabled
					const permissionGranted = 'Notification' in window && Notification.permission === 'granted';
					const preferenceEnabled = window.notificationService.preferences.browserNotificationsEnabled;

					return !permissionGranted || !preferenceEnabled;
				},

				async enableNotifications() {
					if (!window.notificationService) return;

					// Request permission if needed
					if (!('Notification' in window)) {
						console.warn('Browser does not support notifications');
						return;
					}

					if (Notification.permission !== 'granted') {
						const granted = await window.notificationService.requestPermission();
						if (!granted) {
							console.log('Notification permission denied');
							return;
						}
					}

					// Enable and save preference
					window.notificationService.preferences.browserNotificationsEnabled = true;
					await window.notificationService.savePreferences(window.notificationService.preferences);

					// Update permission status in service
					window.notificationService.permissionGranted = Notification.permission === 'granted';

					console.log('Notifications enabled successfully');

					// Auto-dismiss the banner since notifications are now enabled
					this.dismissNotificationBanner();
				},

				dismissNotificationBanner() {
					this.notificationBannerDismissed = true;
					// Save to localStorage
					localStorage.setItem('notificator_banner_dismissed', 'true');
				}
			}
		}
	</script>
}