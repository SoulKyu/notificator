package scripts

templ DashboardSettings() {
	<script>
		function settingsModalData() {
			return {
				activeTab: 'general',
				colorPreferences: [],
				availableLabels: {},
				availableLabelsLastLoaded: null,
				labelKeyTimeouts: {},
				
				// Hidden alerts data
				hiddenAlerts: [],
				hiddenRules: [],
				hiddenAlertsLoading: false,
				hiddenRulesLoading: false,
				
				// Hidden Rules Modal
				showHiddenRuleModal: false,
				hiddenRuleForm: {
					name: '',
					labelKey: '',
					labelValue: '',
					description: '',
					enabled: true
				},
				
				settings: {
					theme: 'light',
					resolvedAlertsRetention: 7,
					resolvedAlertsLimit: 100,
					refreshInterval: 30
				},
				
				notificationPreferences: {
					enabled: true,
					soundEnabled: true,
					browserNotifications: true,
					cooldownSeconds: 300,
					maxNotifications: 5,
					respectFilters: true,
					severityRules: {
						critical: true,
						major: true,
						warning: true,
						minor: false,
						info: false,
						unknown: false
					},
					soundConfig: {}
				},
				notificationPreferencesSaving: false,
				settingsSaving: false,
				
				async init() {
					console.log('Settings modal initializing...');
					await this.loadSettings();
					await this.loadColorPreferences();
					await this.loadAvailableLabels();
					await this.loadNotificationPreferences();
					await this.loadHiddenAlerts();
					await this.loadHiddenRules();
					window.currentSettingsModal = this;
					console.log('Settings modal initialized, window.currentSettingsModal set:', !!window.currentSettingsModal);
				},

				async loadSettings() {
					try {
						// Load settings from localStorage for now (can be extended to backend later)
						const savedSettings = localStorage.getItem('dashboardSettings');
						if (savedSettings) {
							const parsedSettings = JSON.parse(savedSettings);
							this.settings = { ...this.settings, ...parsedSettings };
						}
						
						// Also check for theme preference from dashboard instance
						if (window.dashboardInstance && window.dashboardInstance.currentTheme) {
							this.settings.theme = window.dashboardInstance.currentTheme;
						}
						
						console.log('Loaded general settings:', this.settings);
					} catch (error) {
						console.error('Error loading general settings:', error);
					}
				},

				async loadColorPreferences() {
					try {
						const response = await fetch('/api/v1/dashboard/color-preferences', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								this.colorPreferences = (result.data.preferences || []).map(pref => ({
									...pref,
									labelConditions: pref.labelConditions || {},
									bgLightnessFactor: pref.bgLightnessFactor !== undefined ? pref.bgLightnessFactor : 0.9,
									textDarknessFactor: pref.textDarknessFactor !== undefined ? pref.textDarknessFactor : 0.3
								}));
							}
						}
					} catch (error) {
						console.error('Error loading color preferences:', error);
					}
				},

				async loadAvailableLabels() {
					// Check if we already have cached labels and they're not too old (cache for 5 minutes)
					if (this.availableLabels && Object.keys(this.availableLabels).length > 0 && 
						this.availableLabelsLastLoaded && 
						(Date.now() - this.availableLabelsLastLoaded) < 300000) {
						console.log('Using cached available labels');
						return;
					}

					try {
						console.log('Fetching available labels from API...');
						const response = await fetch('/api/v1/dashboard/available-labels', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								this.availableLabels = result.data.labels || {};
								this.availableLabelsLastLoaded = Date.now();
								console.log('Loaded available labels:', Object.keys(this.availableLabels).length, 'label types');
							}
						}
					} catch (error) {
						console.error('Error loading available labels:', error);
						// Fallback to empty object if fetch fails
						this.availableLabels = {};
					}
				},

				async saveColorPreferences() {
					console.log('saveColorPreferences called with preferences:', this.colorPreferences);
					try {
						const response = await fetch('/api/v1/dashboard/color-preferences', {
							method: 'POST',
							credentials: 'include',
							headers: {
								'Content-Type': 'application/json',
							},
							body: JSON.stringify({
								preferences: this.colorPreferences
							})
						});

						const result = await response.json();
						console.log('Color preferences save response:', result);
						if (result.success) {
							// Reload color preferences to show saved state in modal
							await this.loadColorPreferences();
							return true;
						} else {
							console.error('Failed to save color preferences:', result.error);
							return false;
						}
					} catch (error) {
						console.error('Error saving color preferences:', error);
						return false;
					}
				},

				addColorPreference() {
					const newPref = {
						id: String(Date.now() + Math.random()),
						labelKey: '',
						labelValue: '',
						color: '#ff9999',
						colorType: 'custom',
						priority: 0,
						bgLightnessFactor: 0.9,
						textDarknessFactor: 0.3,
						isEditing: true
					};
					this.colorPreferences.push(newPref);
				},

				addLabelCondition(preference) {
					if (!preference.labelConditions) {
						preference.labelConditions = {};
					}
					const key = 'label' + Object.keys(preference.labelConditions).length;
					preference.labelConditions[key] = '';
				},

				ensureAvailableLabels() {
					if (!this.availableLabels || Object.keys(this.availableLabels).length === 0) {
						this.loadAvailableLabels();
					}
				},

				editColorPreference(id) {
					const pref = this.colorPreferences.find(p => p.id === id);
					if (pref) {
						pref.isEditing = true;
					}
				},

				cancelEditColorPreference(id) {
					const index = this.colorPreferences.findIndex(p => p.id === id);
					if (index !== -1) {
						const pref = this.colorPreferences[index];
						if (!pref.labelKey && !pref.labelValue) {
							// Remove if it's a new preference being cancelled
							this.colorPreferences.splice(index, 1);
						} else {
							pref.isEditing = false;
						}
					}
				},

				removeColorPreference(index) {
					this.colorPreferences.splice(index, 1);
				},

				// Get available values for a selected label key
				getAvailableValuesForLabel(labelKey) {
					return this.availableLabels[labelKey] || [];
				},

				// Get available severities from dashboard metadata
				getAvailableSeverities() {
					if (window.dashboardInstance && window.dashboardInstance.metadata && window.dashboardInstance.metadata.availableFilters) {
						return window.dashboardInstance.metadata.availableFilters.severities || [];
					}
					return [];
				},

				// Initialize dynamic severity rules based on available severities
				initializeDynamicSeverityRules() {
					const availableSeverities = this.getAvailableSeverities();
					const currentRules = this.notificationPreferences.severityRules || {};
					const newRules = {};

					// Keep existing preferences for known severities
					availableSeverities.forEach(severity => {
						const severityKey = severity.toLowerCase();
						// Use existing preference if available, otherwise default based on severity type
						if (currentRules.hasOwnProperty(severityKey)) {
							newRules[severityKey] = currentRules[severityKey];
						} else {
							// Default rules: enable critical, warning, major; disable others
							newRules[severityKey] = ['critical', 'major', 'warning'].includes(severityKey);
						}
					});

					// Update notification preferences with dynamic rules
					this.notificationPreferences.severityRules = newRules;
				},

				// Debounced update for label condition keys to improve performance
				updateLabelConditionKey(preference, oldKey, newKey) {
					if (oldKey !== newKey && newKey.trim() !== '') {
						const value = preference.labelConditions[oldKey];
						delete preference.labelConditions[oldKey];
						preference.labelConditions[newKey] = value;
					}
				},

				// Debounced version for input events - only updates after user stops typing
				debouncedUpdateLabelConditionKey(preference, oldKey, newKey) {
					// Clear existing timeout for this specific input
					const timeoutKey = `${preference.id}-${oldKey}`;
					if (this.labelKeyTimeouts && this.labelKeyTimeouts[timeoutKey]) {
						clearTimeout(this.labelKeyTimeouts[timeoutKey]);
					}

					// Initialize timeouts object if it doesn't exist
					if (!this.labelKeyTimeouts) {
						this.labelKeyTimeouts = {};
					}

					// Set new timeout to update after 300ms of no typing
					this.labelKeyTimeouts[timeoutKey] = setTimeout(() => {
						this.updateLabelConditionKey(preference, oldKey, newKey);
						delete this.labelKeyTimeouts[timeoutKey];
					}, 300);
				},

				// Get severity color for UI display
				getSeverityColor(severity) {
					const severityLower = severity.toLowerCase();
					const colorMap = {
						'critical': 'red',
						'major': 'orange', 
						'warning': 'yellow',
						'minor': 'blue',
						'info': 'green',
						'information': 'green',
						'unknown': 'gray'
					};
					return colorMap[severityLower] || 'gray';
				},

				// Get severity display name
				getSeverityDisplayName(severity) {
					const displayMap = {
						'info': 'Info',
						'information': 'Info',
						'critical': 'Critical',
						'major': 'Major',
						'warning': 'Warning',
						'minor': 'Minor',
						'unknown': 'Unknown'
					};
					return displayMap[severity.toLowerCase()] || severity.charAt(0).toUpperCase() + severity.slice(1);
				},

				// Initialize dynamic sound configuration based on available severities
				initializeDynamicSoundConfig() {
					const availableSeverities = this.getAvailableSeverities();
					const currentSoundConfig = this.notificationPreferences.soundConfig || {};
					const newSoundConfig = {};

					// Process each available severity
					availableSeverities.forEach(severity => {
						const severityKey = severity.toLowerCase();
						const freqKey = `${severityKey}_frequency`;
						const durKey = `${severityKey}_duration`;
						const typeKey = `${severityKey}_type`;

						// Use existing config if available, otherwise use defaults
						if (currentSoundConfig.hasOwnProperty(freqKey)) {
							newSoundConfig[freqKey] = currentSoundConfig[freqKey];
							newSoundConfig[durKey] = currentSoundConfig[durKey];
							newSoundConfig[typeKey] = currentSoundConfig[typeKey];
						} else {
							// Set intelligent defaults based on severity type
							const defaults = this.getDefaultSoundConfigForSeverity(severityKey);
							newSoundConfig[freqKey] = defaults.frequency;
							newSoundConfig[durKey] = defaults.duration;
							newSoundConfig[typeKey] = defaults.type;
						}
					});

					// Update notification preferences with dynamic sound config
					this.notificationPreferences.soundConfig = newSoundConfig;
				},

				// Get default sound configuration for a severity
				getDefaultSoundConfigForSeverity(severity) {
					const severityLower = severity.toLowerCase();
					
					// Default configurations based on severity urgency
					switch (severityLower) {
						case 'critical':
						case 'major':
							return { frequency: 800, duration: 200, type: 'square' };
						case 'warning':
						case 'minor':
							return { frequency: 600, duration: 150, type: 'sine' };
						case 'info':
						case 'information':
							return { frequency: 400, duration: 100, type: 'sine' };
						default:
							// Unknown severities get a neutral sound
							return { frequency: 500, duration: 120, type: 'triangle' };
					}
				},

				// Test sound with current form settings (preview functionality)
				testSoundWithPreview(severity) {
					if (!window.dashboardInstance || !window.dashboardInstance.audioContext) {
						console.warn('Audio context not available for sound preview');
						return;
					}

					const severityKey = severity.toLowerCase();
					
					// Read current values directly from DOM elements to get the most up-to-date user input
					const frequencyInput = document.querySelector(`input[type="number"][x-model*="${severityKey}_frequency"]`);
					const durationInput = document.querySelector(`input[type="number"][x-model*="${severityKey}_duration"]`);
					const typeSelect = document.querySelector(`select[x-model*="${severityKey}_type"]`);
					
					const soundConfig = {
						frequency: frequencyInput ? parseInt(frequencyInput.value) || 500 : 500,
						duration: durationInput ? parseInt(durationInput.value) || 150 : 150,
						type: typeSelect ? typeSelect.value || 'sine' : 'sine'
					};
					
					console.log(`Testing sound for ${severity} with current form values:`, soundConfig);
					this.playPreviewSound(soundConfig);
				},

				// Play sound with specific configuration (for testing)
				playPreviewSound(soundConfig) {
					if (!window.dashboardInstance || !window.dashboardInstance.audioContext) {
						return;
					}

					try {
						const audioContext = window.dashboardInstance.audioContext;
						const oscillator = audioContext.createOscillator();
						const gainNode = audioContext.createGain();
						
						oscillator.connect(gainNode);
						gainNode.connect(audioContext.destination);
						
						oscillator.frequency.setValueAtTime(soundConfig.frequency, audioContext.currentTime);
						oscillator.type = soundConfig.type;
						
						gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
						gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + soundConfig.duration / 1000);
						
						oscillator.start(audioContext.currentTime);
						oscillator.stop(audioContext.currentTime + soundConfig.duration / 1000);
					} catch (error) {
						console.warn('Failed to play preview sound:', error);
					}
				},

				// Get current sound config from DOM form values (for saving real-time user input)
				getCurrentSoundConfigFromDOM() {
					const availableSeverities = this.getAvailableSeverities();
					const currentSoundConfig = {};
					
					// Read current form values for each available severity
					availableSeverities.forEach(severity => {
						const severityKey = severity.toLowerCase();
						
						// Query DOM for frequency, duration, and type inputs
						const frequencyInput = document.querySelector(`input[type="number"][x-model*="${severityKey}_frequency"]`);
						const durationInput = document.querySelector(`input[type="number"][x-model*="${severityKey}_duration"]`);
						const typeSelect = document.querySelector(`select[x-model*="${severityKey}_type"]`);
						
						// Extract values with defaults and ensure clean data types
						const freqKey = `${severityKey}_frequency`;
						const durKey = `${severityKey}_duration`;
						const typeKey = `${severityKey}_type`;
						
						// Ensure integers are clean and valid
						let frequency = 500;
						let duration = 150;
						let soundType = 'sine';
						
						if (frequencyInput && frequencyInput.value) {
							const parsedFreq = parseInt(frequencyInput.value, 10);
							frequency = (isNaN(parsedFreq) || parsedFreq < 100 || parsedFreq > 2000) ? 500 : parsedFreq;
						}
						
						if (durationInput && durationInput.value) {
							const parsedDur = parseInt(durationInput.value, 10);
							duration = (isNaN(parsedDur) || parsedDur < 50 || parsedDur > 5000) ? 150 : parsedDur;
						}
						
						if (typeSelect && typeSelect.value) {
							const validTypes = ['sine', 'square', 'triangle', 'sawtooth'];
							soundType = validTypes.includes(typeSelect.value) ? typeSelect.value : 'sine';
						}
						
						currentSoundConfig[freqKey] = frequency;
						currentSoundConfig[durKey] = duration;
						currentSoundConfig[typeKey] = soundType;
					});
					
					console.log('Reading current sound config from DOM:', currentSoundConfig);
					return currentSoundConfig;
				},

				// Preview the color combination with lightness factors
				getPreviewStyle(pref) {
					if (!pref.color) return '';
					
					// Use the base color and apply lightness factors
					const baseColor = pref.color;
					const bgLightness = pref.bgLightnessFactor || 0.9;
					const textDarkness = pref.textDarknessFactor || 0.3;
					
					// For custom colors, simulate the lightening/darkening effects
					if (pref.colorType === 'custom' && baseColor.startsWith('#')) {
						const bgColor = this.lightenColorSimulation(baseColor, bgLightness);
						const textColor = this.darkenColorSimulation(baseColor, textDarkness);
						return `background-color: ${bgColor}; color: ${textColor}; padding: 2px 8px; border-radius: 4px; display: inline-block; min-width: 60px; text-align: center; border: 1px solid ${baseColor};`;
					}
					
					// For other color types, just use the base color
					return `background-color: ${baseColor}; color: white; padding: 2px 8px; border-radius: 4px; display: inline-block; min-width: 60px; text-align: center;`;
				},
				
				// Simple color lightening simulation for preview
				lightenColorSimulation(hexColor, factor) {
					// Remove # if present
					const hex = hexColor.replace('#', '');
					const r = parseInt(hex.substr(0, 2), 16);
					const g = parseInt(hex.substr(2, 2), 16);
					const b = parseInt(hex.substr(4, 2), 16);
					
					// Lighten by interpolating towards white
					const newR = Math.round(r + (255 - r) * factor);
					const newG = Math.round(g + (255 - g) * factor);
					const newB = Math.round(b + (255 - b) * factor);
					
					return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
				},
				
				// Simple color darkening simulation for preview
				darkenColorSimulation(hexColor, factor) {
					// Remove # if present
					const hex = hexColor.replace('#', '');
					const r = parseInt(hex.substr(0, 2), 16);
					const g = parseInt(hex.substr(2, 2), 16);
					const b = parseInt(hex.substr(4, 2), 16);
					
					// Darken by interpolating towards black
					const newR = Math.round(r * (1 - factor));
					const newG = Math.round(g * (1 - factor));
					const newB = Math.round(b * (1 - factor));
					
					return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
				},

				// Tab management
				setActiveTab(tab) {
					this.activeTab = tab;
					if (tab === 'colors') {
						// Refresh available labels when opening colors tab
						this.loadAvailableLabels();
					} else if (tab === 'notifications') {
						// Reload notification preferences to ensure fresh backend data (like color preferences)
						this.loadNotificationPreferences();
					} else if (tab === 'hidden-alerts') {
						// Refresh hidden alerts data when opening hidden alerts tab
						this.loadHiddenAlerts();
						this.loadHiddenRules();
					}
				},

				// Form validation
				isValidColorPreference(pref) {
					return pref.labelKey.trim() && pref.labelValue.trim() && pref.color;
				},

				// Check if a color preference has unsaved changes
				hasUnsavedChanges(pref) {
					return pref.isEditing;
				},

				// Color utility functions
				generateRandomColor() {
					const colors = [
						'#ff9999', '#99ff99', '#9999ff', '#ffff99', '#ff99ff', '#99ffff',
						'#ffcc99', '#cc99ff', '#99ffcc', '#ccff99', '#ff99cc', '#99ccff'
					];
					return colors[Math.floor(Math.random() * colors.length)];
				},

				// Get contrasting text color for background
				getContrastingTextColor(bgColor) {
					// Simple contrast calculation - convert hex to RGB and check luminance
					const hex = bgColor.replace('#', '');
					const r = parseInt(hex.substr(0, 2), 16);
					const g = parseInt(hex.substr(2, 2), 16);
					const b = parseInt(hex.substr(4, 2), 16);
					
					// Calculate luminance
					const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
					
					return luminance > 0.5 ? '#000000' : '#ffffff';
				},

				// Auto-set contrasting text color when background changes
				onBgColorChange(pref) {
					pref.textColor = this.getContrastingTextColor(pref.bgColor);
				},

				// Notification Preference Methods
				async loadNotificationPreferences() {
					try {
						const response = await fetch('/api/v1/dashboard/notification-preferences', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success && result.data.preference) {
								const backendPrefs = result.data.preference;
								
								// Convert backend format (snake_case) to frontend format (camelCase)
								const frontendPrefs = {
									enabled: backendPrefs.enabled,
									soundEnabled: backendPrefs.sound_enabled,
									browserNotifications: backendPrefs.browser_notifications,
									cooldownSeconds: backendPrefs.cooldown_seconds,
									maxNotifications: backendPrefs.max_notifications,
									respectFilters: backendPrefs.respect_filters,
									severityRules: backendPrefs.severity_rules || {},
									soundConfig: backendPrefs.sound_config || {}
								};
								
								// Merge with defaults, preferring loaded values
								this.notificationPreferences = { 
									...this.notificationPreferences, 
									...frontendPrefs 
								};
								console.log('Loaded notification preferences:', this.notificationPreferences);
								
								// Initialize dynamic severity rules after loading preferences
								this.initializeDynamicSeverityRules();
								// Initialize dynamic sound configuration
								this.initializeDynamicSoundConfig();
							}
						}
					} catch (error) {
						console.error('Error loading notification preferences:', error);
					}
				},

				async saveNotificationPreferences() {
					console.log('Starting saveNotificationPreferences() from settings modal');
					this.notificationPreferencesSaving = true;
					try {
						// Get current sound config from DOM to capture real-time user input
						const currentSoundConfig = this.getCurrentSoundConfigFromDOM();
						
						// Pre-validate JSON serialization to catch issues early
						try {
							JSON.stringify(currentSoundConfig);
						} catch (jsonError) {
							console.error('Invalid sound config data - cannot serialize to JSON:', jsonError);
							console.error('Problematic data:', currentSoundConfig);
							if (window.dashboardInstance && window.dashboardInstance.showNotification) {
								window.dashboardInstance.showNotification('error', 'Invalid sound configuration data. Please check your settings.');
							}
							return false;
						}
						
						// Clean up the payload and convert frontend format to backend format
						const cleanPreferences = {
							enabled: this.notificationPreferences.enabled,
							sound_enabled: this.notificationPreferences.soundEnabled,
							browser_notifications: this.notificationPreferences.browserNotifications,
							cooldown_seconds: this.notificationPreferences.cooldownSeconds,
							max_notifications: this.notificationPreferences.maxNotifications,
							respect_filters: this.notificationPreferences.respectFilters,
							severity_rules: this.notificationPreferences.severityRules,
							sound_config: currentSoundConfig  // Use real DOM values instead of cached data
						};

						console.log('Sending notification preferences to server:', cleanPreferences);

						const response = await fetch('/api/v1/dashboard/notification-preferences', {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							credentials: 'include',
							body: JSON.stringify({ preference: cleanPreferences })
						});
						
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								console.log('Notification preferences saved successfully');
								return true;
							} else {
								console.error('Failed to save notification preferences:', result.error);
								return false;
							}
						} else {
							return false;
						}
					} catch (error) {
						console.error('Error saving notification preferences:', error);
						return false;
					} finally {
						this.notificationPreferencesSaving = false;
					}
				},

				testNotification() {
					if (window.dashboardInstance && window.dashboardInstance.showInAppNotification) {
						window.dashboardInstance.showInAppNotification('info', 'Test notification - your notification settings are working!');
					}
					
					// Also test sound if enabled
					if (this.notificationPreferences.sound_enabled && window.dashboardInstance && window.dashboardInstance.playNotificationSound) {
						window.dashboardInstance.playNotificationSound('info');
					}
				},

				async saveHiddenRules() {
					console.log('saveHiddenRules called - hidden rules are saved individually when created');
					try {
						// Hidden rules are automatically saved to backend when created via createHiddenRule()
						// This function provides consistency in the unified save process
						// and ensures all rules in the current session are validated
						
						// Validate that all rules have been properly saved
						if (this.hiddenRules && this.hiddenRules.length > 0) {
							console.log(`Validated ${this.hiddenRules.length} hidden rules in current session`);
						}
						
						// All hidden rules are already persisted to backend
						// Return true to indicate successful save operation
						return true;
					} catch (error) {
						console.error('Error validating hidden rules:', error);
						return false;
					}
				},

				async saveSettings() {
					console.log('Starting unified settings save...');
					this.settingsSaving = true;
					
					try {
						// Save general settings to localStorage
						localStorage.setItem('dashboardSettings', JSON.stringify(this.settings));
						
						// Apply theme change immediately if changed
						if (window.dashboardInstance && typeof window.dashboardInstance.setTheme === 'function') {
							window.dashboardInstance.setTheme(this.settings.theme);
						}
						
						console.log('General settings saved:', this.settings);
						
						// Save notification preferences
						const notificationResult = await this.saveNotificationPreferences();
						if (!notificationResult) {
							throw new Error('Failed to save notification preferences');
						}
						
						// Save color preferences (save all existing preferences)
						const colorResult = await this.saveColorPreferences();
						if (!colorResult) {
							throw new Error('Failed to save color preferences');
						}
						
						// Save hidden rules (ensure all rules are persisted)
						const hiddenRulesResult = await this.saveHiddenRules();
						if (!hiddenRulesResult) {
							throw new Error('Failed to save hidden rules');
						}
						
						// Show unified success message
						if (window.dashboardInstance && window.dashboardInstance.showNotification) {
							window.dashboardInstance.showNotification('success', 'All settings saved successfully');
						}
						
						console.log('All settings saved successfully');
						
					} catch (error) {
						console.error('Error saving settings:', error);
						if (window.dashboardInstance && window.dashboardInstance.showNotification) {
							window.dashboardInstance.showNotification('error', 'Failed to save some settings: ' + error.message);
						}
					} finally {
						this.settingsSaving = false;
					}
				},

				testSound(severity) {
					// Use the new preview functionality that uses current form settings
					this.testSoundWithPreview(severity);
				},

				// Hidden Alerts Management Functions
				async loadHiddenAlerts() {
					this.hiddenAlertsLoading = true;
					try {
						const response = await fetch('/api/v1/dashboard/hidden-alerts', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								this.hiddenAlerts = result.data.hiddenAlerts || [];
								console.log('Loaded hidden alerts:', this.hiddenAlerts.length);
							}
						}
					} catch (error) {
						console.error('Error loading hidden alerts:', error);
					} finally {
						this.hiddenAlertsLoading = false;
					}
				},

				async loadHiddenRules() {
					this.hiddenRulesLoading = true;
					try {
						const response = await fetch('/api/v1/dashboard/hidden-rules', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								this.hiddenRules = result.data.rules || [];
								console.log('Loaded hidden rules:', this.hiddenRules.length);
							}
						}
					} catch (error) {
						console.error('Error loading hidden rules:', error);
					} finally {
						this.hiddenRulesLoading = false;
					}
				},

				async unhideAlert(fingerprint) {
					try {
						const response = await fetch(`/api/v1/dashboard/hidden-alerts/${encodeURIComponent(fingerprint)}`, {
							method: 'DELETE',
							credentials: 'include'
						});

						const result = await response.json();
						
						if (result.success) {
							// Remove from local array
							this.hiddenAlerts = this.hiddenAlerts.filter(alert => alert.fingerprint !== fingerprint);
							
							// Show success message
							if (window.dashboardInstance && window.dashboardInstance.showNotification) {
								window.dashboardInstance.showNotification('success', 'Alert unhidden successfully');
							}
							
							// Refresh dashboard data if visible
							if (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {
								window.dashboardInstance.loadDashboardData();
							}
						} else {
							console.error('Failed to unhide alert:', result.error);
							if (window.dashboardInstance && window.dashboardInstance.showNotification) {
								window.dashboardInstance.showNotification('error', 'Failed to unhide alert: ' + (result.error || 'Unknown error'));
							}
						}
					} catch (error) {
						console.error('Error unhiding alert:', error);
						if (window.dashboardInstance && window.dashboardInstance.showNotification) {
							window.dashboardInstance.showNotification('error', 'Failed to unhide alert');
						}
					}
				},

				async toggleHiddenRule(ruleId) {
					try {
						const rule = this.hiddenRules.find(r => r.id === ruleId);
						if (!rule) return;

						const response = await fetch(`/api/v1/dashboard/hidden-rules/${ruleId}`, {
							method: 'PUT',
							credentials: 'include',
							headers: {
								'Content-Type': 'application/json',
							},
							body: JSON.stringify({
								...rule,
								enabled: !rule.enabled
							})
						});

						const result = await response.json();
						
						if (result.success) {
							// Update local rule
							rule.enabled = !rule.enabled;
							
							// Show success message
							if (window.dashboardInstance && window.dashboardInstance.showNotification) {
								window.dashboardInstance.showNotification('success', 
									`Rule ${rule.enabled ? 'enabled' : 'disabled'} successfully`);
							}
							
							// Refresh dashboard data if visible
							if (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {
								window.dashboardInstance.loadDashboardData();
							}
						} else {
							console.error('Failed to toggle hidden rule:', result.error);
							if (window.dashboardInstance && window.dashboardInstance.showNotification) {
								window.dashboardInstance.showNotification('error', 'Failed to update rule: ' + (result.error || 'Unknown error'));
							}
						}
					} catch (error) {
						console.error('Error toggling hidden rule:', error);
						if (window.dashboardInstance && window.dashboardInstance.showNotification) {
							window.dashboardInstance.showNotification('error', 'Failed to update rule');
						}
					}
				},

				async removeHiddenRule(ruleId) {
					if (!confirm('Are you sure you want to delete this hidden rule?')) {
						return;
					}

					try {
						const response = await fetch(`/api/v1/dashboard/hidden-rules/${ruleId}`, {
							method: 'DELETE',
							credentials: 'include'
						});

						const result = await response.json();
						
						if (result.success) {
							// Remove from local array
							this.hiddenRules = this.hiddenRules.filter(rule => rule.id !== ruleId);
							
							// Show success message
							if (window.dashboardInstance && window.dashboardInstance.showNotification) {
								window.dashboardInstance.showNotification('success', 'Hidden rule deleted successfully');
							}
							
							// Refresh dashboard data if visible
							if (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {
								window.dashboardInstance.loadDashboardData();
							}
						} else {
							console.error('Failed to delete hidden rule:', result.error);
							if (window.dashboardInstance && window.dashboardInstance.showNotification) {
								window.dashboardInstance.showNotification('error', 'Failed to delete rule: ' + (result.error || 'Unknown error'));
							}
						}
					} catch (error) {
						console.error('Error deleting hidden rule:', error);
						if (window.dashboardInstance && window.dashboardInstance.showNotification) {
							window.dashboardInstance.showNotification('error', 'Failed to delete rule');
						}
					}
				},

				// Utility function to format timestamps
				formatTimestamp(timestamp) {
					if (!timestamp) return 'Unknown';
					const date = new Date(timestamp);
					return date.toLocaleString();
				},

				// Utility function to truncate long text
				truncateText(text, maxLength = 50) {
					if (!text) return '';
					return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
				},

				// Add new hidden rule function
				addHiddenRule() {
					// Reset the form
					this.hiddenRuleForm = {
						name: '',
						labelKey: '',
						labelValue: '',
						description: '',
						enabled: true
					};
					// Ensure available labels are loaded
					this.ensureAvailableLabels();
					// Show the modal
					this.showHiddenRuleModal = true;
				},
				
				// Cancel hidden rule modal
				cancelHiddenRule() {
					this.showHiddenRuleModal = false;
					this.hiddenRuleForm = {
						name: '',
						labelKey: '',
						labelValue: '',
						description: '',
						enabled: true
					};
				},
				
				// Save hidden rule from modal
				async saveHiddenRule() {
					// Validate required fields
					if (!this.hiddenRuleForm.name.trim() || !this.hiddenRuleForm.labelKey.trim() || !this.hiddenRuleForm.labelValue.trim()) {
						if (window.dashboardInstance && window.dashboardInstance.showNotification) {
							window.dashboardInstance.showNotification('error', 'Please fill in all required fields (Name, Label Key, Label Value)');
						}
						return;
					}
					
					await this.createHiddenRule({
						name: this.hiddenRuleForm.name.trim(),
						labelKey: this.hiddenRuleForm.labelKey.trim(),
						labelValue: this.hiddenRuleForm.labelValue.trim(),
						description: this.hiddenRuleForm.description.trim(),
						enabled: this.hiddenRuleForm.enabled
					});
					
					// Close modal on success
					this.showHiddenRuleModal = false;
				},

				async createHiddenRule(ruleData) {
					try {
						const response = await fetch('/api/v1/dashboard/hidden-rules', {
							method: 'POST',
							credentials: 'include',
							headers: {
								'Content-Type': 'application/json',
							},
							body: JSON.stringify({
								name: ruleData.name,
								labelKey: ruleData.labelKey,
								labelValue: ruleData.labelValue,
								description: ruleData.description,
								enabled: ruleData.enabled
							})
						});

						const result = await response.json();
						
						if (result.success) {
							// Add to local array
							this.hiddenRules.push({
								id: result.data.id,
								...ruleData,
								createdAt: new Date().toISOString()
							});
							
							// Show success message
							if (window.dashboardInstance && window.dashboardInstance.showNotification) {
								window.dashboardInstance.showNotification('success', 'Hidden rule created successfully');
							}
							
							// Refresh dashboard data
							if (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {
								window.dashboardInstance.loadDashboardData();
							}
						} else {
							console.error('Failed to create hidden rule:', result.error);
							if (window.dashboardInstance && window.dashboardInstance.showNotification) {
								window.dashboardInstance.showNotification('error', 'Failed to create rule: ' + (result.error || 'Unknown error'));
							}
						}
					} catch (error) {
						console.error('Error creating hidden rule:', error);
						if (window.dashboardInstance && window.dashboardInstance.showNotification) {
							window.dashboardInstance.showNotification('error', 'Failed to create hidden rule');
						}
					}
				}
			};
		}

		// Global settings modal reference for dashboard integration
		window.settingsModalData = settingsModalData;
	</script>
}