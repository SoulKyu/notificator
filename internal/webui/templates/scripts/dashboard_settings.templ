package scripts

templ DashboardSettings() {
	<script>
		function settingsModalData() {
			return {
				activeTab: 'general',
				colorPreferences: [],
				availableLabels: {},
				availableLabelsLastLoaded: null,
				labelKeyTimeouts: {},
				
				notificationPreferences: {
					enabled: true,
					soundEnabled: true,
					browserNotifications: true,
					cooldownSeconds: 300,
					maxNotifications: 5,
					respectFilters: true,
					severityRules: {
						critical: true,
						major: true,
						warning: true,
						minor: false,
						info: false,
						unknown: false
					},
					soundConfig: {}
				},
				notificationPreferencesSaving: false,
				
				async init() {
					console.log('Settings modal initializing...');
					await this.loadColorPreferences();
					await this.loadAvailableLabels();
					await this.loadNotificationPreferences();
					window.currentSettingsModal = this;
					console.log('Settings modal initialized, window.currentSettingsModal set:', !!window.currentSettingsModal);
				},

				async loadColorPreferences() {
					try {
						const response = await fetch('/api/v1/dashboard/color-preferences', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								this.colorPreferences = (result.data.preferences || []).map(pref => ({
									...pref,
									labelConditions: pref.labelConditions || {},
									bgLightnessFactor: pref.bgLightnessFactor !== undefined ? pref.bgLightnessFactor : 0.9,
									textDarknessFactor: pref.textDarknessFactor !== undefined ? pref.textDarknessFactor : 0.3
								}));
							}
						}
					} catch (error) {
						console.error('Error loading color preferences:', error);
					}
				},

				async loadAvailableLabels() {
					// Check if we already have cached labels and they're not too old (cache for 5 minutes)
					if (this.availableLabels && Object.keys(this.availableLabels).length > 0 && 
						this.availableLabelsLastLoaded && 
						(Date.now() - this.availableLabelsLastLoaded) < 300000) {
						console.log('Using cached available labels');
						return;
					}

					try {
						console.log('Fetching available labels from API...');
						const response = await fetch('/api/v1/dashboard/available-labels', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								this.availableLabels = result.data.labels || {};
								this.availableLabelsLastLoaded = Date.now();
								console.log('Loaded available labels:', Object.keys(this.availableLabels).length, 'label types');
							}
						}
					} catch (error) {
						console.error('Error loading available labels:', error);
						// Fallback to empty object if fetch fails
						this.availableLabels = {};
					}
				},

				async saveColorPreferences() {
					console.log('saveColorPreferences called with preferences:', this.colorPreferences);
					try {
						const response = await fetch('/api/v1/dashboard/color-preferences', {
							method: 'POST',
							credentials: 'include',
							headers: {
								'Content-Type': 'application/json',
							},
							body: JSON.stringify({
								preferences: this.colorPreferences
							})
						});

						const result = await response.json();
						console.log('Color preferences save response:', result);
						if (result.success) {
							// Reload color preferences to show saved state in modal
							await this.loadColorPreferences();
							return true;
						} else {
							console.error('Failed to save color preferences:', result.error);
							return false;
						}
					} catch (error) {
						console.error('Error saving color preferences:', error);
						return false;
					}
				},

				addColorPreference() {
					const newPref = {
						id: String(Date.now() + Math.random()),
						labelKey: '',
						labelValue: '',
						color: '#ff9999',
						colorType: 'custom',
						priority: 0,
						bgLightnessFactor: 0.9,
						textDarknessFactor: 0.3,
						isEditing: true
					};
					this.colorPreferences.push(newPref);
				},

				addLabelCondition(preference) {
					if (!preference.labelConditions) {
						preference.labelConditions = {};
					}
					const key = 'label' + Object.keys(preference.labelConditions).length;
					preference.labelConditions[key] = '';
				},

				ensureAvailableLabels() {
					if (!this.availableLabels || Object.keys(this.availableLabels).length === 0) {
						this.loadAvailableLabels();
					}
				},

				editColorPreference(id) {
					const pref = this.colorPreferences.find(p => p.id === id);
					if (pref) {
						pref.isEditing = true;
					}
				},

				cancelEditColorPreference(id) {
					const index = this.colorPreferences.findIndex(p => p.id === id);
					if (index !== -1) {
						const pref = this.colorPreferences[index];
						if (!pref.labelKey && !pref.labelValue) {
							// Remove if it's a new preference being cancelled
							this.colorPreferences.splice(index, 1);
						} else {
							pref.isEditing = false;
						}
					}
				},

				removeColorPreference(index) {
					this.colorPreferences.splice(index, 1);
				},

				async saveColorPreference(id) {
					const pref = this.colorPreferences.find(p => p.id === id);
					if (!pref || !pref.labelKey.trim() || !pref.labelValue.trim()) {
						console.warn('Cannot save color preference: missing required fields');
						return;
					}

					try {
						const method = pref.serverId ? 'PUT' : 'POST';
						const url = pref.serverId 
							? `/api/v1/dashboard/color-preferences/${pref.serverId}`
							: '/api/v1/dashboard/color-preferences';

						const response = await fetch(url, {
							method: method,
							credentials: 'include',
							headers: {
								'Content-Type': 'application/json',
							},
							body: JSON.stringify({
								labelKey: pref.labelKey.trim(),
								labelValue: pref.labelValue.trim(),
								color: pref.color,
								colorType: pref.colorType || 'custom',
								priority: pref.priority || 0,
								bgLightnessFactor: pref.bgLightnessFactor || 0.9,
								textDarknessFactor: pref.textDarknessFactor || 0.3
							})
						});

						const result = await response.json();
						if (result.success) {
							// Update the preference with server data
							if (result.data && result.data.id) {
								pref.serverId = result.data.id;
							}
							pref.isEditing = false;
							console.log('Color preference saved successfully');
							
							// Trigger alert color refresh in dashboard
							if (window.dashboardInstance && typeof window.dashboardInstance.refreshAlertColors === 'function') {
								console.log('Triggering dashboard alert color refresh...');
								await window.dashboardInstance.refreshAlertColors();
							}
						} else {
							console.error('Failed to save color preference:', result.error);
						}
					} catch (error) {
						console.error('Error saving color preference:', error);
					}
				},

				async deleteColorPreference(id) {
					if (!confirm('Are you sure you want to delete this color preference?')) {
						return;
					}

					const index = this.colorPreferences.findIndex(p => p.id === id);
					if (index === -1) return;

					const pref = this.colorPreferences[index];
					
					// If it has a server ID, delete from server
					if (pref.serverId) {
						try {
							const response = await fetch(`/api/v1/dashboard/color-preferences/${pref.serverId}`, {
								method: 'DELETE',
								credentials: 'include'
							});

							const result = await response.json();
							if (!result.success) {
								console.error('Failed to delete color preference from server:', result.error);
								return;
							}
						} catch (error) {
							console.error('Error deleting color preference:', error);
							return;
						}
					}

					// Remove from local array
					this.colorPreferences.splice(index, 1);
					console.log('Color preference deleted successfully');
					
					// Trigger alert color refresh in dashboard
					if (window.dashboardInstance && typeof window.dashboardInstance.refreshAlertColors === 'function') {
						console.log('Triggering dashboard alert color refresh after deletion...');
						await window.dashboardInstance.refreshAlertColors();
					}
				},

				// Get available values for a selected label key
				getAvailableValuesForLabel(labelKey) {
					return this.availableLabels[labelKey] || [];
				},

				// Get available severities from dashboard metadata
				getAvailableSeverities() {
					if (window.dashboardInstance && window.dashboardInstance.metadata && window.dashboardInstance.metadata.availableFilters) {
						return window.dashboardInstance.metadata.availableFilters.severities || [];
					}
					return [];
				},

				// Initialize dynamic severity rules based on available severities
				initializeDynamicSeverityRules() {
					const availableSeverities = this.getAvailableSeverities();
					const currentRules = this.notificationPreferences.severityRules || {};
					const newRules = {};

					// Keep existing preferences for known severities
					availableSeverities.forEach(severity => {
						const severityKey = severity.toLowerCase();
						// Use existing preference if available, otherwise default based on severity type
						if (currentRules.hasOwnProperty(severityKey)) {
							newRules[severityKey] = currentRules[severityKey];
						} else {
							// Default rules: enable critical, warning, major; disable others
							newRules[severityKey] = ['critical', 'major', 'warning'].includes(severityKey);
						}
					});

					// Update notification preferences with dynamic rules
					this.notificationPreferences.severityRules = newRules;
				},

				// Debounced update for label condition keys to improve performance
				updateLabelConditionKey(preference, oldKey, newKey) {
					if (oldKey !== newKey && newKey.trim() !== '') {
						const value = preference.labelConditions[oldKey];
						delete preference.labelConditions[oldKey];
						preference.labelConditions[newKey] = value;
					}
				},

				// Debounced version for input events - only updates after user stops typing
				debouncedUpdateLabelConditionKey(preference, oldKey, newKey) {
					// Clear existing timeout for this specific input
					const timeoutKey = `${preference.id}-${oldKey}`;
					if (this.labelKeyTimeouts && this.labelKeyTimeouts[timeoutKey]) {
						clearTimeout(this.labelKeyTimeouts[timeoutKey]);
					}

					// Initialize timeouts object if it doesn't exist
					if (!this.labelKeyTimeouts) {
						this.labelKeyTimeouts = {};
					}

					// Set new timeout to update after 300ms of no typing
					this.labelKeyTimeouts[timeoutKey] = setTimeout(() => {
						this.updateLabelConditionKey(preference, oldKey, newKey);
						delete this.labelKeyTimeouts[timeoutKey];
					}, 300);
				},

				// Get severity color for UI display
				getSeverityColor(severity) {
					const severityLower = severity.toLowerCase();
					const colorMap = {
						'critical': 'red',
						'major': 'orange', 
						'warning': 'yellow',
						'minor': 'blue',
						'info': 'green',
						'information': 'green',
						'unknown': 'gray'
					};
					return colorMap[severityLower] || 'gray';
				},

				// Get severity display name
				getSeverityDisplayName(severity) {
					const displayMap = {
						'info': 'Info',
						'information': 'Info',
						'critical': 'Critical',
						'major': 'Major',
						'warning': 'Warning',
						'minor': 'Minor',
						'unknown': 'Unknown'
					};
					return displayMap[severity.toLowerCase()] || severity.charAt(0).toUpperCase() + severity.slice(1);
				},

				// Initialize dynamic sound configuration based on available severities
				initializeDynamicSoundConfig() {
					const availableSeverities = this.getAvailableSeverities();
					const currentSoundConfig = this.notificationPreferences.soundConfig || {};
					const newSoundConfig = {};

					// Process each available severity
					availableSeverities.forEach(severity => {
						const severityKey = severity.toLowerCase();
						const freqKey = `${severityKey}_frequency`;
						const durKey = `${severityKey}_duration`;
						const typeKey = `${severityKey}_type`;

						// Use existing config if available, otherwise use defaults
						if (currentSoundConfig.hasOwnProperty(freqKey)) {
							newSoundConfig[freqKey] = currentSoundConfig[freqKey];
							newSoundConfig[durKey] = currentSoundConfig[durKey];
							newSoundConfig[typeKey] = currentSoundConfig[typeKey];
						} else {
							// Set intelligent defaults based on severity type
							const defaults = this.getDefaultSoundConfigForSeverity(severityKey);
							newSoundConfig[freqKey] = defaults.frequency;
							newSoundConfig[durKey] = defaults.duration;
							newSoundConfig[typeKey] = defaults.type;
						}
					});

					// Update notification preferences with dynamic sound config
					this.notificationPreferences.soundConfig = newSoundConfig;
				},

				// Get default sound configuration for a severity
				getDefaultSoundConfigForSeverity(severity) {
					const severityLower = severity.toLowerCase();
					
					// Default configurations based on severity urgency
					switch (severityLower) {
						case 'critical':
						case 'major':
							return { frequency: 800, duration: 200, type: 'square' };
						case 'warning':
						case 'minor':
							return { frequency: 600, duration: 150, type: 'sine' };
						case 'info':
						case 'information':
							return { frequency: 400, duration: 100, type: 'sine' };
						default:
							// Unknown severities get a neutral sound
							return { frequency: 500, duration: 120, type: 'triangle' };
					}
				},

				// Test sound with current form settings (preview functionality)
				testSoundWithPreview(severity) {
					if (!window.dashboardInstance || !window.dashboardInstance.audioContext) {
						console.warn('Audio context not available for sound preview');
						return;
					}

					const severityKey = severity.toLowerCase();
					
					// Read current values directly from DOM elements to get the most up-to-date user input
					const frequencyInput = document.querySelector(`input[type="number"][x-model*="${severityKey}_frequency"]`);
					const durationInput = document.querySelector(`input[type="number"][x-model*="${severityKey}_duration"]`);
					const typeSelect = document.querySelector(`select[x-model*="${severityKey}_type"]`);
					
					const soundConfig = {
						frequency: frequencyInput ? parseInt(frequencyInput.value) || 500 : 500,
						duration: durationInput ? parseInt(durationInput.value) || 150 : 150,
						type: typeSelect ? typeSelect.value || 'sine' : 'sine'
					};
					
					console.log(`Testing sound for ${severity} with current form values:`, soundConfig);
					this.playPreviewSound(soundConfig);
				},

				// Play sound with specific configuration (for testing)
				playPreviewSound(soundConfig) {
					if (!window.dashboardInstance || !window.dashboardInstance.audioContext) {
						return;
					}

					try {
						const audioContext = window.dashboardInstance.audioContext;
						const oscillator = audioContext.createOscillator();
						const gainNode = audioContext.createGain();
						
						oscillator.connect(gainNode);
						gainNode.connect(audioContext.destination);
						
						oscillator.frequency.setValueAtTime(soundConfig.frequency, audioContext.currentTime);
						oscillator.type = soundConfig.type;
						
						gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
						gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + soundConfig.duration / 1000);
						
						oscillator.start(audioContext.currentTime);
						oscillator.stop(audioContext.currentTime + soundConfig.duration / 1000);
					} catch (error) {
						console.warn('Failed to play preview sound:', error);
					}
				},

				// Get current sound config from DOM form values (for saving real-time user input)
				getCurrentSoundConfigFromDOM() {
					const availableSeverities = this.getAvailableSeverities();
					const currentSoundConfig = {};
					
					// Read current form values for each available severity
					availableSeverities.forEach(severity => {
						const severityKey = severity.toLowerCase();
						
						// Query DOM for frequency, duration, and type inputs
						const frequencyInput = document.querySelector(`input[type="number"][x-model*="${severityKey}_frequency"]`);
						const durationInput = document.querySelector(`input[type="number"][x-model*="${severityKey}_duration"]`);
						const typeSelect = document.querySelector(`select[x-model*="${severityKey}_type"]`);
						
						// Extract values with defaults and ensure clean data types
						const freqKey = `${severityKey}_frequency`;
						const durKey = `${severityKey}_duration`;
						const typeKey = `${severityKey}_type`;
						
						// Ensure integers are clean and valid
						let frequency = 500;
						let duration = 150;
						let soundType = 'sine';
						
						if (frequencyInput && frequencyInput.value) {
							const parsedFreq = parseInt(frequencyInput.value, 10);
							frequency = (isNaN(parsedFreq) || parsedFreq < 100 || parsedFreq > 2000) ? 500 : parsedFreq;
						}
						
						if (durationInput && durationInput.value) {
							const parsedDur = parseInt(durationInput.value, 10);
							duration = (isNaN(parsedDur) || parsedDur < 50 || parsedDur > 5000) ? 150 : parsedDur;
						}
						
						if (typeSelect && typeSelect.value) {
							const validTypes = ['sine', 'square', 'triangle', 'sawtooth'];
							soundType = validTypes.includes(typeSelect.value) ? typeSelect.value : 'sine';
						}
						
						currentSoundConfig[freqKey] = frequency;
						currentSoundConfig[durKey] = duration;
						currentSoundConfig[typeKey] = soundType;
					});
					
					console.log('Reading current sound config from DOM:', currentSoundConfig);
					return currentSoundConfig;
				},

				// Preview the color combination with lightness factors
				getPreviewStyle(pref) {
					if (!pref.color) return '';
					
					// Use the base color and apply lightness factors
					const baseColor = pref.color;
					const bgLightness = pref.bgLightnessFactor || 0.9;
					const textDarkness = pref.textDarknessFactor || 0.3;
					
					// For custom colors, simulate the lightening/darkening effects
					if (pref.colorType === 'custom' && baseColor.startsWith('#')) {
						const bgColor = this.lightenColorSimulation(baseColor, bgLightness);
						const textColor = this.darkenColorSimulation(baseColor, textDarkness);
						return `background-color: ${bgColor}; color: ${textColor}; padding: 2px 8px; border-radius: 4px; display: inline-block; min-width: 60px; text-align: center; border: 1px solid ${baseColor};`;
					}
					
					// For other color types, just use the base color
					return `background-color: ${baseColor}; color: white; padding: 2px 8px; border-radius: 4px; display: inline-block; min-width: 60px; text-align: center;`;
				},
				
				// Simple color lightening simulation for preview
				lightenColorSimulation(hexColor, factor) {
					// Remove # if present
					const hex = hexColor.replace('#', '');
					const r = parseInt(hex.substr(0, 2), 16);
					const g = parseInt(hex.substr(2, 2), 16);
					const b = parseInt(hex.substr(4, 2), 16);
					
					// Lighten by interpolating towards white
					const newR = Math.round(r + (255 - r) * factor);
					const newG = Math.round(g + (255 - g) * factor);
					const newB = Math.round(b + (255 - b) * factor);
					
					return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
				},
				
				// Simple color darkening simulation for preview
				darkenColorSimulation(hexColor, factor) {
					// Remove # if present
					const hex = hexColor.replace('#', '');
					const r = parseInt(hex.substr(0, 2), 16);
					const g = parseInt(hex.substr(2, 2), 16);
					const b = parseInt(hex.substr(4, 2), 16);
					
					// Darken by interpolating towards black
					const newR = Math.round(r * (1 - factor));
					const newG = Math.round(g * (1 - factor));
					const newB = Math.round(b * (1 - factor));
					
					return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
				},

				// Tab management
				setActiveTab(tab) {
					this.activeTab = tab;
					if (tab === 'colors') {
						// Refresh available labels when opening colors tab
						this.loadAvailableLabels();
					} else if (tab === 'notifications') {
						// Reload notification preferences to ensure fresh backend data (like color preferences)
						this.loadNotificationPreferences();
					}
				},

				// Form validation
				isValidColorPreference(pref) {
					return pref.labelKey.trim() && pref.labelValue.trim() && pref.color;
				},

				// Check if a color preference has unsaved changes
				hasUnsavedChanges(pref) {
					return pref.isEditing;
				},

				// Color utility functions
				generateRandomColor() {
					const colors = [
						'#ff9999', '#99ff99', '#9999ff', '#ffff99', '#ff99ff', '#99ffff',
						'#ffcc99', '#cc99ff', '#99ffcc', '#ccff99', '#ff99cc', '#99ccff'
					];
					return colors[Math.floor(Math.random() * colors.length)];
				},

				// Get contrasting text color for background
				getContrastingTextColor(bgColor) {
					// Simple contrast calculation - convert hex to RGB and check luminance
					const hex = bgColor.replace('#', '');
					const r = parseInt(hex.substr(0, 2), 16);
					const g = parseInt(hex.substr(2, 2), 16);
					const b = parseInt(hex.substr(4, 2), 16);
					
					// Calculate luminance
					const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
					
					return luminance > 0.5 ? '#000000' : '#ffffff';
				},

				// Auto-set contrasting text color when background changes
				onBgColorChange(pref) {
					pref.textColor = this.getContrastingTextColor(pref.bgColor);
				},

				// Notification Preference Methods
				async loadNotificationPreferences() {
					try {
						const response = await fetch('/api/v1/dashboard/notification-preferences', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success && result.data.preference) {
								const backendPrefs = result.data.preference;
								
								// Convert backend format (snake_case) to frontend format (camelCase)
								const frontendPrefs = {
									enabled: backendPrefs.enabled,
									soundEnabled: backendPrefs.sound_enabled,
									browserNotifications: backendPrefs.browser_notifications,
									cooldownSeconds: backendPrefs.cooldown_seconds,
									maxNotifications: backendPrefs.max_notifications,
									respectFilters: backendPrefs.respect_filters,
									severityRules: backendPrefs.severity_rules || {},
									soundConfig: backendPrefs.sound_config || {}
								};
								
								// Merge with defaults, preferring loaded values
								this.notificationPreferences = { 
									...this.notificationPreferences, 
									...frontendPrefs 
								};
								console.log('Loaded notification preferences:', this.notificationPreferences);
								
								// Initialize dynamic severity rules after loading preferences
								this.initializeDynamicSeverityRules();
								// Initialize dynamic sound configuration
								this.initializeDynamicSoundConfig();
							}
						}
					} catch (error) {
						console.error('Error loading notification preferences:', error);
					}
				},

				async saveNotificationPreferences() {
					console.log('Starting saveNotificationPreferences() from settings modal');
					this.notificationPreferencesSaving = true;
					try {
						// Get current sound config from DOM to capture real-time user input
						const currentSoundConfig = this.getCurrentSoundConfigFromDOM();
						
						// Pre-validate JSON serialization to catch issues early
						try {
							JSON.stringify(currentSoundConfig);
						} catch (jsonError) {
							console.error('Invalid sound config data - cannot serialize to JSON:', jsonError);
							console.error('Problematic data:', currentSoundConfig);
							if (window.dashboardInstance && window.dashboardInstance.showNotification) {
								window.dashboardInstance.showNotification('error', 'Invalid sound configuration data. Please check your settings.');
							}
							return;
						}
						
						// Clean up the payload and convert frontend format to backend format
						const cleanPreferences = {
							enabled: this.notificationPreferences.enabled,
							sound_enabled: this.notificationPreferences.soundEnabled,
							browser_notifications: this.notificationPreferences.browserNotifications,
							cooldown_seconds: this.notificationPreferences.cooldownSeconds,
							max_notifications: this.notificationPreferences.maxNotifications,
							respect_filters: this.notificationPreferences.respectFilters,
							severity_rules: this.notificationPreferences.severityRules,
							sound_config: currentSoundConfig  // Use real DOM values instead of cached data
						};

						console.log('Sending notification preferences to server:', cleanPreferences);

						const response = await fetch('/api/v1/dashboard/notification-preferences', {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							credentials: 'include',
							body: JSON.stringify({ preference: cleanPreferences })
						});
						
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								console.log('Notification preferences saved successfully');
								
								// Show success message
								if (window.dashboardInstance && window.dashboardInstance.showNotification) {
									window.dashboardInstance.showNotification('success', 'Notification preferences saved successfully');
								}
							} else {
								console.error('Failed to save notification preferences:', result.error);
								if (window.dashboardInstance && window.dashboardInstance.showNotification) {
									window.dashboardInstance.showNotification('error', 'Failed to save notification preferences: ' + result.error);
								}
							}
						}
					} catch (error) {
						console.error('Error saving notification preferences:', error);
						if (window.dashboardInstance && window.dashboardInstance.showNotification) {
							window.dashboardInstance.showNotification('error', 'Error saving notification preferences');
						}
					} finally {
						this.notificationPreferencesSaving = false;
					}
				},

				testNotification() {
					if (window.dashboardInstance && window.dashboardInstance.showInAppNotification) {
						window.dashboardInstance.showInAppNotification('info', 'Test notification - your notification settings are working!');
					}
					
					// Also test sound if enabled
					if (this.notificationPreferences.sound_enabled && window.dashboardInstance && window.dashboardInstance.playNotificationSound) {
						window.dashboardInstance.playNotificationSound('info');
					}
				},

				testSound(severity) {
					// Use the new preview functionality that uses current form settings
					this.testSoundWithPreview(severity);
				}
			};
		}

		// Global settings modal reference for dashboard integration
		window.settingsModalData = settingsModalData;
	</script>
}