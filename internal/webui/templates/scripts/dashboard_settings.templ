package scripts

templ DashboardSettings() {
	<script>
		function settingsModalData() {
			return {
				activeTab: 'general',
				colorPreferences: [],
				availableLabels: {},
				availableLabelsLastLoaded: null,
				labelKeyTimeouts: {},
				
				// Hidden alerts data
				hiddenAlerts: [],
				hiddenRules: [],
				hiddenAlertsLoading: false,
				hiddenRulesLoading: false,
				
				// Hidden Rules Modal
				showHiddenRuleModal: false,
				hiddenRuleForm: {
					name: '',
					labelKey: '',
					labelValue: '',
					description: '',
					enabled: true
				},
				
				settings: {
					theme: 'light',
					resolvedAlertsRetention: 7,
					resolvedAlertsLimit: 100,
					refreshInterval: 30
				},
				
				// Sentry integration data
				sentryConfig: {
					hasToken: false,
					baseUrl: 'https://sentry.io',
					authStatus: 'none',
					connectionTesting: false
				},
				sentryForm: {
					token: '',
					baseUrl: 'https://sentry.io'
				},
				sentrySaving: false,
				settingsSaving: false,

				// Notification preferences
				notificationPreferences: {
					browserNotificationsEnabled: false,
					enabledSeverities: ['critical', 'warning'],
					soundNotificationsEnabled: true
				},
				// Browser notification permission (reactive state for UI)
				browserNotificationPermission: 'default', // 'default', 'granted', 'denied'

				async init() {
					console.log('Settings modal initializing...');
					await this.loadSettings();
					await this.loadColorPreferences();
					await this.loadAvailableLabels();
					await this.loadHiddenAlerts();
					await this.loadHiddenRules();
					await this.loadSentryConfig();
					await this.loadNotificationPreferences();
					await this.loadAnnotationButtonConfigs();
					this.checkBrowserPermission(); // Check current browser permission status
					window.currentSettingsModal = this;
					console.log('Settings modal initialized, window.currentSettingsModal set:', !!window.currentSettingsModal);
				},

				async loadSettings() {
					try {
						// Load settings from localStorage for now (can be extended to backend later)
						const savedSettings = localStorage.getItem('dashboardSettings');
						if (savedSettings) {
							const parsedSettings = JSON.parse(savedSettings);
							this.settings = { ...this.settings, ...parsedSettings };
						}
						
						// Also check for theme preference from dashboard instance
						if (window.dashboardInstance && window.dashboardInstance.currentTheme) {
							this.settings.theme = window.dashboardInstance.currentTheme;
						}
						
						console.log('Loaded general settings:', this.settings);
					} catch (error) {
						console.error('Error loading general settings:', error);
					}
				},

				async loadColorPreferences() {
					try {
						const response = await fetch('/api/v1/dashboard/color-preferences', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								this.colorPreferences = (result.data.preferences || []).map(pref => ({
									...pref,
									labelConditions: pref.labelConditions || {},
									bgLightnessFactor: pref.bgLightnessFactor !== undefined ? pref.bgLightnessFactor : 0.9,
									textDarknessFactor: pref.textDarknessFactor !== undefined ? pref.textDarknessFactor : 0.3
								}));
							}
						}
					} catch (error) {
						console.error('Error loading color preferences:', error);
					}
				},

				async loadAvailableLabels() {
					// Check if we already have cached labels and they're not too old (cache for 5 minutes)
					if (this.availableLabels && Object.keys(this.availableLabels).length > 0 && 
						this.availableLabelsLastLoaded && 
						(Date.now() - this.availableLabelsLastLoaded) < 300000) {
						console.log('Using cached available labels');
						return;
					}

					try {
						console.log('Fetching available labels from API...');
						const response = await fetch('/api/v1/dashboard/available-labels', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								this.availableLabels = result.data.labels || {};
								this.availableLabelsLastLoaded = Date.now();
								console.log('Loaded available labels:', Object.keys(this.availableLabels).length, 'label types');
							}
						}
					} catch (error) {
						console.error('Error loading available labels:', error);
						// Fallback to empty object if fetch fails
						this.availableLabels = {};
					}
				},

				async saveColorPreferences() {
					console.log('saveColorPreferences called with preferences:', this.colorPreferences);
					try {
						const response = await fetch('/api/v1/dashboard/color-preferences', {
							method: 'POST',
							credentials: 'include',
							headers: {
								'Content-Type': 'application/json',
							},
							body: JSON.stringify({
								preferences: this.colorPreferences
							})
						});

						const result = await response.json();
						console.log('Color preferences save response:', result);
						if (result.success) {
							// Reload color preferences to show saved state in modal
							await this.loadColorPreferences();
							return true;
						} else {
							console.error('Failed to save color preferences:', result.error);
							return false;
						}
					} catch (error) {
						console.error('Error saving color preferences:', error);
						return false;
					}
				},

				addColorPreference() {
					const newPref = {
						id: String(Date.now() + Math.random()),
						labelKey: '',
						labelValue: '',
						color: '#ff9999',
						colorType: 'custom',
						priority: 0,
						bgLightnessFactor: 0.9,
						textDarknessFactor: 0.3,
						isEditing: true
					};
					this.colorPreferences.push(newPref);
				},

				addLabelCondition(preference) {
					if (!preference.labelConditions) {
						preference.labelConditions = {};
					}
					const key = 'label' + Object.keys(preference.labelConditions).length;
					preference.labelConditions[key] = '';
				},

				ensureAvailableLabels() {
					if (!this.availableLabels || Object.keys(this.availableLabels).length === 0) {
						this.loadAvailableLabels();
					}
				},

				editColorPreference(id) {
					const pref = this.colorPreferences.find(p => p.id === id);
					if (pref) {
						pref.isEditing = true;
					}
				},

				cancelEditColorPreference(id) {
					const index = this.colorPreferences.findIndex(p => p.id === id);
					if (index !== -1) {
						const pref = this.colorPreferences[index];
						if (!pref.labelKey && !pref.labelValue) {
							// Remove if it's a new preference being cancelled
							this.colorPreferences.splice(index, 1);
						} else {
							pref.isEditing = false;
						}
					}
				},

				removeColorPreference(index) {
					this.colorPreferences.splice(index, 1);
				},

				// Get available values for a selected label key
				getAvailableValuesForLabel(labelKey) {
					return this.availableLabels[labelKey] || [];
				},

				// Get available severities from dashboard metadata
				getAvailableSeverities() {
					if (window.dashboardInstance && window.dashboardInstance.metadata && window.dashboardInstance.metadata.availableFilters) {
						return window.dashboardInstance.metadata.availableFilters.severities || [];
					}
					return [];
				},


				// Debounced update for label condition keys to improve performance
				updateLabelConditionKey(preference, oldKey, newKey) {
					if (oldKey !== newKey && newKey.trim() !== '') {
						const value = preference.labelConditions[oldKey];
						delete preference.labelConditions[oldKey];
						preference.labelConditions[newKey] = value;
					}
				},

				// Debounced version for input events - only updates after user stops typing
				debouncedUpdateLabelConditionKey(preference, oldKey, newKey) {
					// Clear existing timeout for this specific input
					const timeoutKey = `${preference.id}-${oldKey}`;
					if (this.labelKeyTimeouts && this.labelKeyTimeouts[timeoutKey]) {
						clearTimeout(this.labelKeyTimeouts[timeoutKey]);
					}

					// Initialize timeouts object if it doesn't exist
					if (!this.labelKeyTimeouts) {
						this.labelKeyTimeouts = {};
					}

					// Set new timeout to update after 300ms of no typing
					this.labelKeyTimeouts[timeoutKey] = setTimeout(() => {
						this.updateLabelConditionKey(preference, oldKey, newKey);
						delete this.labelKeyTimeouts[timeoutKey];
					}, 300);
				},

				// Get severity color for UI display
				getSeverityColor(severity) {
					const severityLower = severity.toLowerCase();
					const colorMap = {
						'critical': 'red',
						'major': 'orange', 
						'warning': 'yellow',
						'minor': 'blue',
						'info': 'green',
						'information': 'green',
						'unknown': 'gray'
					};
					return colorMap[severityLower] || 'gray';
				},

				// Get severity display name
				getSeverityDisplayName(severity) {
					const displayMap = {
						'info': 'Info',
						'information': 'Info',
						'critical': 'Critical',
						'major': 'Major',
						'warning': 'Warning',
						'minor': 'Minor',
						'unknown': 'Unknown'
					};
					return displayMap[severity.toLowerCase()] || severity.charAt(0).toUpperCase() + severity.slice(1);
				},


				// Preview the color combination with lightness factors
				getPreviewStyle(pref) {
					if (!pref.color) return '';
					
					// Use the base color and apply lightness factors
					const baseColor = pref.color;
					const bgLightness = pref.bgLightnessFactor || 0.9;
					const textDarkness = pref.textDarknessFactor || 0.3;
					
					// For custom colors, simulate the lightening/darkening effects
					if (pref.colorType === 'custom' && baseColor.startsWith('#')) {
						const bgColor = this.lightenColorSimulation(baseColor, bgLightness);
						const textColor = this.darkenColorSimulation(baseColor, textDarkness);
						return `background-color: ${bgColor}; color: ${textColor}; padding: 2px 8px; border-radius: 4px; display: inline-block; min-width: 60px; text-align: center; border: 1px solid ${baseColor};`;
					}
					
					// For other color types, just use the base color
					return `background-color: ${baseColor}; color: white; padding: 2px 8px; border-radius: 4px; display: inline-block; min-width: 60px; text-align: center;`;
				},
				
				// Simple color lightening simulation for preview
				lightenColorSimulation(hexColor, factor) {
					// Remove # if present
					const hex = hexColor.replace('#', '');
					const r = parseInt(hex.substr(0, 2), 16);
					const g = parseInt(hex.substr(2, 2), 16);
					const b = parseInt(hex.substr(4, 2), 16);
					
					// Lighten by interpolating towards white
					const newR = Math.round(r + (255 - r) * factor);
					const newG = Math.round(g + (255 - g) * factor);
					const newB = Math.round(b + (255 - b) * factor);
					
					return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
				},
				
				// Simple color darkening simulation for preview
				darkenColorSimulation(hexColor, factor) {
					// Remove # if present
					const hex = hexColor.replace('#', '');
					const r = parseInt(hex.substr(0, 2), 16);
					const g = parseInt(hex.substr(2, 2), 16);
					const b = parseInt(hex.substr(4, 2), 16);
					
					// Darken by interpolating towards black
					const newR = Math.round(r * (1 - factor));
					const newG = Math.round(g * (1 - factor));
					const newB = Math.round(b * (1 - factor));
					
					return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
				},

				// Tab management
				setActiveTab(tab) {
					this.activeTab = tab;
					if (tab === 'colors') {
						// Refresh available labels when opening colors tab
						this.loadAvailableLabels();
					} else if (tab === 'hidden-alerts') {
						// Refresh hidden alerts data when opening hidden alerts tab
						this.loadHiddenAlerts();
						this.loadHiddenRules();
					} else if (tab === 'annotation-buttons') {
						// Refresh annotation button configs when opening annotation buttons tab
						this.loadAnnotationButtonConfigs();
					}
				},

				// Form validation
				isValidColorPreference(pref) {
					return pref.labelKey.trim() && pref.labelValue.trim() && pref.color;
				},

				// Check if a color preference has unsaved changes
				hasUnsavedChanges(pref) {
					return pref.isEditing;
				},

				// Color utility functions
				generateRandomColor() {
					const colors = [
						'#ff9999', '#99ff99', '#9999ff', '#ffff99', '#ff99ff', '#99ffff',
						'#ffcc99', '#cc99ff', '#99ffcc', '#ccff99', '#ff99cc', '#99ccff'
					];
					return colors[Math.floor(Math.random() * colors.length)];
				},

				// Get contrasting text color for background
				getContrastingTextColor(bgColor) {
					// Simple contrast calculation - convert hex to RGB and check luminance
					const hex = bgColor.replace('#', '');
					const r = parseInt(hex.substr(0, 2), 16);
					const g = parseInt(hex.substr(2, 2), 16);
					const b = parseInt(hex.substr(4, 2), 16);
					
					// Calculate luminance
					const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
					
					return luminance > 0.5 ? '#000000' : '#ffffff';
				},

				// Auto-set contrasting text color when background changes
				onBgColorChange(pref) {
					pref.textColor = this.getContrastingTextColor(pref.bgColor);
				},

				async saveHiddenRules() {
					console.log('saveHiddenRules called - hidden rules are saved individually when created');
					try {
						// Hidden rules are automatically saved to backend when created via createHiddenRule()
						// This function provides consistency in the unified save process
						// and ensures all rules in the current session are validated
						
						// Validate that all rules have been properly saved
						if (this.hiddenRules && this.hiddenRules.length > 0) {
							console.log(`Validated ${this.hiddenRules.length} hidden rules in current session`);
						}
						
						// All hidden rules are already persisted to backend
						// Return true to indicate successful save operation
						return true;
					} catch (error) {
						console.error('Error validating hidden rules:', error);
						return false;
					}
				},

				async saveSettings() {
					console.log('Starting unified settings save...');
					this.settingsSaving = true;
					
					try {
						// Save general settings to localStorage
						localStorage.setItem('dashboardSettings', JSON.stringify(this.settings));
						
						// Apply theme change immediately if changed
						if (window.dashboardInstance && typeof window.dashboardInstance.setTheme === 'function') {
							window.dashboardInstance.setTheme(this.settings.theme);
						}
						
						console.log('General settings saved:', this.settings);

						// Save color preferences (save all existing preferences)
						const colorResult = await this.saveColorPreferences();
						if (!colorResult) {
							throw new Error('Failed to save color preferences');
						}
						
						// Save hidden rules (ensure all rules are persisted)
						const hiddenRulesResult = await this.saveHiddenRules();
						if (!hiddenRulesResult) {
							throw new Error('Failed to save hidden rules');
						}

						// Save notification preferences
						const notificationResult = await this.saveNotificationPreferences();
						if (!notificationResult) {
							throw new Error('Failed to save notification preferences');
						}

						// Save annotation button configs
						const annotationButtonsResult = await this.saveAnnotationButtonConfigs();
						if (!annotationButtonsResult) {
							throw new Error('Failed to save annotation button configs');
						}

						console.log('All settings saved successfully');
						
					} catch (error) {
						console.error('Error saving settings:', error);
					} finally {
						this.settingsSaving = false;
					}
				},

				// Hidden Alerts Management Functions
				async loadHiddenAlerts() {
					this.hiddenAlertsLoading = true;
					try {
						const response = await fetch('/api/v1/dashboard/hidden-alerts', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								this.hiddenAlerts = result.data.hiddenAlerts || [];
								console.log('Loaded hidden alerts:', this.hiddenAlerts.length);
							}
						}
					} catch (error) {
						console.error('Error loading hidden alerts:', error);
					} finally {
						this.hiddenAlertsLoading = false;
					}
				},

				async loadHiddenRules() {
					this.hiddenRulesLoading = true;
					try {
						const response = await fetch('/api/v1/dashboard/hidden-rules', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								this.hiddenRules = result.data.rules || [];
								console.log('Loaded hidden rules:', this.hiddenRules.length);
							}
						}
					} catch (error) {
						console.error('Error loading hidden rules:', error);
					} finally {
						this.hiddenRulesLoading = false;
					}
				},

				async unhideAlert(fingerprint) {
					try {
						const response = await fetch(`/api/v1/dashboard/hidden-alerts/${encodeURIComponent(fingerprint)}`, {
							method: 'DELETE',
							credentials: 'include'
						});

						const result = await response.json();
						
						if (result.success) {
							// Remove from local array
							this.hiddenAlerts = this.hiddenAlerts.filter(alert => alert.fingerprint !== fingerprint);
							
							// Show success message
							
							// Refresh dashboard data if visible
							if (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {
								window.dashboardInstance.loadDashboardData();
							}
						} else {
							console.error('Failed to unhide alert:', result.error);
						}
					} catch (error) {
						console.error('Error unhiding alert:', error);
					}
				},

				async toggleHiddenRule(ruleId) {
					try {
						const rule = this.hiddenRules.find(r => r.id === ruleId);
						if (!rule) return;

						const response = await fetch(`/api/v1/dashboard/hidden-rules/${ruleId}`, {
							method: 'PUT',
							credentials: 'include',
							headers: {
								'Content-Type': 'application/json',
							},
							body: JSON.stringify({
								...rule,
								enabled: !rule.enabled
							})
						});

						const result = await response.json();
						
						if (result.success) {
							// Update local rule
							rule.enabled = !rule.enabled;
							
							// Show success message
							
							// Refresh dashboard data if visible
							if (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {
								window.dashboardInstance.loadDashboardData();
							}
						} else {
							console.error('Failed to toggle hidden rule:', result.error);
						}
					} catch (error) {
						console.error('Error toggling hidden rule:', error);
					}
				},

				async removeHiddenRule(ruleId) {
					if (!confirm('Are you sure you want to delete this hidden rule?')) {
						return;
					}

					try {
						const response = await fetch(`/api/v1/dashboard/hidden-rules/${ruleId}`, {
							method: 'DELETE',
							credentials: 'include'
						});

						const result = await response.json();
						
						if (result.success) {
							// Remove from local array
							this.hiddenRules = this.hiddenRules.filter(rule => rule.id !== ruleId);
							
							// Show success message
							
							// Refresh dashboard data if visible
							if (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {
								window.dashboardInstance.loadDashboardData();
							}
						} else {
							console.error('Failed to delete hidden rule:', result.error);
						}
					} catch (error) {
						console.error('Error deleting hidden rule:', error);
					}
				},

				// Utility function to format timestamps
				formatTimestamp(timestamp) {
					if (!timestamp) return 'Unknown';
					const date = new Date(timestamp);
					return date.toLocaleString();
				},

				// Utility function to truncate long text
				truncateText(text, maxLength = 50) {
					if (!text) return '';
					return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
				},

				// Add new hidden rule function
				addHiddenRule() {
					// Reset the form
					this.hiddenRuleForm = {
						name: '',
						labelKey: '',
						labelValue: '',
						description: '',
						enabled: true
					};
					// Ensure available labels are loaded
					this.ensureAvailableLabels();
					// Show the modal
					this.showHiddenRuleModal = true;
				},
				
				// Cancel hidden rule modal
				cancelHiddenRule() {
					this.showHiddenRuleModal = false;
					this.hiddenRuleForm = {
						name: '',
						labelKey: '',
						labelValue: '',
						description: '',
						enabled: true
					};
				},
				
				// Save hidden rule from modal
				async saveHiddenRule() {
					// Validate required fields
					if (!this.hiddenRuleForm.name.trim() || !this.hiddenRuleForm.labelKey.trim() || !this.hiddenRuleForm.labelValue.trim()) {
						return;
					}
					
					await this.createHiddenRule({
						name: this.hiddenRuleForm.name.trim(),
						labelKey: this.hiddenRuleForm.labelKey.trim(),
						labelValue: this.hiddenRuleForm.labelValue.trim(),
						description: this.hiddenRuleForm.description.trim(),
						enabled: this.hiddenRuleForm.enabled
					});
					
					// Close modal on success
					this.showHiddenRuleModal = false;
				},

				async createHiddenRule(ruleData) {
					try {
						const response = await fetch('/api/v1/dashboard/hidden-rules', {
							method: 'POST',
							credentials: 'include',
							headers: {
								'Content-Type': 'application/json',
							},
							body: JSON.stringify({
								name: ruleData.name,
								labelKey: ruleData.labelKey,
								labelValue: ruleData.labelValue,
								description: ruleData.description,
								enabled: ruleData.enabled
							})
						});

						const result = await response.json();
						
						if (result.success) {
							// Add to local array
							this.hiddenRules.push({
								id: result.data.id,
								...ruleData,
								createdAt: new Date().toISOString()
							});
							
							// Show success message
							
							// Refresh dashboard data
							if (window.dashboardInstance && window.dashboardInstance.loadDashboardData) {
								window.dashboardInstance.loadDashboardData();
							}
						} else {
							console.error('Failed to create hidden rule:', result.error);
						}
					} catch (error) {
						console.error('Error creating hidden rule:', error);
					}
				},

				// Sentry Integration Functions
				async loadSentryConfig() {
					try {
						const response = await fetch('/api/v1/dashboard/sentry-config', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							this.sentryConfig = {
								hasToken: result.has_token || false,
								baseUrl: result.base_url || 'https://sentry.io',
								authStatus: result.auth_status || 'none',
								connectionTesting: false
							};
							this.sentryForm.baseUrl = this.sentryConfig.baseUrl;
							console.log('Loaded Sentry config:', this.sentryConfig);
						}
					} catch (error) {
						console.error('Error loading Sentry config:', error);
					}
				},

				async saveSentryToken() {
					if (!this.sentryForm.token.trim()) {
						return;
					}

					this.sentrySaving = true;
					try {
						const response = await fetch('/api/v1/dashboard/sentry-token', {
							method: 'POST',
							credentials: 'include',
							headers: {
								'Content-Type': 'application/json'
							},
							body: JSON.stringify({
								token: this.sentryForm.token,
								base_url: this.sentryForm.baseUrl
							})
						});

						const result = await response.json();
						
						if (result.success) {
							// Update config to reflect saved state
							this.sentryConfig.hasToken = true;
							this.sentryConfig.authStatus = 'personal_token';
							this.sentryForm.token = '';  // Clear form after saving
							
						} else {
						}
					} catch (error) {
						console.error('Error saving Sentry token:', error);
					} finally {
						this.sentrySaving = false;
					}
				},

				async testSentryConnection() {
					// Get token and base URL from the form
					const token = this.sentryForm.token;
					const baseUrl = this.sentryForm.baseUrl || 'https://sentry.io';

					if (!token.trim()) {
						return;
					}

					this.sentryConfig.connectionTesting = true;
					try {
						const response = await fetch('/api/v1/dashboard/sentry/test-connection', {
							method: 'POST',
							credentials: 'include',
							headers: {
								'Content-Type': 'application/json',
							},
							body: JSON.stringify({
								token: token,
								base_url: baseUrl
							})
						});

						const result = await response.json();
						
						if (result.valid) {
							console.log('Connection Successful')
						} else {
							console.error('Connection Failed')
						}
					} catch (error) {
						console.error('Error testing Sentry connection:', error);
					} finally {
						this.sentryConfig.connectionTesting = false;
					}
				},

				async removeSentryToken() {
					if (!confirm('Are you sure you want to remove your Sentry token?')) {
						return;
					}

					try {
						const response = await fetch('/api/v1/dashboard/sentry-token', {
							method: 'DELETE',
							credentials: 'include'
						});

						const result = await response.json();
						
						if (result.success) {
							// Update config to reflect removed state
							this.sentryConfig.hasToken = false;
							this.sentryConfig.authStatus = 'none';
						} else {
							console.error('Failed to remove Sentry token')
						}
					} catch (error) {
						console.error('Error removing Sentry token:', error);
					}
				},

				// Notification preference methods
				async loadNotificationPreferences() {
					try {
						const response = await fetch('/api/v1/notifications/preferences', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success && result.data) {
								this.notificationPreferences = {
									browserNotificationsEnabled: result.data.browser_notifications_enabled || false,
									enabledSeverities: result.data.enabled_severities || ['critical', 'warning'],
									soundNotificationsEnabled: result.data.sound_notifications_enabled !== undefined ? result.data.sound_notifications_enabled : true
								};
							}
						}
					} catch (error) {
						console.error('Error loading notification preferences:', error);
					}
				},

				async saveNotificationPreferences() {
					try {
						console.log('Saving notification preferences:', this.notificationPreferences);

						const response = await fetch('/api/v1/notifications/preferences', {
							method: 'POST',
							credentials: 'include',
							headers: {
								'Content-Type': 'application/json'
							},
							body: JSON.stringify({
								browser_notifications_enabled: this.notificationPreferences.browserNotificationsEnabled,
								enabled_severities: this.notificationPreferences.enabledSeverities,
								sound_notifications_enabled: this.notificationPreferences.soundNotificationsEnabled
							})
						});

						if (response.ok) {
							const result = await response.json();
							console.log('Notification preferences save response:', result);

							if (result.success) {
								// Update the notification service preferences
								if (window.notificationService) {
									window.notificationService.preferences = this.notificationPreferences;
								}
								console.log('Notification preferences saved successfully');
								return true;
							}
						}

						console.error('Failed to save notification preferences');
						return false;
					} catch (error) {
						console.error('Error saving notification preferences:', error);
						return false;
					}
				},

				checkBrowserPermission() {
					// Check current browser permission status and sync with local state
					if ('Notification' in window) {
						this.browserNotificationPermission = Notification.permission;
						console.log('Browser notification permission:', Notification.permission);

						// Sync with notification service if available
						if (window.notificationService) {
							window.notificationService.permissionGranted = Notification.permission === 'granted';
						}
					} else {
						console.warn('Browser does not support notifications');
						this.browserNotificationPermission = 'denied';
					}
				},

				async requestNotificationPermission() {
					if (!('Notification' in window)) {
						console.warn('Browser does not support notifications');
						return false;
					}

					try {
						console.log('Requesting notification permission...');
						const permission = await Notification.requestPermission();

						// Update local reactive state
						this.browserNotificationPermission = permission;
						console.log('Notification permission result:', permission);

						// Sync with notification service
						if (window.notificationService) {
							window.notificationService.permissionGranted = permission === 'granted';
						}

						return permission === 'granted';
					} catch (error) {
						console.error('Failed to request notification permission:', error);
						return false;
					}
				},

				async testNotification() {
					if (!window.notificationService) {
						console.error('Notification service not available');
						return;
					}

					// Check if permission is granted
					if (!window.notificationService.permissionGranted) {
						alert('Please grant notification permission first');
						return;
					}

					// Create a test alert object
					const testAlert = {
						fingerprint: 'test-' + Date.now(),
						alertName: 'Test Notification',
						summary: 'This is a test notification from Notificator',
						severity: 'info',
						source: 'Dashboard Settings',
						labels: {
							severity: 'info',
							alertname: 'Test Notification'
						},
						annotations: {
							summary: 'This is a test notification from Notificator'
						}
					};

					// Temporarily enable notifications and force the test alert to show
					const originalEnabled = window.notificationService.preferences.browserNotificationsEnabled;
					const originalSeverities = window.notificationService.preferences.enabledSeverities;

					window.notificationService.preferences.browserNotificationsEnabled = true;
					window.notificationService.preferences.enabledSeverities = ['critical', 'warning', 'info'];

					window.notificationService.showNotification(testAlert);

					// Restore original settings
					window.notificationService.preferences.browserNotificationsEnabled = originalEnabled;
					window.notificationService.preferences.enabledSeverities = originalSeverities;
				},

				// Annotation Button Config Management Functions
				annotationButtonConfigs: [],
				annotationButtonsLoading: false,
				annotationButtonsError: '',

				// Color validation/sanitization
				sanitizeColor(color) {
					// Validate hex color format (#RGB or #RRGGBB)
					const hexColorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
					if (hexColorRegex.test(color)) {
						return color;
					}
					return '#6366f1'; // Default indigo-600
				},

				async loadAnnotationButtonConfigs() {
					this.annotationButtonsLoading = true;
					try {
						const response = await fetch('/api/v1/dashboard/annotation-buttons', {
							credentials: 'include'
						});
						if (response.ok) {
							const result = await response.json();
							if (result.success) {
								this.annotationButtonConfigs = result.data.configs || [];
								console.log('Loaded annotation button configs:', this.annotationButtonConfigs.length);
							}
						}
					} catch (error) {
						console.error('Error loading annotation button configs:', error);
					} finally {
						this.annotationButtonsLoading = false;
					}
				},

				async saveAnnotationButtonConfigs() {
					try {
						this.annotationButtonsError = '';

						// Sanitize colors before saving
						const sanitizedConfigs = this.annotationButtonConfigs.map(config => ({
							...config,
							color: this.sanitizeColor(config.color),
							// Filter out empty annotation keys
							annotation_keys: (config.annotation_keys || []).filter(key => key && key.trim())
						}));

						const response = await fetch('/api/v1/dashboard/annotation-buttons', {
							method: 'POST',
							credentials: 'include',
							headers: {
								'Content-Type': 'application/json'
							},
							body: JSON.stringify({
								configs: sanitizedConfigs
							})
						});

						const result = await response.json();
						if (result.success) {
							console.log('Annotation button configs saved successfully');
							await this.loadAnnotationButtonConfigs();
							return true;
						} else {
							const errorMsg = result.error || 'Failed to save annotation button configs';
							console.error('Failed to save:', errorMsg);
							this.annotationButtonsError = errorMsg;
							alert('Error: ' + errorMsg); // User-facing error
							return false;
						}
					} catch (error) {
						console.error('Error saving annotation button configs:', error);
						this.annotationButtonsError = 'Network error: ' + error.message;
						alert('Failed to save annotation button configs. Please try again.');
						return false;
					}
				},

				addAnnotationButton() {
					const newButton = {
						id: String(Date.now() + Math.random()),
						label: 'New Button',
						annotation_keys: [''],
						color: '#6366f1',
						icon: 'link',
						display_order: this.annotationButtonConfigs.length,
						enabled: true,
						button_type: 'custom',
						isEditing: true
					};
					this.annotationButtonConfigs.push(newButton);
				},

				removeAnnotationButton(index) {
					if (confirm('Are you sure you want to remove this button?')) {
						this.annotationButtonConfigs.splice(index, 1);
						// Update display orders
						this.annotationButtonConfigs.forEach((btn, idx) => {
							btn.display_order = idx;
						});
					}
				},

				moveButtonUp(index) {
					if (index > 0) {
						const temp = this.annotationButtonConfigs[index];
						this.annotationButtonConfigs[index] = this.annotationButtonConfigs[index - 1];
						this.annotationButtonConfigs[index - 1] = temp;
						// Update display orders
						this.annotationButtonConfigs.forEach((btn, idx) => {
							btn.display_order = idx;
						});
					}
				},

				moveButtonDown(index) {
					if (index < this.annotationButtonConfigs.length - 1) {
						const temp = this.annotationButtonConfigs[index];
						this.annotationButtonConfigs[index] = this.annotationButtonConfigs[index + 1];
						this.annotationButtonConfigs[index + 1] = temp;
						// Update display orders
						this.annotationButtonConfigs.forEach((btn, idx) => {
							btn.display_order = idx;
						});
					}
				},

				addAnnotationKey(button) {
					if (!button.annotation_keys) {
						button.annotation_keys = [];
					}
					button.annotation_keys.push('');
				},

				removeAnnotationKey(button, index) {
					button.annotation_keys.splice(index, 1);
				},

				toggleButtonEdit(button) {
					button.isEditing = !button.isEditing;
				}
			};
		}

		// Global settings modal reference for dashboard integration
		window.settingsModalData = settingsModalData;
	</script>
}