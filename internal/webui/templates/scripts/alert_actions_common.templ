package scripts

// Common alert actions script shared between dashboard and standalone alert page
templ AlertActionsCommon() {
	<script>
		window.alertActionsCommonMixin = {
			// Related alerts state variables
			relatedFilter: 'all',
			relatedCurrentPage: 1,
			relatedPageSize: 10,
			relatedTotalResults: 0,
			relatedTotalPages: 0,
			relatedAllAlerts: [],
			relatedSearchQuery: '',
			relatedLoading: false,
			relatedAlerts: [],
			
			// Modal state variables
			showAckModal: false,
			ackAction: 'single', // 'single', 'bulk', or 'group'
			ackReason: '',
			ackError: '',
			ackSubmitting: false,
			currentAckAlert: null,
			currentGroupName: '',
			
			showSilenceModal: false,
			silenceAction: 'single', // 'single', 'bulk', or 'group'
			silenceReason: '',
			silenceError: '',
			silenceSubmitting: false,
			currentSilenceAlert: null,
			silenceDuration: '1h',
			silenceDurationType: 'preset', // 'preset' or 'custom'
			customSilenceDuration: '',
			customDurationError: '',

			// Acknowledge Modal Functions
			cancelAcknowledgment() {
				this.showAckModal = false;
				this.ackReason = '';
				this.ackError = '';
				this.ackSubmitting = false;
				this.currentAckAlert = null;
				this.currentGroupName = '';
			},
			
			async submitAcknowledgment() {
				if (!this.ackReason.trim()) {
					this.ackError = 'Please provide a reason for the acknowledgment';
					return;
				}
				
				this.ackSubmitting = true;
				this.ackError = '';
				
				try {
					let request;
					let successMessage;
					
					switch (this.ackAction) {
						case 'single':
							request = {
								alertFingerprints: [this.currentAckAlert.fingerprint],
								groupNames: [],
								action: 'acknowledge',
								comment: this.ackReason
							};
							successMessage = 'Alert acknowledged successfully';
							break;
							
						case 'group':
							request = {
								alertFingerprints: [],
								groupNames: [this.currentGroupName],
								action: 'acknowledge',
								comment: this.ackReason
							};
							successMessage = `Group "${this.currentGroupName}" acknowledged successfully`;
							break;
							
						case 'bulk':
							request = {
								alertFingerprints: this.selectedAlerts || [],
								groupNames: this.selectedGroups || [],
								action: 'acknowledge',
								comment: this.ackReason
							};
							const totalCount = (this.selectedAlerts?.length || 0) + (this.selectedGroups?.length || 0);
							successMessage = `${totalCount} items acknowledged successfully`;
							break;
							
						default:
							this.ackError = 'Invalid acknowledgment action';
							this.ackSubmitting = false;
							return;
					}
					
					const response = await fetch('/api/v1/dashboard/bulk-action', {
						method: 'POST',
						credentials: 'include',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify(request)
					});

					const result = await response.json();
					
					if (result.success) {
						this.showNotification('success', successMessage);
						this.showAckModal = false;
						
						// Clear selection if bulk action (only if method exists)
						if (this.ackAction === 'bulk' && typeof this.clearSelection === 'function') {
							this.clearSelection();
						}
						
						// Refresh data - use appropriate method based on context
						if (typeof this.loadDashboardData === 'function') {
							this.loadDashboardData(); // Dashboard context
						} else if (typeof this.loadAlertDetails === 'function') {
							this.loadAlertDetails(); // Standalone page context
						}
					} else {
						this.ackError = result.error || 'Failed to acknowledge';
					}
				} catch (error) {
					console.error('Error submitting acknowledgment:', error);
					this.ackError = 'Network error: Failed to submit acknowledgment';
				} finally {
					this.ackSubmitting = false;
				}
			},

			// Silence Modal Functions
			cancelSilence() {
				this.showSilenceModal = false;
				this.silenceReason = '';
				this.silenceError = '';
				this.silenceSubmitting = false;
				this.currentSilenceAlert = null;
				this.currentGroupName = '';
				this.silenceDuration = '1h';
				this.silenceDurationType = 'preset';
				this.customSilenceDuration = '';
				this.customDurationError = '';
			},

			
			async submitSilence() {
				if (!this.silenceReason.trim()) {
					this.silenceError = 'Please provide a reason for the silence';
					return;
				}
				
				if (this.silenceDurationType === 'custom') {
					if (!this.validateCustomDuration()) {
						return;
					}
				}
				
				this.silenceSubmitting = true;
				this.silenceError = '';
				
				try {
					let request;
					let successMessage;
					
					const durationFields = {};
					if (this.silenceDurationType === 'custom') {
						durationFields.silenceDurationType = 'custom';
						durationFields.customSilenceDuration = this.customSilenceDuration.trim();
					} else {
						durationFields.silenceDuration = this.parseDurationToSeconds(this.silenceDuration) * 1000000000;
						durationFields.silenceDurationType = 'preset';
					}
					
					switch (this.silenceAction) {
						case 'single':
							request = {
								alertFingerprints: [this.currentSilenceAlert.fingerprint],
								groupNames: [],
								action: 'silence',
								comment: this.silenceReason,
								...durationFields
							};
							successMessage = 'Alert silenced successfully';
							break;
							
						case 'group':
							request = {
								alertFingerprints: [],
								groupNames: [this.currentGroupName],
								action: 'silence',
								comment: this.silenceReason,
								...durationFields
							};
							successMessage = `Group "${this.currentGroupName}" silenced successfully`;
							break;
							
						case 'bulk':
							request = {
								alertFingerprints: this.selectedAlerts || [],
								groupNames: this.selectedGroups || [],
								action: 'silence',
								comment: this.silenceReason,
								...durationFields
							};
							const totalCount = (this.selectedAlerts?.length || 0) + (this.selectedGroups?.length || 0);
							successMessage = `${totalCount} items silenced successfully`;
							break;
							
						default:
							this.silenceError = 'Invalid silence action';
							this.silenceSubmitting = false;
							return;
					}
					
					const response = await fetch('/api/v1/dashboard/bulk-action', {
						method: 'POST',
						credentials: 'include',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify(request)
					});

					const result = await response.json();
					
					if (result.success) {
						this.showNotification('success', successMessage);
						this.showSilenceModal = false;
						
						// Clear selection if bulk action (only if method exists)
						if (this.silenceAction === 'bulk' && typeof this.clearSelection === 'function') {
							this.clearSelection();
						}
						
						// Refresh data - use appropriate method based on context
						if (typeof this.loadDashboardData === 'function') {
							this.loadDashboardData(); // Dashboard context
						} else if (typeof this.loadAlertDetails === 'function') {
							this.loadAlertDetails(); // Standalone page context
						}
					} else {
						this.silenceError = result.error || 'Failed to silence';
					}
				} catch (error) {
					console.error('Error submitting silence:', error);
					this.silenceError = 'Network error: Failed to submit silence';
				} finally {
					this.silenceSubmitting = false;
				}
			},

			getSilenceButtonText(alert) {
				if (!alert) return 'Unsilence';
				if (alert.status?.state === 'suppressed' || alert.status?.state === 'silenced') {
					return 'Unsilence';
				}
				return 'Silence';
			},

			async copyAlertLink() {
				if (!this.alertDetails?.alert?.fingerprint) {
					this.showNotification('error', 'Alert information not available');
					return;
				}

				// Build the alert URL
				const baseUrl = window.location.origin;
				const alertUrl = `${baseUrl}/alert/${this.alertDetails.alert.fingerprint}`;

				// Copy to clipboard
				await this.copyToClipboard(alertUrl);
				this.showNotification('success', 'Alert link copied to clipboard');
			},

			async copyGeneratorURL() {
				if (!this.alertDetails?.alert?.generatorURL) {
					this.showNotification('error', 'Generator URL not available for this alert');
					return;
				}

				// Copy generator URL to clipboard
				await this.copyToClipboard(this.alertDetails.alert.generatorURL);
				this.showNotification('success', 'Generator URL copied to clipboard');
			},

			calculateDuration() {
				if (!this.alertDetails?.duration) {
					return 'N/A';
				}
				
				// Duration is in nanoseconds, convert to seconds
				const durationSeconds = Math.floor(this.alertDetails.duration / 1000000000);
				
				if (durationSeconds < 60) {
					return `${durationSeconds}s`;
				} else if (durationSeconds < 3600) {
					const minutes = Math.floor(durationSeconds / 60);
					const remainingSeconds = durationSeconds % 60;
					return `${minutes}m ${remainingSeconds}s`;
				} else if (durationSeconds < 86400) {
					const hours = Math.floor(durationSeconds / 3600);
					const remainingMinutes = Math.floor((durationSeconds % 3600) / 60);
					return `${hours}h ${remainingMinutes}m`;
				} else {
					const days = Math.floor(durationSeconds / 86400);
					const remainingHours = Math.floor((durationSeconds % 86400) / 3600);
					return `${days}d ${remainingHours}h`;
				}
			},

			async copyAlertAsIssue() {
				if (!this.alertDetails?.alert) {
					this.showNotification('error', 'Alert information not available');
					return;
				}

				const alert = this.alertDetails.alert;
				
				// Build an issue template with alert information
				let issueContent = `## Alert Details\n\n`;
				issueContent += `**Alert Name:** ${alert.alertName || 'Unknown'}\n`;
				issueContent += `**Severity:** ${alert.severity || 'Unknown'}\n`;
				issueContent += `**Status:** ${alert.status?.state || 'Unknown'}\n`;
				issueContent += `**Instance:** ${alert.instance || 'N/A'}\n`;
				
				if (alert.labels?.team) {
					issueContent += `**Team:** ${alert.labels.team}\n`;
				}
				
				if (alert.summary) {
					issueContent += `**Summary:** ${alert.summary}\n`;
				}
				
				if (alert.description) {
					issueContent += `**Description:** ${alert.description}\n`;
				}
				
				if (alert.generatorURL) {
					issueContent += `**Generator URL:** ${alert.generatorURL}\n`;
				}
				
				if (alert.startsAt) {
					const startDate = new Date(alert.startsAt).toLocaleString();
					issueContent += `**Started At:** ${startDate}\n`;
				}
				
				// Add labels section
				if (alert.labels && Object.keys(alert.labels).length > 0) {
					issueContent += `\n### Labels\n`;
					Object.entries(alert.labels).forEach(([key, value]) => {
						if (key !== 'team') { // Skip team as it's already shown above
							issueContent += `- **${key}:** ${value}\n`;
						}
					});
				}
				
				// Add annotations section
				if (alert.annotations && Object.keys(alert.annotations).length > 0) {
					issueContent += `\n### Annotations\n`;
					Object.entries(alert.annotations).forEach(([key, value]) => {
						if (key !== 'summary' && key !== 'description') { // Skip as they're already shown above
							issueContent += `- **${key}:** ${value}\n`;
						}
					});
				}
				
				// Add alert link
				const baseUrl = window.location.origin;
				const alertUrl = `${baseUrl}/alert/${alert.fingerprint}`;
				issueContent += `\n**Alert Link:** ${alertUrl}\n`;

				// Copy to clipboard
				await this.copyToClipboard(issueContent);
				this.showNotification('success', 'Alert issue template copied to clipboard');
			},

			async loadAlertDetails() {
				if (!this.alertId) {
					this.error = 'No alert ID provided';
					this.loading = false;
					return;
				}

				this.loading = true;
				this.error = null;

				try {
					const response = await fetch(`/api/v1/dashboard/alert/${this.alertId}`, {
						credentials: 'include'
					});
					const result = await response.json();
					
					if (result.success) {
						this.alertDetails = result.data;
						// Load related alerts if we're on the related tab and have the loadRelatedAlerts function
						if (this.currentTab === 'related' && typeof this.loadRelatedAlerts === 'function') {
							this.loadRelatedAlerts();
						}
					} else {
						this.error = result.error || 'Failed to load alert details';
					}
				} catch (error) {
					console.error('Error loading alert details:', error);
					this.error = 'Network error: Failed to load alert details';
				} finally {
					this.loading = false;
				}
			},

			// Related alerts functionality
			async loadRelatedAlerts() {
				if (!this.alertDetails?.alert) return;
				
				this.relatedLoading = true;
				
				try {
					// Fetch all alerts from the correct endpoint
					const response = await fetch('/api/v1/dashboard/incremental', {
						credentials: 'include'
					});
					
					const result = await response.json();
					
					if (result.success && result.data) {
						const allAlerts = result.data;
						const currentAlert = this.alertDetails.alert;
						
						// Debug: Log the structure of the first few alerts
						console.log('Sample alerts from API:', allAlerts.slice(0, 3));
						
						// Filter alerts based on selected criteria
						let filteredAlerts = allAlerts.filter(alert => {
							// Validate alert has required properties
							if (!alert || !alert.fingerprint || typeof alert.fingerprint !== 'string') {
								console.warn('Alert missing or invalid fingerprint:', alert);
								return false;
							}
							
							// Exclude current alert
							if (alert.fingerprint === currentAlert.fingerprint) return false;
							
							switch (this.relatedFilter) {
								case 'same_source':
									return alert.source === currentAlert.source;
								case 'same_severity':
									return alert.labels?.severity === currentAlert.labels?.severity || alert.severity === currentAlert.severity;
								case 'same_labels':
									// Match on alertname (most common relation)
									return alert.labels?.alertname === currentAlert.labels?.alertname;
								default: // 'all'
									// Match on alertname primarily, fallback to job or instance
									return (alert.labels?.alertname === currentAlert.labels?.alertname) ||
										   (alert.labels?.job === currentAlert.labels?.job) ||
										   (alert.labels?.instance === currentAlert.labels?.instance);
							}
						});
						
						// Apply search filter if provided
						if (this.relatedSearchQuery.trim()) {
							const searchLower = this.relatedSearchQuery.toLowerCase();
							filteredAlerts = filteredAlerts.filter(alert => {
								return (alert.labels?.alertname || '').toLowerCase().includes(searchLower) ||
									   (alert.labels?.instance || '').toLowerCase().includes(searchLower) ||
									   (alert.annotations?.summary || '').toLowerCase().includes(searchLower);
							});
						}
						
						// Sort by most recent first
						filteredAlerts.sort((a, b) => new Date(b.startsAt || 0) - new Date(a.startsAt || 0));
						
						// Deduplicate by fingerprint (keep first occurrence)
						const seenFingerprints = new Set();
						filteredAlerts = filteredAlerts.filter(alert => {
							if (seenFingerprints.has(alert.fingerprint)) {
								return false;
							}
							seenFingerprints.add(alert.fingerprint);
							return true;
						});
						
						// Store all filtered results
						this.relatedAllAlerts = filteredAlerts;
						this.relatedTotalResults = filteredAlerts.length;
						this.relatedTotalPages = Math.ceil(filteredAlerts.length / this.relatedPageSize);
						
						// Apply pagination
						this.updateRelatedAlertsPage();
					} else {
						this.relatedAlerts = [];
						this.relatedAllAlerts = [];
						this.relatedTotalResults = 0;
						this.relatedTotalPages = 0;
					}
				} catch (error) {
					console.error('Error loading related alerts:', error);
					this.relatedAlerts = [];
					this.relatedAllAlerts = [];
					this.relatedTotalResults = 0;
					this.relatedTotalPages = 0;
					this.showNotification('error', 'Failed to load related alerts');
				} finally {
					this.relatedLoading = false;
				}
			},

			// Pagination methods for related alerts
			updateRelatedAlertsPage() {
				const startIndex = (this.relatedCurrentPage - 1) * this.relatedPageSize;
				const endIndex = startIndex + this.relatedPageSize;
				this.relatedAlerts = this.relatedAllAlerts.slice(startIndex, endIndex);
			},

			goToRelatedPage(page) {
				if (page >= 1 && page <= this.relatedTotalPages) {
					this.relatedCurrentPage = page;
					this.updateRelatedAlertsPage();
				}
			},

			nextRelatedPage() {
				if (this.relatedCurrentPage < this.relatedTotalPages) {
					this.relatedCurrentPage++;
					this.updateRelatedAlertsPage();
				}
			},

			prevRelatedPage() {
				if (this.relatedCurrentPage > 1) {
					this.relatedCurrentPage--;
					this.updateRelatedAlertsPage();
				}
			},

			changeRelatedPageSize(newSize) {
				this.relatedPageSize = parseInt(newSize);
				this.relatedCurrentPage = 1; // Reset to first page
				this.relatedTotalPages = Math.ceil(this.relatedTotalResults / this.relatedPageSize);
				this.updateRelatedAlertsPage();
			},

			searchRelatedAlerts() {
				// Reset to first page when searching
				this.relatedCurrentPage = 1;
				// Reload with search filter applied
				this.loadRelatedAlerts();
			},

			getRelatedPageNumbers() {
				const pages = [];
				const current = this.relatedCurrentPage;
				const total = this.relatedTotalPages;
				
				// Show at most 5 page numbers
				let start = Math.max(1, current - 2);
				let end = Math.min(total, current + 2);
				
				// Adjust if we're near the beginning or end
				if (end - start < 4) {
					if (start === 1) {
						end = Math.min(total, start + 4);
					} else if (end === total) {
						start = Math.max(1, end - 4);
					}
				}
				
				for (let i = start; i <= end; i++) {
					pages.push(i);
				}
				
				return pages;
			},

			navigateToAlert(fingerprint) {
				// Validate fingerprint
				if (!fingerprint || typeof fingerprint !== 'string') {
					console.error('Invalid fingerprint for navigation:', fingerprint);
					this.showNotification('error', 'Invalid alert fingerprint');
					return;
				}
				
				// Debug: Log the fingerprint being used
				console.log('Navigating to alert with fingerprint:', fingerprint);
				
				// Navigate to another alert, preserving query parameters
				const currentQuery = window.location.search;
				window.location.href = `/alert/${fingerprint}${currentQuery}`;
			},


			// Common unsilence action (for direct unsilence without modal)
			async processUnsilenceAction(fingerprint) {
				try {
					const response = await fetch('/api/v1/dashboard/bulk-action', {
						method: 'POST',
						credentials: 'include',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify({
							action: 'unsilence',
							fingerprints: [fingerprint],
							comment: 'Unsilenced from alert details'
						})
					});

					const result = await response.json();
					
					if (result.success) {
						this.showNotification('success', 'Alert unsilenced successfully');
						
						// Refresh data based on context
						if (typeof this.loadDashboardData === 'function') {
							this.loadDashboardData();
						} else if (typeof this.loadAlertDetails === 'function') {
							this.loadAlertDetails();
						}
					} else {
						this.showNotification('error', 'Failed to unsilence alert: ' + result.error);
					}
				} catch (error) {
					console.error('Error unsilencing alert:', error);
					this.showNotification('error', 'Failed to unsilence alert');
				}
			},

			// Common unacknowledge action
			async processUnacknowledgeAction(fingerprint) {
				try {
					const request = {
						alertFingerprints: [fingerprint],
						action: 'unacknowledge',
						comment: 'Unacknowledged from alert details'
					};
					
					const response = await fetch('/api/v1/dashboard/bulk-action', {
						method: 'POST',
						credentials: 'include',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify(request)
					});
					
					const result = await response.json();
					
					if (result.success) {
						this.showNotification('success', 'Alert unacknowledged successfully');
						
						// Refresh data based on context
						if (typeof this.loadDashboardData === 'function') {
							this.loadDashboardData();
						} else if (typeof this.loadAlertDetails === 'function') {
							this.loadAlertDetails();
						}
					} else {
						this.showNotification('error', 'Failed to unacknowledge alert: ' + result.error);
					}
				} catch (error) {
					console.error('Error unacknowledging alert:', error);
					this.showNotification('error', 'Failed to unacknowledge alert');
				}
			},

			// Duration parsing functions (copied from dashboard_actions.templ)
			parseDurationToSeconds(duration) {
				if (!duration) return 0;
				
				if (duration.match(/^\d+[hd]$/)) {
					const value = parseInt(duration.slice(0, -1));
					const unit = duration.slice(-1);
					
					switch (unit) {
						case 'h':
							return value * 3600;
						case 'd':
							return value * 86400;
						default:
							return value * 3600;
					}
				}
				
				return this.parseComplexDurationToSeconds(duration);
			},
			
			parseComplexDurationToSeconds(duration) {
				if (!duration) return 0;
				
				let totalSeconds = 0;
				const units = {
					'ns': 0.000000001,
					'µs': 0.000001,
					'us': 0.000001,
					'ms': 0.001,
					's': 1,
					'm': 60,
					'h': 3600
				};
				
				const regex = /(\d+(?:\.\d+)?)(ns|µs|us|ms|s|m|h)/g;
				let match;
				
				while ((match = regex.exec(duration)) !== null) {
					const value = parseFloat(match[1]);
					const unit = match[2];
					
					if (units[unit]) {
						totalSeconds += value * units[unit];
					}
				}
				
				return Math.round(totalSeconds);
			},
			
			validateCustomDuration() {
				if (this.silenceDurationType !== 'custom' || !this.customSilenceDuration) {
					this.customDurationError = '';
					return true;
				}
				
				const duration = this.customSilenceDuration.trim();
				
				if (!duration) {
					this.customDurationError = 'Duration cannot be empty';
					return false;
				}
				
				const validFormat = /^(\d+(?:\.\d+)?)(ns|µs|us|ms|s|m|h)(\d+(?:\.\d+)?(ns|µs|us|ms|s|m|h))*$/;
				if (!validFormat.test(duration)) {
					this.customDurationError = 'Invalid format. Use combinations like 1h30m, 2h15m30s';
					return false;
				}
				
				const totalSeconds = this.parseComplexDurationToSeconds(duration);
				
				if (totalSeconds <= 0) {
					this.customDurationError = 'Duration must be positive';
					return false;
				}
				
				if (totalSeconds < 1) {
					this.customDurationError = 'Duration must be at least 1 second';
					return false;
				}
				
				const maxSeconds = 30 * 24 * 3600;
				if (totalSeconds > maxSeconds) {
					this.customDurationError = 'Duration cannot exceed 30 days';
					return false;
				}
				
				this.customDurationError = '';
				return true;
			}
		};
	</script>
}