// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func DashboardModal() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\twindow.dashboardModalMixin = {\n\t\t\tasync showAlertDetails(fingerprint) {\n\t\t\t\tthis.alertDetailsLoading = true;\n\t\t\t\tthis.showAlertModal = true;\n\t\t\t\tthis.currentAlertTab = 'overview';\n\t\t\t\tthis.alertDetails = null;\n\n\t\t\t\tconst currentPath = window.location.pathname;\n\t\t\t\tconst newPath = `/dashboard/alert/${fingerprint}`;\n\t\t\t\tif (currentPath !== newPath) {\n\t\t\t\t\twindow.history.pushState({ alertId: fingerprint }, '', newPath);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${fingerprint}`, {\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.alertDetails = result.data;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to load alert details: ' + result.error);\n\t\t\t\t\t\tthis.closeAlertModal();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error loading alert details:', error);\n\t\t\t\t\tthis.showNotification('error', 'Failed to load alert details');\n\t\t\t\t\tthis.closeAlertModal();\n\t\t\t\t} finally {\n\t\t\t\t\tthis.alertDetailsLoading = false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcloseAlertModal() {\n\t\t\t\tthis.showAlertModal = false;\n\t\t\t\tthis.alertDetails = null;\n\t\t\t\tthis.currentAlertTab = 'overview';\n\t\t\t\t\n\t\t\t\tthis.newCommentContent = '';\n\t\t\t\tthis.commentSubmitting = false;\n\t\t\t\tthis.commentDeleting = {};\n\t\t\t\t\n\t\t\t\tif (window.location.pathname.includes('/alert/')) {\n\t\t\t\t\twindow.history.pushState({}, '', '/dashboard');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tacknowledgeCurrentAlert() {\n\t\t\t\tif (this.alertDetails?.alert) {\n\t\t\t\t\tthis.currentAckAlert = this.alertDetails.alert;\n\t\t\t\t\tthis.ackAction = 'single';\n\t\t\t\t\tthis.ackReason = '';\n\t\t\t\t\tthis.ackError = '';\n\t\t\t\t\tthis.showAckModal = true;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsilenceCurrentAlert() {\n\t\t\t\tif (this.alertDetails?.alert) {\n\t\t\t\t\tthis.currentSilenceAlert = this.alertDetails.alert;\n\t\t\t\t\tthis.silenceAction = 'single';\n\t\t\t\t\tthis.silenceReason = '';\n\t\t\t\t\tthis.silenceError = '';\n\t\t\t\t\tthis.silenceDuration = '1h';\n\t\t\t\t\tthis.silenceDurationType = 'preset';\n\t\t\t\t\tthis.customSilenceDuration = '';\n\t\t\t\t\tthis.customDurationError = '';\n\t\t\t\t\tthis.showSilenceModal = true;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tunsilenceCurrentAlert() {\n\t\t\t\tif (this.alertDetails?.alert) {\n\t\t\t\t\tthis.processUnsilenceAction(this.alertDetails.alert.fingerprint);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync processUnsilenceAction(fingerprint) {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\taction: 'unsilence',\n\t\t\t\t\t\t\tfingerprints: [fingerprint],\n\t\t\t\t\t\t\tcomment: 'Unsilenced from alert details'\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.showNotification('success', 'Alert unsilenced successfully');\n\t\t\t\t\t\t// Refresh alert details to show updated state\n\t\t\t\t\t\tif (this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\t\t\tawait this.showAlertDetails(this.alertDetails.alert.fingerprint);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to unsilence alert: ' + (result.error || 'Unknown error'));\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error unsilencing alert:', error);\n\t\t\t\t\tthis.showNotification('error', 'Failed to unsilence alert');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tisAlertSilenced(alert) {\n\t\t\t\tif (!alert) return false;\n\t\t\t\treturn alert.status?.state === 'suppressed' || \n\t\t\t\t\t   alert.status?.state === 'silenced' || \n\t\t\t\t\t   (alert.status?.silencedBy && alert.status.silencedBy.length > 0);\n\t\t\t},\n\n\t\t\tgetSilenceButtonText(alert) {\n\t\t\t\tif (!alert) return 'Unsilence';\n\t\t\t\tconst silenceCount = alert.status?.silencedBy?.length || 0;\n\t\t\t\treturn silenceCount > 1 ? `Unsilence (${silenceCount})` : 'Unsilence';\n\t\t\t},\n\n\t\t\t// Comment Management Functions\n\t\t\tasync addComment() {\n\t\t\t\tif (!this.newCommentContent.trim()) {\n\t\t\t\t\tthis.showNotification('warning', 'Please enter a comment');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\tthis.showNotification('error', 'Alert information not available');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.commentSubmitting = true;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${this.alertDetails.alert.fingerprint}/comments`, {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\tcontent: this.newCommentContent.trim()\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.showNotification('success', 'Comment added successfully');\n\t\t\t\t\t\tthis.newCommentContent = '';\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Refresh alert details to show the new comment\n\t\t\t\t\t\tawait this.refreshComments();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to add comment: ' + result.error);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error adding comment:', error);\n\t\t\t\t\tthis.showNotification('error', 'Failed to add comment');\n\t\t\t\t} finally {\n\t\t\t\t\tthis.commentSubmitting = false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync deleteComment(commentId) {\n\t\t\t\tif (!commentId || !this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\tthis.showNotification('error', 'Comment information not available');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.commentDeleting[commentId] = true;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${this.alertDetails.alert.fingerprint}/comments/${commentId}`, {\n\t\t\t\t\t\tmethod: 'DELETE',\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.showNotification('success', 'Comment deleted successfully');\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Refresh alert details to remove the deleted comment\n\t\t\t\t\t\tawait this.refreshComments();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to delete comment: ' + result.error);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error deleting comment:', error);\n\t\t\t\t\tthis.showNotification('error', 'Failed to delete comment');\n\t\t\t\t} finally {\n\t\t\t\t\t// Remove deleting state for this comment\n\t\t\t\t\tdelete this.commentDeleting[commentId];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync refreshComments() {\n\t\t\t\tif (!this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${this.alertDetails.alert.fingerprint}`, {\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t// Update only the comments and maintain other alert details\n\t\t\t\t\t\tthis.alertDetails.comments = result.data.comments || [];\n\t\t\t\t\t\t// Update comment count in alert object if it exists\n\t\t\t\t\t\tif (this.alertDetails.alert) {\n\t\t\t\t\t\t\tthis.alertDetails.alert.commentCount = this.alertDetails.comments.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error refreshing comments:', error);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcopyAlertAsIssue() {\n\t\t\t\tif (!this.alertDetails?.alert) {\n\t\t\t\t\tthis.showNotification('error', 'No alert data available');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst alert = this.alertDetails.alert;\n\t\t\t\tconst comments = this.alertDetails.comments || [];\n\t\t\t\t\n\t\t\t\tconst formatDate = (dateStr) => {\n\t\t\t\t\tif (!dateStr) return 'N/A';\n\t\t\t\t\treturn new Date(dateStr).toLocaleString();\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tconst calculateDuration = (start, end) => {\n\t\t\t\t\tif (!start) return 'N/A';\n\t\t\t\t\tconst startTime = new Date(start);\n\t\t\t\t\tconst endTime = end ? new Date(end) : new Date();\n\t\t\t\t\tconst diffMs = endTime - startTime;\n\t\t\t\t\t\n\t\t\t\t\tconst hours = Math.floor(diffMs / (1000 * 60 * 60));\n\t\t\t\t\tconst minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));\n\t\t\t\t\t\n\t\t\t\t\tif (hours > 0) {\n\t\t\t\t\t\treturn `${hours}h ${minutes}m`;\n\t\t\t\t\t}\n\t\t\t\t\treturn `${minutes}m`;\n\t\t\t\t};\n\n\t\t\t\t// Build markdown content\n\t\t\t\tlet markdown = `# Alert: ${alert.alertname || alert.labels?.alertname || 'Unknown'}\\n\\n`;\n\t\t\t\t\n\t\t\t\t// Summary section\n\t\t\t\tif (alert.summary) {\n\t\t\t\t\tmarkdown += `## Summary\\n${alert.summary}\\n\\n`;\n\t\t\t\t}\n\n\t\t\t\t// Details section\n\t\t\t\tmarkdown += `## Details\\n`;\n\t\t\t\tmarkdown += `- **Status**: ${(alert.status?.state || 'unknown').toUpperCase()}\\n`;\n\t\t\t\tmarkdown += `- **Severity**: ${(alert.severity || 'unknown').toUpperCase()}\\n`;\n\t\t\t\tif (alert.instance) {\n\t\t\t\t\tmarkdown += `- **Instance**: ${alert.instance}\\n`;\n\t\t\t\t}\n\t\t\t\tmarkdown += `- **Started**: ${formatDate(alert.startsAt)}\\n`;\n\t\t\t\tif (alert.endsAt) {\n\t\t\t\t\tmarkdown += `- **Ended**: ${formatDate(alert.endsAt)}\\n`;\n\t\t\t\t}\n\t\t\t\tmarkdown += `- **Duration**: ${calculateDuration(alert.startsAt, alert.endsAt)}\\n\\n`;\n\n\t\t\t\t// Labels section\n\t\t\t\tif (alert.labels && Object.keys(alert.labels).length > 0) {\n\t\t\t\t\tmarkdown += `## Labels\\n`;\n\t\t\t\t\tObject.entries(alert.labels).forEach(([key, value]) => {\n\t\t\t\t\t\tmarkdown += `- **${key}**: ${value}\\n`;\n\t\t\t\t\t});\n\t\t\t\t\tmarkdown += '\\n';\n\t\t\t\t}\n\n\t\t\t\t// Annotations section\n\t\t\t\tif (alert.annotations && Object.keys(alert.annotations).length > 0) {\n\t\t\t\t\tmarkdown += `## Annotations\\n`;\n\t\t\t\t\tObject.entries(alert.annotations).forEach(([key, value]) => {\n\t\t\t\t\t\tmarkdown += `- **${key}**: ${value}\\n`;\n\t\t\t\t\t});\n\t\t\t\t\tmarkdown += '\\n';\n\t\t\t\t}\n\n\t\t\t\t// Comments section\n\t\t\t\tif (comments.length > 0) {\n\t\t\t\t\tmarkdown += `## Comments\\n`;\n\t\t\t\t\tcomments.forEach(comment => {\n\t\t\t\t\t\tconst commentDate = formatDate(comment.createdAt);\n\t\t\t\t\t\tmarkdown += `**${comment.username}** (${commentDate}):\\n`;\n\t\t\t\t\t\tmarkdown += `${comment.content}\\n\\n`;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Alert ID section\n\t\t\t\tmarkdown += `## Alert ID\\n`;\n\t\t\t\tmarkdown += `\\`${alert.fingerprint}\\`\\n`;\n\n\t\t\t\t// Copy to clipboard\n\t\t\t\tthis.copyToClipboard(markdown);\n\t\t\t\tthis.showNotification('success', 'Alert copied as issue template');\n\t\t\t},\n\n\t\t\tasync unacknowledgeCurrentAlert() {\n\t\t\t\tif (!this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\tthis.showNotification('error', 'No alert information available');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tconst request = {\n\t\t\t\t\t\talertFingerprints: [this.alertDetails.alert.fingerprint],\n\t\t\t\t\t\taction: 'unacknowledge',\n\t\t\t\t\t\tcomment: 'Unacknowledged from alert details'\n\t\t\t\t\t};\n\n\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t\t});\n\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.showNotification('success', 'Alert unacknowledged successfully');\n\t\t\t\t\t\t// Refresh alert details to show updated state\n\t\t\t\t\t\tif (this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\t\t\tawait this.showAlertDetails(this.alertDetails.alert.fingerprint);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to unacknowledge alert: ' + (result.error || 'Unknown error'));\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error unacknowledging alert:', error);\n\t\t\t\t\tthis.showNotification('error', 'Failed to unacknowledge alert');\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
