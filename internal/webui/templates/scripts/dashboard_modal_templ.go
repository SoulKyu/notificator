// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func DashboardModal() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\twindow.dashboardModalMixin = {\n\t\t\tasync showAlertDetails(fingerprint) {\n\t\t\t\tthis.alertDetailsLoading = true;\n\t\t\t\tthis.showAlertModal = true;\n\t\t\t\tthis.currentAlertTab = 'overview';\n\t\t\t\tthis.alertDetails = null;\n\n\t\t\t\tconst currentPath = window.location.pathname;\n\t\t\t\tconst newPath = `/dashboard/alert/${fingerprint}`;\n\t\t\t\tif (currentPath !== newPath) {\n\t\t\t\t\twindow.history.pushState({ alertId: fingerprint }, '', newPath);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${fingerprint}`, {\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.alertDetails = result.data;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('Failed to load alert details: ' + result.error);\n\t\t\t\t\t\tthis.closeAlertModal();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error loading alert details:', error);\n\t\t\t\t\tconsole.error('Failed to load alert details');\n\t\t\t\t\tthis.closeAlertModal();\n\t\t\t\t} finally {\n\t\t\t\t\tthis.alertDetailsLoading = false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcloseAlertModal() {\n\t\t\t\tthis.showAlertModal = false;\n\t\t\t\tthis.alertDetails = null;\n\t\t\t\tthis.currentAlertTab = 'overview';\n\t\t\t\t\n\t\t\t\tthis.newCommentContent = '';\n\t\t\t\tthis.commentSubmitting = false;\n\t\t\t\tthis.commentDeleting = {};\n\t\t\t\t\n\t\t\t\tif (window.location.pathname.includes('/alert/')) {\n\t\t\t\t\twindow.history.pushState({}, '', '/dashboard');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tacknowledgeCurrentAlert() {\n\t\t\t\tif (this.alertDetails?.alert) {\n\t\t\t\t\tthis.currentAckAlert = this.alertDetails.alert;\n\t\t\t\t\tthis.ackAction = 'single';\n\t\t\t\t\tthis.ackReason = '';\n\t\t\t\t\tthis.ackError = '';\n\t\t\t\t\tthis.showAckModal = true;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsilenceCurrentAlert() {\n\t\t\t\tif (this.alertDetails?.alert) {\n\t\t\t\t\tthis.currentSilenceAlert = this.alertDetails.alert;\n\t\t\t\t\tthis.silenceAction = 'single';\n\t\t\t\t\tthis.silenceReason = '';\n\t\t\t\t\tthis.silenceError = '';\n\t\t\t\t\tthis.silenceDuration = '1h';\n\t\t\t\t\tthis.silenceDurationType = 'preset';\n\t\t\t\t\tthis.customSilenceDuration = '';\n\t\t\t\t\tthis.customDurationError = '';\n\t\t\t\t\tthis.showSilenceModal = true;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tunsilenceCurrentAlert() {\n\t\t\t\tif (this.alertDetails?.alert) {\n\t\t\t\t\tthis.processUnsilenceAction(this.alertDetails.alert.fingerprint);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync processUnsilenceAction(fingerprint) {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\taction: 'unsilence',\n\t\t\t\t\t\t\tfingerprints: [fingerprint],\n\t\t\t\t\t\t\tcomment: 'Unsilenced from alert details'\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tconsole.log('Alert unsilenced successfully');\n\t\t\t\t\t\t// Refresh alert details to show updated state\n\t\t\t\t\t\tif (this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\t\t\tawait this.showAlertDetails(this.alertDetails.alert.fingerprint);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('Failed to unsilence alert: ' + (result.error || 'Unknown error'));\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error unsilencing alert:', error);\n\t\t\t\t\tconsole.error('Failed to unsilence alert');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tisAlertSilenced(alert) {\n\t\t\t\tif (!alert) return false;\n\t\t\t\treturn alert.status?.state === 'suppressed' || \n\t\t\t\t\t   alert.status?.state === 'silenced' || \n\t\t\t\t\t   (alert.status?.silencedBy && alert.status.silencedBy.length > 0);\n\t\t\t},\n\n\t\t\tgetSilenceButtonText(alert) {\n\t\t\t\tif (!alert) return 'Unsilence';\n\t\t\t\tconst silenceCount = alert.status?.silencedBy?.length || 0;\n\t\t\t\treturn silenceCount > 1 ? `Unsilence (${silenceCount})` : 'Unsilence';\n\t\t\t},\n\n\t\t\t// Comment Management Functions\n\t\t\tasync addComment() {\n\t\t\t\tif (!this.newCommentContent.trim()) {\n\t\t\t\t\tconsole.log('Please enter a comment');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\tconsole.error('Alert information not available');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.commentSubmitting = true;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${this.alertDetails.alert.fingerprint}/comments`, {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\tcontent: this.newCommentContent.trim()\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tconsole.log('Comment added successfully');\n\t\t\t\t\t\tthis.newCommentContent = '';\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Refresh alert details to show the new comment\n\t\t\t\t\t\tawait this.refreshComments();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('Failed to add comment: ' + result.error);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error adding comment:', error);\n\t\t\t\t\tconsole.error('Failed to add comment');\n\t\t\t\t} finally {\n\t\t\t\t\tthis.commentSubmitting = false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync deleteComment(commentId) {\n\t\t\t\tif (!commentId || !this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\tconsole.error('Comment information not available');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.commentDeleting[commentId] = true;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${this.alertDetails.alert.fingerprint}/comments/${commentId}`, {\n\t\t\t\t\t\tmethod: 'DELETE',\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tconsole.log('Comment deleted successfully');\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Refresh alert details to remove the deleted comment\n\t\t\t\t\t\tawait this.refreshComments();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('Failed to delete comment: ' + result.error);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error deleting comment:', error);\n\t\t\t\t\tconsole.error('Failed to delete comment');\n\t\t\t\t} finally {\n\t\t\t\t\t// Remove deleting state for this comment\n\t\t\t\t\tdelete this.commentDeleting[commentId];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync refreshComments() {\n\t\t\t\tif (!this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert/${this.alertDetails.alert.fingerprint}`, {\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\t// Update only the comments and maintain other alert details\n\t\t\t\t\t\tthis.alertDetails.comments = result.data.comments || [];\n\t\t\t\t\t\t// Update comment count in alert object if it exists\n\t\t\t\t\t\tif (this.alertDetails.alert) {\n\t\t\t\t\t\t\tthis.alertDetails.alert.commentCount = this.alertDetails.comments.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error refreshing comments:', error);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcopyAlertAsIssue() {\n\t\t\t\tif (!this.alertDetails?.alert) {\n\t\t\t\t\tconsole.error('No alert data available');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst alert = this.alertDetails.alert;\n\t\t\t\tconst comments = this.alertDetails.comments || [];\n\t\t\t\t\n\t\t\t\tconst formatDate = (dateStr) => {\n\t\t\t\t\tif (!dateStr) return 'N/A';\n\t\t\t\t\treturn new Date(dateStr).toLocaleString();\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tconst calculateDuration = (start, end) => {\n\t\t\t\t\tif (!start) return 'N/A';\n\t\t\t\t\tconst startTime = new Date(start);\n\t\t\t\t\tconst endTime = end ? new Date(end) : new Date();\n\t\t\t\t\tconst diffMs = endTime - startTime;\n\t\t\t\t\t\n\t\t\t\t\tconst hours = Math.floor(diffMs / (1000 * 60 * 60));\n\t\t\t\t\tconst minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));\n\t\t\t\t\t\n\t\t\t\t\tif (hours > 0) {\n\t\t\t\t\t\treturn `${hours}h ${minutes}m`;\n\t\t\t\t\t}\n\t\t\t\t\treturn `${minutes}m`;\n\t\t\t\t};\n\n\t\t\t\t// Build markdown content\n\t\t\t\tlet markdown = `# Alert: ${alert.alertname || alert.labels?.alertname || 'Unknown'}\\n\\n`;\n\t\t\t\t\n\t\t\t\t// Summary section\n\t\t\t\tif (alert.summary) {\n\t\t\t\t\tmarkdown += `## Summary\\n${alert.summary}\\n\\n`;\n\t\t\t\t}\n\n\t\t\t\t// Details section\n\t\t\t\tmarkdown += `## Details\\n`;\n\t\t\t\tmarkdown += `- **Status**: ${(alert.status?.state || 'unknown').toUpperCase()}\\n`;\n\t\t\t\tmarkdown += `- **Severity**: ${(alert.severity || 'unknown').toUpperCase()}\\n`;\n\t\t\t\tif (alert.instance) {\n\t\t\t\t\tmarkdown += `- **Instance**: ${alert.instance}\\n`;\n\t\t\t\t}\n\t\t\t\tmarkdown += `- **Started**: ${formatDate(alert.startsAt)}\\n`;\n\t\t\t\tif (alert.endsAt) {\n\t\t\t\t\tmarkdown += `- **Ended**: ${formatDate(alert.endsAt)}\\n`;\n\t\t\t\t}\n\t\t\t\tmarkdown += `- **Duration**: ${calculateDuration(alert.startsAt, alert.endsAt)}\\n\\n`;\n\n\t\t\t\t// Labels section\n\t\t\t\tif (alert.labels && Object.keys(alert.labels).length > 0) {\n\t\t\t\t\tmarkdown += `## Labels\\n`;\n\t\t\t\t\tObject.entries(alert.labels).forEach(([key, value]) => {\n\t\t\t\t\t\tmarkdown += `- **${key}**: ${value}\\n`;\n\t\t\t\t\t});\n\t\t\t\t\tmarkdown += '\\n';\n\t\t\t\t}\n\n\t\t\t\t// Annotations section\n\t\t\t\tif (alert.annotations && Object.keys(alert.annotations).length > 0) {\n\t\t\t\t\tmarkdown += `## Annotations\\n`;\n\t\t\t\t\tObject.entries(alert.annotations).forEach(([key, value]) => {\n\t\t\t\t\t\tmarkdown += `- **${key}**: ${value}\\n`;\n\t\t\t\t\t});\n\t\t\t\t\tmarkdown += '\\n';\n\t\t\t\t}\n\n\t\t\t\t// Comments section\n\t\t\t\tif (comments.length > 0) {\n\t\t\t\t\tmarkdown += `## Comments\\n`;\n\t\t\t\t\tcomments.forEach(comment => {\n\t\t\t\t\t\tconst commentDate = formatDate(comment.createdAt);\n\t\t\t\t\t\tmarkdown += `**${comment.username}** (${commentDate}):\\n`;\n\t\t\t\t\t\tmarkdown += `${comment.content}\\n\\n`;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Alert ID section\n\t\t\t\tmarkdown += `## Alert ID\\n`;\n\t\t\t\tmarkdown += `\\`${alert.fingerprint}\\`\\n`;\n\n\t\t\t\t// Copy to clipboard\n\t\t\t\tthis.copyToClipboard(markdown);\n\t\t\t\tconsole.log('Alert copied as issue template');\n\t\t\t},\n\n\t\t\tasync unacknowledgeCurrentAlert() {\n\t\t\t\tif (!this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\tconsole.error('No alert information available');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tconst request = {\n\t\t\t\t\t\talertFingerprints: [this.alertDetails.alert.fingerprint],\n\t\t\t\t\t\taction: 'unacknowledge',\n\t\t\t\t\t\tcomment: 'Unacknowledged from alert details'\n\t\t\t\t\t};\n\n\t\t\t\t\tconst response = await fetch('/api/v1/dashboard/bulk-action', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tcredentials: 'include',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t\t});\n\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tconsole.log('Alert unacknowledged successfully');\n\t\t\t\t\t\t// Refresh alert details to show updated state\n\t\t\t\t\t\tif (this.alertDetails?.alert?.fingerprint) {\n\t\t\t\t\t\t\tawait this.showAlertDetails(this.alertDetails.alert.fingerprint);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('Failed to unacknowledge alert: ' + (result.error || 'Unknown error'));\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error unacknowledging alert:', error);\n\t\t\t\t\tconsole.error('Failed to unacknowledge alert');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Sentry Integration Functions  \n\t\t\tasync loadSentryDataForTab() {\n\t\t\t\t// This function is called from the tab button click\n\t\t\t\t// Find the Sentry data component using document.querySelector since $refs doesn't work across components\n\t\t\t\tconst sentryComponent = document.querySelector('[x-ref=\"sentryDataComponent\"]');\n\t\t\t\t\n\t\t\t\tif (sentryComponent && sentryComponent._x_dataStack && sentryComponent._x_dataStack[0]) {\n\t\t\t\t\t// Get the Alpine component data\n\t\t\t\t\tconst componentData = sentryComponent._x_dataStack[0];\n\t\t\t\t\t// Set loading state\n\t\t\t\t\tcomponentData.sentryLoading = true;\n\t\t\t\t\tcomponentData.sentryError = null;\n\t\t\t\t\t\n\t\t\t\t\tawait this.loadSentryData(componentData);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('Could not find Sentry data component. Element found:', !!sentryComponent, \n\t\t\t\t\t\t'Has _x_dataStack:', !!(sentryComponent && sentryComponent._x_dataStack));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync loadSentryData(component) {\n\t\t\t\ttry {\n\t\t\t\t\t// Get current alert from the component that has alert details\n\t\t\t\t\tlet alert = null;\n\t\t\t\t\tlet fingerprint = null;\n\t\t\t\t\t\n\t\t\t\t\t// Try to get alert from the component's alert details\n\t\t\t\t\tif (component && component.alertDetails?.alert) {\n\t\t\t\t\t\talert = component.alertDetails.alert;\n\t\t\t\t\t\tfingerprint = alert.fingerprint;\n\t\t\t\t\t} \n\t\t\t\t\t// Fallback to current alert from dashboard instance\n\t\t\t\t\telse if (window.dashboardInstance && window.dashboardInstance.currentAlert) {\n\t\t\t\t\t\talert = window.dashboardInstance.currentAlert;\n\t\t\t\t\t\tfingerprint = alert.fingerprint;\n\t\t\t\t\t}\n\t\t\t\t\t// Last resort: use alertDetails from parent modal component\n\t\t\t\t\telse if (this.alertDetails?.alert) {\n\t\t\t\t\t\talert = this.alertDetails.alert;\n\t\t\t\t\t\tfingerprint = alert.fingerprint;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!alert || !fingerprint) {\n\t\t\t\t\t\tconsole.error('No current alert available for Sentry data');\n\t\t\t\t\t\tif (component) {\n\t\t\t\t\t\t\tcomponent.sentryError = 'No alert data available';\n\t\t\t\t\t\t\tcomponent.sentryLoading = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.log('Loading Sentry data for alert fingerprint:', fingerprint);\n\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/sentry/${encodeURIComponent(fingerprint)}`, {\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\n\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (result.has_sentry_label) {\n\t\t\t\t\t\t\tif (result.auth_status?.has_api_token) {\n\t\t\t\t\t\t\t\t// User has token and can view data\n\t\t\t\t\t\t\t\tif (component) {\n\t\t\t\t\t\t\t\t\tcomponent.sentryData = result;\n\t\t\t\t\t\t\t\t\tcomponent.sentryError = null;\n\t\t\t\t\t\t\t\t\tcomponent.hasSentryToken = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// User needs to configure token\n\t\t\t\t\t\t\t\tif (component) {\n\t\t\t\t\t\t\t\t\tcomponent.sentryData = null;\n\t\t\t\t\t\t\t\t\tcomponent.sentryError = 'Sentry token not configured';\n\t\t\t\t\t\t\t\t\tcomponent.hasSentryToken = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Alert doesn't have sentry label\n\t\t\t\t\t\t\tif (component) {\n\t\t\t\t\t\t\t\tcomponent.sentryData = null;\n\t\t\t\t\t\t\t\tcomponent.sentryError = 'This alert does not have Sentry integration data';\n\t\t\t\t\t\t\t\tcomponent.hasSentryToken = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('Failed to load Sentry data:', response.status);\n\t\t\t\t\t\tif (component) {\n\t\t\t\t\t\t\tcomponent.sentryError = 'Failed to load Sentry data';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error loading Sentry data:', error);\n\t\t\t\t\tif (component) {\n\t\t\t\t\t\tcomponent.sentryError = 'Error loading Sentry data: ' + error.message;\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (component) {\n\t\t\t\t\t\tcomponent.sentryLoading = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Helper methods for annotation buttons\n\t\t\thasMatchingAnnotation(buttonConfig) {\n\t\t\t\tif (!buttonConfig || !buttonConfig.enabled) return false;\n\t\t\t\tconst annotations = this.alertDetails?.alert?.annotations || {};\n\t\t\t\treturn buttonConfig.annotation_keys?.some(key => annotations[key]);\n\t\t\t},\n\n\t\t\tgetAnnotationUrl(buttonConfig) {\n\t\t\t\tconst annotations = this.alertDetails?.alert?.annotations || {};\n\t\t\t\tconst matchedKey = buttonConfig.annotation_keys?.find(key => annotations[key]);\n\t\t\t\treturn matchedKey ? annotations[matchedKey] : null;\n\t\t\t},\n\n\t\t\topenAnnotationUrl(buttonConfig) {\n\t\t\t\tconst url = this.getAnnotationUrl(buttonConfig);\n\t\t\t\tif (url) {\n\t\t\t\t\twindow.open(url, '_blank');\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Global function for Sentry data loading that can be called from Alpine.js components\n\t\twindow.loadSentryData = function() {\n\t\t\t// Get the parent dashboard component that has the modal mixin\n\t\t\tconst dashboardComponent = window.dashboardInstance;\n\t\t\tif (dashboardComponent && dashboardComponent.loadSentryData) {\n\t\t\t\t// Pass the current Alpine.js component (this) to the function\n\t\t\t\tdashboardComponent.loadSentryData(this);\n\t\t\t} else {\n\t\t\t\tconsole.error('Dashboard instance not found or loadSentryData method not available');\n\t\t\t\tthis.sentryError = 'Dashboard not properly initialized';\n\t\t\t\tthis.sentryLoading = false;\n\t\t\t}\n\t\t};\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
