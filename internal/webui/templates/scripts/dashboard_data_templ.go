// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package scripts

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func DashboardData() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\t// Data loading and API functions for dashboard\n\t\twindow.dashboardDataMixin = {\n\t\t\t// Data loading - initial load with full data\n\t\t\tasync loadDashboardData() {\n\t\t\t\tthis.loading = true;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tconst params = new URLSearchParams();\n\t\t\t\t\t\n\t\t\t\t\t// Add current filters to request\n\t\t\t\t\tif (this.searchQuery) params.set('search', this.searchQuery);\n\t\t\t\t\tif (this.filters.alertmanagers.length > 0) params.set('alertmanagers', this.filters.alertmanagers.join(','));\n\t\t\t\t\tif (this.filters.severities.length > 0) params.set('severities', this.filters.severities.join(','));\n\t\t\t\t\tif (this.filters.statuses.length > 0) params.set('statuses', this.filters.statuses.join(','));\n\t\t\t\t\tif (this.filters.teams.length > 0) params.set('teams', this.filters.teams.join(','));\n\t\t\t\t\t\n\t\t\t\t\tparams.set('displayMode', this.displayMode);\n\t\t\t\t\tparams.set('viewMode', this.viewMode);\n\t\t\t\t\tparams.set('sortField', this.sortField);\n\t\t\t\t\tparams.set('sortDirection', this.sortDirection);\n\t\t\t\t\t\n\t\t\t\t\tif (this.acknowledgmentFilter) params.set('acknowledged', this.acknowledgmentFilter);\n\t\t\t\t\tif (this.commentsFilter) params.set('hasComments', this.commentsFilter);\n\t\t\t\t\t\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/data?${params.toString()}`, {\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tconst oldAlerts = this.alerts;\n\t\t\t\t\t\tthis.alerts = result.data.alerts || [];\n\t\t\t\t\t\tthis.groups = result.data.groups || [];\n\t\t\t\t\t\tthis.metadata = result.data.metadata;\n\t\t\t\t\t\tthis.settings = { ...this.settings, ...result.data.settings };\n\t\t\t\t\t\tthis.lastUpdateTime = Date.now();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Check for new alerts for notifications\n\t\t\t\t\t\tthis.checkForNewAlerts(oldAlerts, this.alerts);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Load custom alert colors\n\t\t\t\t\t\tawait this.loadAlertColors();\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.updateURL();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.showNotification('error', 'Failed to load alerts: ' + result.error);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error loading dashboard data:', error);\n\t\t\t\t\tthis.showNotification('error', 'Failed to load dashboard data');\n\t\t\t\t} finally {\n\t\t\t\t\tthis.loading = false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Incremental update - only fetch changes\n\t\t\tasync loadDashboardIncremental() {\n\t\t\t\t// Don't show loading spinner for incremental updates\n\t\t\t\ttry {\n\t\t\t\t\tconst params = new URLSearchParams();\n\t\t\t\t\t\n\t\t\t\t\t// Add current filters to request\n\t\t\t\t\tif (this.searchQuery) params.set('search', this.searchQuery);\n\t\t\t\t\tif (this.filters.alertmanagers.length > 0) params.set('alertmanagers', this.filters.alertmanagers.join(','));\n\t\t\t\t\tif (this.filters.severities.length > 0) params.set('severities', this.filters.severities.join(','));\n\t\t\t\t\tif (this.filters.statuses.length > 0) params.set('statuses', this.filters.statuses.join(','));\n\t\t\t\t\tif (this.filters.teams.length > 0) params.set('teams', this.filters.teams.join(','));\n\t\t\t\t\t\n\t\t\t\t\tparams.set('displayMode', this.displayMode);\n\t\t\t\t\tparams.set('viewMode', this.viewMode);\n\t\t\t\t\tparams.set('sortField', this.sortField);\n\t\t\t\t\tparams.set('sortDirection', this.sortDirection);\n\t\t\t\t\t\n\t\t\t\t\tif (this.acknowledgmentFilter) params.set('acknowledged', this.acknowledgmentFilter);\n\t\t\t\t\tif (this.commentsFilter) params.set('hasComments', this.commentsFilter);\n\t\t\t\t\t\n\t\t\t\t\t// Include current alert fingerprints for comparison\n\t\t\t\t\tconst currentFingerprints = this.alerts.map(a => a.fingerprint).join(',');\n\t\t\t\t\tif (currentFingerprints) {\n\t\t\t\t\t\tparams.set('clientAlerts', currentFingerprints);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (this.lastUpdateTime) {\n\t\t\t\t\t\tparams.set('lastUpdate', Math.floor(this.lastUpdateTime / 1000).toString());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/incremental?${params.toString()}`, {\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.applyIncrementalUpdate(result.data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Fallback to full refresh if incremental fails\n\t\t\t\t\t\tconsole.warn('Incremental update failed, falling back to full refresh');\n\t\t\t\t\t\tawait this.loadDashboardData();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error loading incremental data:', error);\n\t\t\t\t\t// Fallback to full refresh on error\n\t\t\t\t\tawait this.loadDashboardData();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Load alert colors from user preferences\n\t\t\tasync loadAlertColors(force = false) {\n\t\t\t\t// Skip loading if colors are already loaded and not forcing refresh\n\t\t\t\tif (!force && Object.keys(this.alertColors).length > 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tconsole.log('Loading alert colors...');\n\t\t\t\t\t\n\t\t\t\t\t// Build same URL parameters as dashboard data API\n\t\t\t\t\tconst params = new URLSearchParams();\n\t\t\t\t\t\n\t\t\t\t\t// Add current filters to request\n\t\t\t\t\tif (this.searchQuery) params.set('search', this.searchQuery);\n\t\t\t\t\tif (this.filters.alertmanagers.length > 0) params.set('alertmanagers', this.filters.alertmanagers.join(','));\n\t\t\t\t\tif (this.filters.severities.length > 0) params.set('severities', this.filters.severities.join(','));\n\t\t\t\t\tif (this.filters.statuses.length > 0) params.set('statuses', this.filters.statuses.join(','));\n\t\t\t\t\tif (this.filters.teams.length > 0) params.set('teams', this.filters.teams.join(','));\n\t\t\t\t\t\n\t\t\t\t\tparams.set('displayMode', this.displayMode);\n\t\t\t\t\tparams.set('viewMode', this.viewMode);\n\t\t\t\t\tparams.set('sortField', this.sortField);\n\t\t\t\t\tparams.set('sortDirection', this.sortDirection);\n\t\t\t\t\t\n\t\t\t\t\tif (this.acknowledgmentFilter) params.set('acknowledged', this.acknowledgmentFilter);\n\t\t\t\t\tif (this.commentsFilter) params.set('hasComments', this.commentsFilter);\n\t\t\t\t\t\n\t\t\t\t\tconst response = await fetch(`/api/v1/dashboard/alert-colors?${params.toString()}`, {\n\t\t\t\t\t\tcredentials: 'include'\n\t\t\t\t\t});\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tthis.alertColors = result.data.colors || {};\n\t\t\t\t\t\tthis.alertColorsTimestamp = result.data.timestamp || Date.now();\n\t\t\t\t\t\tconsole.log(`Loaded colors for ${Object.keys(this.alertColors).length} alerts`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('Failed to load alert colors:', result.error);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error loading alert colors:', error);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Invalidate and reload alert colors when preferences change\n\t\t\tasync refreshAlertColors() {\n\t\t\t\tconsole.log('Refreshing alert colors due to preference changes...');\n\t\t\t\tawait this.loadAlertColors(true);\n\t\t\t\t// Trigger UI update by reassigning the object to ensure reactivity\n\t\t\t\tthis.alertColors = { ...this.alertColors };\n\t\t\t},\n\n\t\t\t// Apply incremental changes to the dashboard\n\t\t\tapplyIncrementalUpdate(update) {\n\t\t\t\t// Create fingerprint maps for efficient lookups\n\t\t\t\tconst alertMap = new Map();\n\t\t\t\tthis.alerts.forEach((alert, index) => {\n\t\t\t\t\talertMap.set(alert.fingerprint, { alert, index });\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// Track if we need to notify about new alerts\n\t\t\t\tconst oldAlerts = [...this.alerts];\n\t\t\t\t\n\t\t\t\t// Remove alerts that are no longer present\n\t\t\t\tif (update.removedAlerts && update.removedAlerts.length > 0) {\n\t\t\t\t\tthis.alerts = this.alerts.filter(alert => \n\t\t\t\t\t\t!update.removedAlerts.includes(alert.fingerprint)\n\t\t\t\t\t);\n\t\t\t\t\t// Update selection to remove deleted alerts\n\t\t\t\t\tthis.selectedAlerts = this.selectedAlerts.filter(fingerprint => \n\t\t\t\t\t\t!update.removedAlerts.includes(fingerprint)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Update existing alerts\n\t\t\t\tif (update.updatedAlerts && update.updatedAlerts.length > 0) {\n\t\t\t\t\tconst newAlertMap = new Map();\n\t\t\t\t\tthis.alerts.forEach((alert, index) => {\n\t\t\t\t\t\tnewAlertMap.set(alert.fingerprint, { alert, index });\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tupdate.updatedAlerts.forEach(updatedAlert => {\n\t\t\t\t\t\tconst existing = newAlertMap.get(updatedAlert.fingerprint);\n\t\t\t\t\t\tif (existing) {\n\t\t\t\t\t\t\t// Update in place to maintain order\n\t\t\t\t\t\t\tthis.alerts[existing.index] = updatedAlert;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Add new alerts\n\t\t\t\tif (update.newAlerts && update.newAlerts.length > 0) {\n\t\t\t\t\tthis.alerts.push(...update.newAlerts);\n\t\t\t\t\t\n\t\t\t\t\t// Sort after adding new alerts to maintain correct order\n\t\t\t\t\tthis.alerts = this.sortAlerts(this.alerts);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Update metadata and settings\n\t\t\t\tif (update.metadata) {\n\t\t\t\t\tthis.metadata = update.metadata;\n\t\t\t\t}\n\t\t\t\tif (update.settings) {\n\t\t\t\t\tthis.settings = { ...this.settings, ...update.settings };\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Update colors for new and updated alerts\n\t\t\t\tif (update.colors && Object.keys(update.colors).length > 0) {\n\t\t\t\t\t// Merge new colors with existing ones\n\t\t\t\t\tthis.alertColors = { ...this.alertColors, ...update.colors };\n\t\t\t\t\tthis.alertColorsTimestamp = Date.now();\n\t\t\t\t\tconsole.log(`Updated colors for ${Object.keys(update.colors).length} alerts from incremental update`);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Update timestamp\n\t\t\t\tthis.lastUpdateTime = update.lastUpdateTime * 1000; // Convert to milliseconds\n\t\t\t\t\n\t\t\t\t// Check for new alerts for notifications\n\t\t\t\tif (update.newAlerts && update.newAlerts.length > 0) {\n\t\t\t\t\tthis.checkForNewAlerts(oldAlerts, this.alerts);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Sort alerts based on current sorting configuration\n\t\t\tsortAlerts(alerts) {\n\t\t\t\treturn [...alerts].sort((a, b) => {\n\t\t\t\t\tlet aVal, bVal;\n\t\t\t\t\t\n\t\t\t\t\tswitch (this.sortField) {\n\t\t\t\t\t\tcase 'alertName':\n\t\t\t\t\t\t\taVal = a.alertName.toLowerCase();\n\t\t\t\t\t\t\tbVal = b.alertName.toLowerCase();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'severity':\n\t\t\t\t\t\t\tconst severityOrder = { 'critical': 3, 'warning': 2, 'info': 1 };\n\t\t\t\t\t\t\taVal = severityOrder[a.severity] || 0;\n\t\t\t\t\t\t\tbVal = severityOrder[b.severity] || 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'status':\n\t\t\t\t\t\t\taVal = a.status.toLowerCase();\n\t\t\t\t\t\t\tbVal = b.status.toLowerCase();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'instance':\n\t\t\t\t\t\t\taVal = a.instance.toLowerCase();\n\t\t\t\t\t\t\tbVal = b.instance.toLowerCase();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'team':\n\t\t\t\t\t\t\taVal = (a.labels.team || '').toLowerCase();\n\t\t\t\t\t\t\tbVal = (b.labels.team || '').toLowerCase();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'duration':\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\taVal = a.duration;\n\t\t\t\t\t\t\tbVal = b.duration;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (this.sortDirection === 'asc') {\n\t\t\t\t\t\treturn aVal < bVal ? -1 : aVal > bVal ? 1 : 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn aVal > bVal ? -1 : aVal < bVal ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
