package scripts

templ DashboardModal() {
	<script>
		window.dashboardModalMixin = {
			async showAlertDetails(fingerprint) {
				this.alertDetailsLoading = true;
				this.showAlertModal = true;
				this.currentAlertTab = 'overview';
				this.alertDetails = null;

				const currentPath = window.location.pathname;
				const newPath = `/dashboard/alert/${fingerprint}`;
				if (currentPath !== newPath) {
					window.history.pushState({ alertId: fingerprint }, '', newPath);
				}

				try {
					const response = await fetch(`/api/v1/dashboard/alert/${fingerprint}`, {
						credentials: 'include'
					});
					const result = await response.json();
					
					if (result.success) {
						this.alertDetails = result.data;
					} else {
						console.error('Failed to load alert details: ' + result.error);
						this.closeAlertModal();
					}
				} catch (error) {
					console.error('Error loading alert details:', error);
					console.error('Failed to load alert details');
					this.closeAlertModal();
				} finally {
					this.alertDetailsLoading = false;
				}
			},

			closeAlertModal() {
				this.showAlertModal = false;
				this.alertDetails = null;
				this.currentAlertTab = 'overview';
				
				this.newCommentContent = '';
				this.commentSubmitting = false;
				this.commentDeleting = {};
				
				if (window.location.pathname.includes('/alert/')) {
					window.history.pushState({}, '', '/dashboard');
				}
			},

			acknowledgeCurrentAlert() {
				if (this.alertDetails?.alert) {
					this.currentAckAlert = this.alertDetails.alert;
					this.ackAction = 'single';
					this.ackReason = '';
					this.ackError = '';
					this.showAckModal = true;
				}
			},

			silenceCurrentAlert() {
				if (this.alertDetails?.alert) {
					this.currentSilenceAlert = this.alertDetails.alert;
					this.silenceAction = 'single';
					this.silenceReason = '';
					this.silenceError = '';
					this.silenceDuration = '1h';
					this.silenceDurationType = 'preset';
					this.customSilenceDuration = '';
					this.customDurationError = '';
					this.showSilenceModal = true;
				}
			},

			unsilenceCurrentAlert() {
				if (this.alertDetails?.alert) {
					this.processUnsilenceAction(this.alertDetails.alert.fingerprint);
				}
			},

			async processUnsilenceAction(fingerprint) {
				try {
					const response = await fetch('/api/v1/dashboard/bulk-action', {
						method: 'POST',
						credentials: 'include',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify({
							action: 'unsilence',
							fingerprints: [fingerprint],
							comment: 'Unsilenced from alert details'
						})
					});

					const result = await response.json();
					
					if (result.success) {
						console.log('Alert unsilenced successfully');
						// Refresh alert details to show updated state
						if (this.alertDetails?.alert?.fingerprint) {
							await this.showAlertDetails(this.alertDetails.alert.fingerprint);
						}
					} else {
						console.error('Failed to unsilence alert: ' + (result.error || 'Unknown error'));
					}
				} catch (error) {
					console.error('Error unsilencing alert:', error);
					console.error('Failed to unsilence alert');
				}
			},

			isAlertSilenced(alert) {
				if (!alert) return false;
				return alert.status?.state === 'suppressed' || 
					   alert.status?.state === 'silenced' || 
					   (alert.status?.silencedBy && alert.status.silencedBy.length > 0);
			},

			getSilenceButtonText(alert) {
				if (!alert) return 'Unsilence';
				const silenceCount = alert.status?.silencedBy?.length || 0;
				return silenceCount > 1 ? `Unsilence (${silenceCount})` : 'Unsilence';
			},

			// Comment Management Functions
			async addComment() {
				if (!this.newCommentContent.trim()) {
					console.log('Please enter a comment');
					return;
				}

				if (!this.alertDetails?.alert?.fingerprint) {
					console.error('Alert information not available');
					return;
				}

				this.commentSubmitting = true;
				
				try {
					const response = await fetch(`/api/v1/dashboard/alert/${this.alertDetails.alert.fingerprint}/comments`, {
						method: 'POST',
						credentials: 'include',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify({
							content: this.newCommentContent.trim()
						})
					});

					const result = await response.json();
					
					if (result.success) {
						console.log('Comment added successfully');
						this.newCommentContent = '';
						
						// Refresh alert details to show the new comment
						await this.refreshComments();
					} else {
						console.error('Failed to add comment: ' + result.error);
					}
				} catch (error) {
					console.error('Error adding comment:', error);
					console.error('Failed to add comment');
				} finally {
					this.commentSubmitting = false;
				}
			},

			async deleteComment(commentId) {
				if (!commentId || !this.alertDetails?.alert?.fingerprint) {
					console.error('Comment information not available');
					return;
				}

				this.commentDeleting[commentId] = true;
				
				try {
					const response = await fetch(`/api/v1/dashboard/alert/${this.alertDetails.alert.fingerprint}/comments/${commentId}`, {
						method: 'DELETE',
						credentials: 'include'
					});

					const result = await response.json();
					
					if (result.success) {
						console.log('Comment deleted successfully');
						
						// Refresh alert details to remove the deleted comment
						await this.refreshComments();
					} else {
						console.error('Failed to delete comment: ' + result.error);
					}
				} catch (error) {
					console.error('Error deleting comment:', error);
					console.error('Failed to delete comment');
				} finally {
					// Remove deleting state for this comment
					delete this.commentDeleting[commentId];
				}
			},

			async refreshComments() {
				if (!this.alertDetails?.alert?.fingerprint) {
					return;
				}

				try {
					const response = await fetch(`/api/v1/dashboard/alert/${this.alertDetails.alert.fingerprint}`, {
						credentials: 'include'
					});
					const result = await response.json();
					
					if (result.success) {
						// Update only the comments and maintain other alert details
						this.alertDetails.comments = result.data.comments || [];
						// Update comment count in alert object if it exists
						if (this.alertDetails.alert) {
							this.alertDetails.alert.commentCount = this.alertDetails.comments.length;
						}
					}
				} catch (error) {
					console.error('Error refreshing comments:', error);
				}
			},

			copyAlertAsIssue() {
				if (!this.alertDetails?.alert) {
					console.error('No alert data available');
					return;
				}

				const alert = this.alertDetails.alert;
				const comments = this.alertDetails.comments || [];
				
				const formatDate = (dateStr) => {
					if (!dateStr) return 'N/A';
					return new Date(dateStr).toLocaleString();
				};
				
				const calculateDuration = (start, end) => {
					if (!start) return 'N/A';
					const startTime = new Date(start);
					const endTime = end ? new Date(end) : new Date();
					const diffMs = endTime - startTime;
					
					const hours = Math.floor(diffMs / (1000 * 60 * 60));
					const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
					
					if (hours > 0) {
						return `${hours}h ${minutes}m`;
					}
					return `${minutes}m`;
				};

				// Build markdown content
				let markdown = `# Alert: ${alert.alertname || alert.labels?.alertname || 'Unknown'}\n\n`;
				
				// Summary section
				if (alert.summary) {
					markdown += `## Summary\n${alert.summary}\n\n`;
				}

				// Details section
				markdown += `## Details\n`;
				markdown += `- **Status**: ${(alert.status?.state || 'unknown').toUpperCase()}\n`;
				markdown += `- **Severity**: ${(alert.severity || 'unknown').toUpperCase()}\n`;
				if (alert.instance) {
					markdown += `- **Instance**: ${alert.instance}\n`;
				}
				markdown += `- **Started**: ${formatDate(alert.startsAt)}\n`;
				if (alert.endsAt) {
					markdown += `- **Ended**: ${formatDate(alert.endsAt)}\n`;
				}
				markdown += `- **Duration**: ${calculateDuration(alert.startsAt, alert.endsAt)}\n\n`;

				// Labels section
				if (alert.labels && Object.keys(alert.labels).length > 0) {
					markdown += `## Labels\n`;
					Object.entries(alert.labels).forEach(([key, value]) => {
						markdown += `- **${key}**: ${value}\n`;
					});
					markdown += '\n';
				}

				// Annotations section
				if (alert.annotations && Object.keys(alert.annotations).length > 0) {
					markdown += `## Annotations\n`;
					Object.entries(alert.annotations).forEach(([key, value]) => {
						markdown += `- **${key}**: ${value}\n`;
					});
					markdown += '\n';
				}

				// Comments section
				if (comments.length > 0) {
					markdown += `## Comments\n`;
					comments.forEach(comment => {
						const commentDate = formatDate(comment.createdAt);
						markdown += `**${comment.username}** (${commentDate}):\n`;
						markdown += `${comment.content}\n\n`;
					});
				}

				// Alert ID section
				markdown += `## Alert ID\n`;
				markdown += `\`${alert.fingerprint}\`\n`;

				// Copy to clipboard
				this.copyToClipboard(markdown);
				console.log('Alert copied as issue template');
			},

			async unacknowledgeCurrentAlert() {
				if (!this.alertDetails?.alert?.fingerprint) {
					console.error('No alert information available');
					return;
				}
				
				try {
					const request = {
						alertFingerprints: [this.alertDetails.alert.fingerprint],
						action: 'unacknowledge',
						comment: 'Unacknowledged from alert details'
					};

					const response = await fetch('/api/v1/dashboard/bulk-action', {
						method: 'POST',
						credentials: 'include',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify(request)
					});

					const result = await response.json();
					
					if (result.success) {
						console.log('Alert unacknowledged successfully');
						// Refresh alert details to show updated state
						if (this.alertDetails?.alert?.fingerprint) {
							await this.showAlertDetails(this.alertDetails.alert.fingerprint);
						}
					} else {
						console.error('Failed to unacknowledge alert: ' + (result.error || 'Unknown error'));
					}
				} catch (error) {
					console.error('Error unacknowledging alert:', error);
					console.error('Failed to unacknowledge alert');
				}
			},

			// Sentry Integration Functions  
			async loadSentryDataForTab() {
				// This function is called from the tab button click
				// Find the Sentry data component using document.querySelector since $refs doesn't work across components
				const sentryComponent = document.querySelector('[x-ref="sentryDataComponent"]');
				
				if (sentryComponent && sentryComponent._x_dataStack && sentryComponent._x_dataStack[0]) {
					// Get the Alpine component data
					const componentData = sentryComponent._x_dataStack[0];
					// Set loading state
					componentData.sentryLoading = true;
					componentData.sentryError = null;
					
					await this.loadSentryData(componentData);
				} else {
					console.error('Could not find Sentry data component. Element found:', !!sentryComponent, 
						'Has _x_dataStack:', !!(sentryComponent && sentryComponent._x_dataStack));
				}
			},

			async loadSentryData(component) {
				try {
					// Get current alert from the component that has alert details
					let alert = null;
					let fingerprint = null;
					
					// Try to get alert from the component's alert details
					if (component && component.alertDetails?.alert) {
						alert = component.alertDetails.alert;
						fingerprint = alert.fingerprint;
					} 
					// Fallback to current alert from dashboard instance
					else if (window.dashboardInstance && window.dashboardInstance.currentAlert) {
						alert = window.dashboardInstance.currentAlert;
						fingerprint = alert.fingerprint;
					}
					// Last resort: use alertDetails from parent modal component
					else if (this.alertDetails?.alert) {
						alert = this.alertDetails.alert;
						fingerprint = alert.fingerprint;
					}
					
					if (!alert || !fingerprint) {
						console.error('No current alert available for Sentry data');
						if (component) {
							component.sentryError = 'No alert data available';
							component.sentryLoading = false;
						}
						return;
					}

					console.log('Loading Sentry data for alert fingerprint:', fingerprint);

					const response = await fetch(`/api/v1/dashboard/sentry/${encodeURIComponent(fingerprint)}`, {
						credentials: 'include'
					});

					if (response.ok) {
						const result = await response.json();
						
						if (result.has_sentry_label) {
							if (result.auth_status?.has_api_token) {
								// User has token and can view data
								if (component) {
									component.sentryData = result;
									component.sentryError = null;
									component.hasSentryToken = true;
								}
							} else {
								// User needs to configure token
								if (component) {
									component.sentryData = null;
									component.sentryError = 'Sentry token not configured';
									component.hasSentryToken = false;
								}
							}
						} else {
							// Alert doesn't have sentry label
							if (component) {
								component.sentryData = null;
								component.sentryError = 'This alert does not have Sentry integration data';
								component.hasSentryToken = false;
							}
						}
					} else {
						console.error('Failed to load Sentry data:', response.status);
						if (component) {
							component.sentryError = 'Failed to load Sentry data';
						}
					}
				} catch (error) {
					console.error('Error loading Sentry data:', error);
					if (component) {
						component.sentryError = 'Error loading Sentry data: ' + error.message;
					}
				} finally {
					if (component) {
						component.sentryLoading = false;
					}
				}
			},

			// Helper methods for annotation buttons
			hasMatchingAnnotation(buttonConfig) {
				if (!buttonConfig || !buttonConfig.enabled) return false;
				const annotations = this.alertDetails?.alert?.annotations || {};
				return buttonConfig.annotation_keys?.some(key => annotations[key]);
			},

			getAnnotationUrl(buttonConfig) {
				const annotations = this.alertDetails?.alert?.annotations || {};
				const matchedKey = buttonConfig.annotation_keys?.find(key => annotations[key]);
				return matchedKey ? annotations[matchedKey] : null;
			},

			openAnnotationUrl(buttonConfig) {
				const url = this.getAnnotationUrl(buttonConfig);
				if (url) {
					window.open(url, '_blank');
				}
			}
		};

		// Global function for Sentry data loading that can be called from Alpine.js components
		window.loadSentryData = function() {
			// Get the parent dashboard component that has the modal mixin
			const dashboardComponent = window.dashboardInstance;
			if (dashboardComponent && dashboardComponent.loadSentryData) {
				// Pass the current Alpine.js component (this) to the function
				dashboardComponent.loadSentryData(this);
			} else {
				console.error('Dashboard instance not found or loadSentryData method not available');
				this.sentryError = 'Dashboard not properly initialized';
				this.sentryLoading = false;
			}
		};
	</script>
}